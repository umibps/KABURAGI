// Visual Studio 2005以降では古いとされる関数を使用するので
	// 警告が出ないようにする
#if defined _MSC_VER && _MSC_VER >= 1400
# define _CRT_SECURE_NO_DEPRECATE
# define _CRT_NONSTDC_NO_DEPRECATE
#endif

#include <string.h>
#include <stdlib.h>
#include <math.h>
#include <zlib.h>
#include <glib/gstdio.h>
#include "application.h"
#include "brushes.h"
#include "ini_file.h"
#include "utils.h"
#include "display.h"
#include "image_read_write.h"
#include "memory.h"
#include "anti_alias.h"
#include "script.h"

#include "./gui/GTK/gtk_widgets.h"

#ifdef _OPENMP
# include <omp.h>
#endif

#if !defined(USE_QT) || (defined(USE_QT) && USE_QT != 0)
# include "gui/GTK/utils_gtk.h"
#endif

#ifdef __cplusplus
extern "C" {
#endif

static void DummyBrushCallBack(
	DRAW_WINDOW* window,
	FLOAT_T x,
	FLOAT_T y,
	FLOAT_T pressure,
	BRUSH_CORE *core,
	void* state
)
{
}

static void DummyBrushDrawCursor(
	DRAW_WINDOW* window,
	FLOAT_T x,
	FLOAT_T y,
	void* data
)
{
}

static void DefaultReleaseCallBack(
	DRAW_WINDOW* window,
	FLOAT_T x,
	FLOAT_T y,
	FLOAT_T pressure,
	BRUSH_CORE *core,
	void* state
)
{
	if(((GdkEventButton*)state)->button == 1)
	{
		AddBrushHistory(core, window->active_layer);

		window->layer_blend_functions[window->work_layer->layer_mode](window->work_layer, window->active_layer);

		(void)memset(window->work_layer->pixels, 0, window->work_layer->stride*window->work_layer->height);

		window->work_layer->layer_mode = LAYER_BLEND_NORMAL;
	}
}

static void DefaultEditSelectionReleaseCallBack(
	DRAW_WINDOW* window,
	FLOAT_T x,
	FLOAT_T y,
	FLOAT_T pressure,
	BRUSH_CORE *core,
	void* state
)
{
	if(((GdkEventButton*)state)->button == 1)
	{
		AddSelectionEditHistory(core, window->selection);

		g_blend_selection_funcs[window->selection->layer_mode](window->work_layer, window->selection);

		(void)memset(window->work_layer->pixels, 0, window->work_layer->stride*window->work_layer->height);

		window->work_layer->layer_mode = LAYER_BLEND_NORMAL;
		window->selection->layer_mode = SELECTION_BLEND_NORMAL;
	}
}

/***********************************************************
* PencilPressCallBack関数                                  *
* 鉛筆ツール使用時のマウスクリックに対するコールバック関数 *
* 引数                                                     *
* window	: 描画領域の情報                               *
* x			: X座標                                        *
* y			: Y座標                                        *
* pressure	: 筆圧                                         *
* core		: ブラシの情報                                 *
* state		: マウスの状態                                 *
***********************************************************/
static void PencilPressCallBack(
	DRAW_WINDOW* window,
	FLOAT_T x,
	FLOAT_T y,
	FLOAT_T pressure,
	BRUSH_CORE* core,
	void* state
)
{
	// 左クリックならば
	if(((GdkEventButton*)state)->button == 1)
	{
		// ブラシの詳細情報にキャスト
		PENCIL *pen = (PENCIL*)core->brush_data;
		// 描画範囲のイメージ情報
		cairo_t *update;
		cairo_surface_t *update_surface;
		// ブラシの半径と不透明度
		FLOAT_T r, alpha;
		// 座標の最大・最小値
		FLOAT_T min_x, min_y, max_x, max_y;
		// ブラシの座標指定用
		cairo_matrix_t matrix;
		// 筆圧によるブラシ縮小用
		FLOAT_T zoom;
		// ピクセルデータをリセットする座標
		int start_x, start_y;
		// ピクセルデータリセット時の高さと1行分のバイト数
		int height, stride;
		// 不透明部保護時のマスク用
		uint8 *mask;
		int i;	// for文用のカウンタ

		// 作業レイヤーの合成方法を設定
		window->work_layer->layer_mode = pen->blend_mode;

		// 最低筆圧のチェック
		if(pressure < pen->minimum_pressure)
		{
			pressure = pen->minimum_pressure;
		}

		// 筆圧でサイズ変更するかフラグを見てからブラシの半径決定
		if((pen->flags & BRUSH_FLAG_SIZE) == 0)
		{
			r = pen->r;
			zoom = 1;
		}
		else
		{
			r = pen->r * pressure;
			zoom = 1/pressure;
		}
		// 筆圧で不透明度変更するかフラグを見てから不透明度決定
		alpha = ((pen->flags & BRUSH_FLAG_FLOW) == 0) ? 1 : pressure;

		// マウスの座標とブラシの半径から
			// 描画する座標の最大・最小値を決定
		min_x = x - r, min_y = y - r;
		max_x = x + r + 1, max_y = y + r + 1;

		// 更新範囲のサーフェース作成
		update_surface = cairo_surface_create_for_rectangle(
			window->work_layer->surface_p, min_x, min_y, r*2+1, r*2+1);
		update = cairo_create(update_surface);

		// 今回の座標を記憶
		pen->before_x = x, pen->before_y = y;

		// 描画領域からはみ出たら修正
		if(min_x < 0.0)
		{
			min_x = 0.0;
		}
		if(min_y < 0.0)
		{
			min_y = 0.0;
		}
		if(max_x > window->work_layer->width)
		{
			max_x = window->work_layer->width;
		}
		if(max_y > window->work_layer->height)
		{
			max_y = window->work_layer->height;
		}

		// 再描画の範囲を指定
		window->update.x = start_x = (int)min_x;
		window->update.y = start_y = (int)min_y;
		window->update.width = (int)max_x - window->update.x;
		stride = (int)window->update.width * 4;
		window->update.height = (int)max_y - window->update.y;
		height = (int)window->update.height;

		// 現在の座標の最大・最小値を記憶しておく
		core->min_x = min_x, core->min_y = min_y;
		core->max_x = max_x, core->max_y = max_y;

		// 作業レイヤーの描画内容の合成方法を通常にしてから
		cairo_set_operator(window->work_layer->cairo_p, CAIRO_OPERATOR_OVER);

		mask = window->mask_temp->pixels;
		if(window->app->textures.active_texture == 0)
		{
			if((window->flags & DRAW_WINDOW_HAS_SELECTION_AREA) == 0)
			{
				if((window->active_layer->flags & LAYER_LOCK_OPACITY) == 0)
				{
					cairo_matrix_init_scale(&matrix, zoom, zoom);
					cairo_pattern_set_matrix(core->brush_pattern, &matrix);
					cairo_set_source(update, core->brush_pattern);
					cairo_paint_with_alpha(update, alpha);
				}
				else
				{
					cairo_matrix_init_scale(&matrix, zoom, zoom);
					cairo_pattern_set_matrix(core->brush_pattern, &matrix);
					cairo_set_source(core->temp_cairo, core->brush_pattern);
					cairo_paint_with_alpha(core->temp_cairo, alpha);
					cairo_matrix_init_translate(&matrix, 0,0);
					cairo_pattern_set_matrix(core->temp_pattern, &matrix);
					cairo_set_source(update, core->temp_pattern);
					cairo_mask_surface(update,
						window->active_layer->surface_p, - x + r, - y + r);
				}
			}
			else
			{
				if((window->active_layer->flags & LAYER_LOCK_OPACITY) == 0)
				{
					cairo_matrix_init_scale(&matrix, zoom, zoom);
					cairo_pattern_set_matrix(core->brush_pattern, &matrix);
					cairo_set_source(core->temp_cairo, core->brush_pattern);
					cairo_paint_with_alpha(core->temp_cairo, alpha);
					cairo_matrix_init_translate(&matrix, 0, 0);
					cairo_pattern_set_matrix(core->temp_pattern, &matrix);
					cairo_set_source(update, core->temp_pattern);
					cairo_mask_surface(window->mask_temp->cairo_p,
						window->selection->surface_p, - x + r, - y + r);
				}
				else
				{
					cairo_surface_t *temp_surface = cairo_surface_create_for_rectangle(
						window->temp_layer->surface_p, start_x, start_y, r*2+1, r*2+1);
					cairo_t *update_temp = cairo_create(temp_surface);

					cairo_matrix_init_scale(&matrix, zoom, zoom);
					cairo_pattern_set_matrix(core->brush_pattern, &matrix);
					cairo_set_source(core->temp_cairo, core->brush_pattern);
					cairo_paint_with_alpha(core->temp_cairo, alpha);
					cairo_matrix_init_translate(&matrix, 0, 0);
					cairo_pattern_set_matrix(core->temp_pattern, &matrix);
					cairo_set_source(update, core->temp_pattern);

					for(i=0; i<height; i++)
					{
						(void)memset(&window->temp_layer->pixels[
							(i+start_y)*window->temp_layer->stride+start_x*4],
							0, stride
						);
					}

					cairo_mask_surface(update,
						window->selection->surface_p, - x + r, - y + r);
					cairo_set_source_surface(update_temp,
						update_surface, 0, 0);
					cairo_mask_surface(update_temp,
						window->active_layer->surface_p, - x + r, - y + r);

					mask = window->temp_layer->pixels;

					cairo_surface_destroy(temp_surface);
					cairo_destroy(update_temp);
				}
			}
		}
		else
		{
			cairo_surface_t *temp_surface = cairo_surface_create_for_rectangle(
				window->temp_layer->surface_p, min_x, min_y, r*2+1, r*2+1);
			cairo_t *update_temp = cairo_create(temp_surface);

			for(i=0; i<height; i++)
			{
				(void)memset(&window->temp_layer->pixels[
					(i+start_y)*window->temp_layer->stride+start_x*4],
					0, stride
				);
			}

			if((window->flags & DRAW_WINDOW_HAS_SELECTION_AREA) == 0)
			{
				if((window->active_layer->flags & LAYER_LOCK_OPACITY) == 0)
				{
					cairo_matrix_init_scale(&matrix, zoom, zoom);
					cairo_pattern_set_matrix(core->brush_pattern, &matrix);
					cairo_set_source(update_temp, core->brush_pattern);
					cairo_paint_with_alpha(update_temp, alpha);
				}
				else
				{
					cairo_matrix_init_scale(&matrix, zoom, zoom);
					cairo_pattern_set_matrix(core->brush_pattern, &matrix);
					cairo_set_source(core->temp_cairo, core->brush_pattern);
					cairo_paint_with_alpha(core->temp_cairo, alpha);
					cairo_matrix_init_translate(&matrix, 0, 0);
					cairo_pattern_set_matrix(core->temp_pattern, &matrix);
					cairo_set_source(update_temp, core->temp_pattern);
					cairo_mask_surface(update_temp,
						window->active_layer->surface_p, - x + r, - y + r);
				}

				cairo_set_source_surface(update, temp_surface, 0, 0);
				cairo_mask_surface(update, window->texture->surface_p, - x + r, - y + r);

				mask = window->temp_layer->pixels;
			}
			else
			{
				if((window->active_layer->flags & LAYER_LOCK_OPACITY) == 0)
				{
					cairo_matrix_init_scale(&matrix, zoom, zoom);
					cairo_pattern_set_matrix(core->brush_pattern, &matrix);
					cairo_set_source(core->temp_cairo, core->brush_pattern);
					cairo_paint_with_alpha(core->temp_cairo, alpha);
					cairo_matrix_init_translate(&matrix, 0, 0);
					cairo_pattern_set_matrix(core->temp_pattern, &matrix);
					cairo_set_source(update, core->temp_pattern);
					cairo_mask_surface(update,
						window->selection->surface_p, - x + r, - y + r);

					for(i=0; i<height; i++)
					{
						(void)memset(&window->temp_layer->pixels[
							(i+start_y)*window->temp_layer->stride+start_x*4],
							0, stride
						);
					}

					cairo_set_source_surface(update_temp, update_surface, 0, 0);
					cairo_mask_surface(update_temp, window->texture->surface_p, - x + r, - y + r);
				}
				else
				{
					cairo_matrix_init_scale(&matrix, zoom, zoom);
					cairo_pattern_set_matrix(core->brush_pattern, &matrix);
					cairo_set_source(core->temp_cairo, core->brush_pattern);
					cairo_paint_with_alpha(core->temp_cairo, alpha);
					cairo_matrix_init_translate(&matrix, 0, 0);
					cairo_pattern_set_matrix(core->temp_pattern, &matrix);
					cairo_set_source(update, core->temp_pattern);

					for(i=0; i<height; i++)
					{
						(void)memset(&window->temp_layer->pixels[
							(i+start_y)*window->temp_layer->stride+start_x*4],
							0, stride
						);
					}

					cairo_mask_surface(update,
						window->selection->surface_p, - x + r, - y + r);
					cairo_set_source_surface(update_temp,
						update_surface, 0, 0);
					cairo_mask_surface(update_temp,
						window->active_layer->surface_p, - x + r, - y + r);

					for(i=0; i<height; i++)
					{
						(void)memset(&window->mask_temp->pixels[
							(i+start_y)*window->mask_temp->stride+start_x*4],
							0, stride
						);
					}

					cairo_set_source_surface(update, temp_surface, 0, 0);
					cairo_mask_surface(update, window->texture->surface_p, - x + r, - y + r);
				}
			}

			cairo_surface_destroy(temp_surface);
			cairo_destroy(update_temp);
		}

		cairo_surface_destroy(update_surface);
		cairo_destroy(update);


		window->flags |= DRAW_WINDOW_UPDATE_PART;
	}
}

#define PencilEditSelectionPressCallBack PencilPressCallBack

static void PencilMotionCallBack(
	DRAW_WINDOW* window,
	FLOAT_T x,
	FLOAT_T y,
	FLOAT_T pressure,
	BRUSH_CORE *core,
	void* state
)
{
	if(((*(GdkModifierType*)state) & GDK_BUTTON1_MASK) != 0)
	{
		PENCIL* pen = (PENCIL*)core->brush_data;
		cairo_matrix_t matrix;
		// 描画範囲のイメージ情報
		cairo_t *update;
		cairo_surface_t *update_surface;
		FLOAT_T r, step, alpha, d;
		FLOAT_T min_x, min_y, max_x, max_y;
		FLOAT_T draw_x = pen->before_x, draw_y = pen->before_y;
		FLOAT_T dx, dy, diff_x, diff_y;
		FLOAT_T zoom;
		int start_x, width, start_y, height;
		int stride;
		uint8 *color = *core->color;
		uint8 *work_pixel = window->work_layer->pixels;
		uint8 *mask;
		int i;

		// 最低筆圧のチェック
		if(pressure < pen->minimum_pressure)
		{
			pressure = pen->minimum_pressure;
		}

		if((pen->flags & BRUSH_FLAG_SIZE) == 0)
		{
			r = pen->r;
			zoom = 1;
		}
		else
		{
			r = pen->r * pressure;
			zoom = 1/pressure;
		}
		step = r * BRUSH_STEP;
		if(step < MIN_BRUSH_STEP)
		{
			dx = 0;
			goto skip_draw;
		}
		alpha = ((pen->flags & BRUSH_FLAG_FLOW) == 0) ?
			1 : pressure;
		dx = x-pen->before_x, dy = y-pen->before_y;
		d = sqrt(dx*dx+dy*dy);
		diff_x = step * dx/d, diff_y = step * dy/d;

		min_x = x - r*2, min_y = y - r*2;
		max_x = x + r*2, max_y = y + r*2;

		if((pen->flags & BRUSH_FLAG_ANTI_ALIAS) != 0)
		{
			max_x++;
			max_y++;
		}

		if(min_x < 0.0)
		{
			min_x = 0.0;
		}
		if(min_y < 0.0)
		{
			min_y = 0.0;
		}
		if(max_x > window->work_layer->width)
		{
			max_x = window->work_layer->width;
		}
		if(max_y > window->work_layer->height)
		{
			max_y = window->work_layer->height;
		}

		if(window->update.x > min_x)
		{
			window->update.width += window->update.x - (int)min_x;
			window->update.x = (int)min_x;
		}
		if(window->update.width + window->update.x < max_x)
		{
			window->update.width += (int)max_x - window->update.width + window->update.x;
		}
		if(window->update.y > min_y)
		{
			window->update.height += window->update.y - (int)min_y;
			window->update.y = (int)min_y;
		}
		if(window->update.height + window->update.y < max_y)
		{
			window->update.height += (int)max_y - window->update.height + window->update.y;
		}

		if(core->min_x > min_x)
		{
			core->min_x = min_x;
		}
		if(core->min_y > min_y)
		{
			core->min_y = min_y;
		}
		if(core->max_x < max_x)
		{
			core->max_x = max_x;
		}
		if(core->max_y < max_y)
		{
			core->max_y = max_y;
		}

		dx = d;
		do
		{
			start_x = (int)(draw_x - r);
			start_y = (int)(draw_y - r);
			width = (int)(draw_x + r + 1);
			height = (int)(draw_y + r + 1);

			if(start_x < 0)
			{
				start_x = 0;
			}
			else if(start_x > window->work_layer->width)
			{
				goto skip_draw;
			}
			if(start_y < 0)
			{
				start_y = 0;
			}
			else if(start_y > window->work_layer->height)
			{
				goto skip_draw;
			}
			if(width > window->work_layer->width)
			{
				width = window->work_layer->width - start_x;
			}
			else
			{
				width = width - start_x;
			}
			if(height > window->work_layer->height)
			{
				height = window->work_layer->height - start_y;
			}
			else
			{
				height = height - start_y;
			}
			stride = width*4;

			if(width <= 0 || height <= 0)
			{
				goto skip_draw;
			}

			update_surface = cairo_surface_create_for_rectangle(
				window->mask_temp->surface_p, draw_x - r, draw_y - r,
					r*2+2, r*2+2);
			update = cairo_create(update_surface);

			window->flags |= DRAW_WINDOW_UPDATE_PART;

			for(i=0; i<height; i++)
			{
				(void)memset(&window->mask_temp->pixels[(i+start_y)*window->mask_temp->stride+start_x*4],
					0, stride);
			}

			cairo_set_operator(window->mask_temp->cairo_p, CAIRO_OPERATOR_OVER);

			mask = window->mask_temp->pixels;
			if(window->app->textures.active_texture == 0)
			{
				if((window->flags & DRAW_WINDOW_HAS_SELECTION_AREA) == 0)
				{
					if((window->active_layer->flags & LAYER_LOCK_OPACITY) == 0)
					{
						cairo_matrix_init_scale(&matrix, zoom, zoom);
						cairo_pattern_set_matrix(core->brush_pattern, &matrix);
						cairo_set_source(update, core->brush_pattern);
						cairo_paint_with_alpha(update, alpha);
					}
					else
					{
						cairo_matrix_init_scale(&matrix, zoom, zoom);
						cairo_pattern_set_matrix(core->brush_pattern, &matrix);
						cairo_set_source(core->temp_cairo, core->brush_pattern);
						cairo_paint_with_alpha(core->temp_cairo, alpha);
						cairo_matrix_init_translate(&matrix, 0, 0);
						cairo_pattern_set_matrix(core->temp_pattern, &matrix);
						cairo_set_source(update, core->temp_pattern);
						cairo_mask_surface(update,
							window->active_layer->surface_p, - draw_x + r, - draw_y + r);
					}
				}
				else
				{
					if((window->active_layer->flags & LAYER_LOCK_OPACITY) == 0)
					{
						cairo_matrix_init_scale(&matrix, zoom, zoom);
						cairo_pattern_set_matrix(core->brush_pattern, &matrix);
						cairo_set_source(core->temp_cairo, core->brush_pattern);
						cairo_paint_with_alpha(core->temp_cairo, alpha);
						cairo_matrix_init_translate(&matrix, 0, 0);
						cairo_pattern_set_matrix(core->temp_pattern, &matrix);
						cairo_set_source(update, core->temp_pattern);
						cairo_mask_surface(update,
							window->selection->surface_p, - draw_x + r, - draw_y + r);
					}
					else
					{
						cairo_surface_t *temp_surface = cairo_surface_create_for_rectangle(
							window->temp_layer->surface_p, start_x, start_y, r*2+1, r*2+1);
						cairo_t *update_temp = cairo_create(temp_surface);

						cairo_matrix_init_scale(&matrix, zoom, zoom);
						cairo_pattern_set_matrix(core->brush_pattern, &matrix);
						cairo_set_source(core->temp_cairo, core->brush_pattern);
						cairo_paint_with_alpha(core->temp_cairo, alpha);
						cairo_matrix_init_translate(&matrix, 0, 0);
						cairo_pattern_set_matrix(core->temp_pattern, &matrix);
						cairo_set_source(update, core->temp_pattern);

						for(i=0; i<height; i++)
						{
							(void)memset(&window->temp_layer->pixels[
								(i+start_y)*window->temp_layer->stride+start_x*4],
								0, stride
							);
						}

						cairo_mask_surface(update,
							window->selection->surface_p, - draw_x + r, - draw_y + r);
						cairo_set_source_surface(update_temp,
							update_surface, 0, 0);
						cairo_mask_surface(update_temp,
							window->active_layer->surface_p, - draw_x + r, - draw_y + r);

						mask = window->temp_layer->pixels;

						cairo_surface_destroy(temp_surface);
						cairo_destroy(update_temp);
					}
				}
			}
			else
			{
				cairo_surface_t *temp_surface = cairo_surface_create_for_rectangle(
					window->temp_layer->surface_p, start_x, start_y, r*2+1, r*2+1);
				cairo_t *update_temp = cairo_create(temp_surface);

				if((window->flags & DRAW_WINDOW_HAS_SELECTION_AREA) == 0)
				{
					if((window->active_layer->flags & LAYER_LOCK_OPACITY) == 0)
					{
						cairo_matrix_init_scale(&matrix, zoom, zoom);
						cairo_pattern_set_matrix(core->brush_pattern, &matrix);
						cairo_set_source(update, core->brush_pattern);
						cairo_paint_with_alpha(update, alpha);
					}
					else
					{
						cairo_matrix_init_scale(&matrix, zoom, zoom);
						cairo_pattern_set_matrix(core->brush_pattern, &matrix);
						cairo_set_source(core->temp_cairo, core->brush_pattern);
						cairo_paint_with_alpha(core->temp_cairo, alpha);
						cairo_matrix_init_translate(&matrix, 0, 0);
						cairo_pattern_set_matrix(core->temp_pattern, &matrix);
						cairo_set_source(update, core->temp_pattern);
						cairo_mask_surface(update,
							window->active_layer->surface_p, - draw_x + r, - draw_y + r);
					}

					for(i=0; i<height; i++)
					{
						(void)memset(&window->temp_layer->pixels[
							(i+start_y)*window->temp_layer->stride+start_x*4],
							0, stride
						);
					}

					cairo_set_source_surface(update_temp, update_surface, 0, 0);
					cairo_mask_surface(update_temp, window->texture->surface_p, - draw_x + r, - draw_y + r);

					mask = window->temp_layer->pixels;
				}
				else
				{
					if((window->active_layer->flags & LAYER_LOCK_OPACITY) == 0)
					{
						cairo_matrix_init_scale(&matrix, zoom, zoom);
						cairo_pattern_set_matrix(core->brush_pattern, &matrix);
						cairo_set_source(core->temp_cairo, core->brush_pattern);
						cairo_paint_with_alpha(core->temp_cairo, alpha);
						cairo_matrix_init_translate(&matrix, 0, 0);
						cairo_pattern_set_matrix(core->temp_pattern, &matrix);
						cairo_set_source(update, core->temp_pattern);
						cairo_mask_surface(update,
							window->selection->surface_p, - draw_x + r, - draw_y + r);

						for(i=0; i<height; i++)
						{
							(void)memset(&window->temp_layer->pixels[
								(i+start_y)*window->temp_layer->stride+start_x*4],
								0, stride
							);
						}

						cairo_set_source_surface(update_temp, update_surface, 0, 0);
						cairo_mask_surface(update_temp, window->texture->surface_p, - draw_x + r, - draw_y + r);

						mask = window->temp_layer->pixels;
					}
					else
					{
						cairo_matrix_init_scale(&matrix, zoom, zoom);
						cairo_pattern_set_matrix(core->brush_pattern, &matrix);
						cairo_set_source(core->temp_cairo, core->brush_pattern);
						cairo_paint_with_alpha(core->temp_cairo, alpha);
						cairo_matrix_init_translate(&matrix, 0, 0);
						cairo_pattern_set_matrix(core->temp_pattern, &matrix);
						cairo_set_source(update, core->temp_pattern);

						for(i=0; i<height; i++)
						{
							(void)memset(&window->temp_layer->pixels[
								(i+start_y)*window->temp_layer->stride+start_x*4],
								0, stride
							);
						}

						cairo_mask_surface(update,
							window->selection->surface_p, - draw_x + r, - draw_y + r);
						cairo_set_source_surface(update_temp,
							update_surface, 0, 0);
						cairo_mask_surface(update_temp,
							window->active_layer->surface_p, - draw_x + r, - draw_y + r);

						for(i=0; i<height; i++)
						{
							(void)memset(&window->mask_temp->pixels[
								(i+start_y)*window->mask_temp->stride+start_x*4],
								0, stride
							);
						}

						cairo_set_source_surface(update, temp_surface, 0, 0);
						cairo_mask_surface(update, window->texture->surface_p, - draw_x + r, - draw_y + r);
					}
				}

				cairo_surface_destroy(temp_surface);
				cairo_destroy(update_temp);
			}

			cairo_surface_destroy(update_surface);
			cairo_destroy(update);

#ifdef _OPENMP
			if(height <= MINIMUM_PARALLEL_SIZE)
			{
				omp_set_dynamic(FALSE);
				omp_set_num_threads(1);
			}
#pragma omp parallel for firstprivate(width, work_pixel, start_x, start_y)
#endif
			for(i=0; i<height; i++)
			{
				uint8 *ref_pix = &work_pixel[
					(start_y+i)*window->work_layer->stride+start_x*4];
				uint8 *mask_pix = &mask[(start_y+i)*window->work_layer->stride
					+start_x*4];
				int j;

				for(j=0; j<width; j++, ref_pix+=4, mask_pix+=4)
				{
					if(ref_pix[3] < mask_pix[3])
					{
						ref_pix[0] = (uint8)((uint32)(((int)mask_pix[0]-(int)ref_pix[0])
							* mask_pix[3] >> 8) + ref_pix[0]);
						ref_pix[1] = (uint8)((uint32)(((int)mask_pix[1]-(int)ref_pix[1])
							* mask_pix[3] >> 8) + ref_pix[1]);
						ref_pix[2] = (uint8)((uint32)(((int)mask_pix[2]-(int)ref_pix[2])
							* mask_pix[3] >> 8) + ref_pix[2]);
						ref_pix[3] = (uint8)((uint32)(((int)mask_pix[3]-(int)ref_pix[3])
							* mask_pix[3] >> 8) + ref_pix[3]);
					}
				}
			}

#ifdef _OPENMP
			omp_set_dynamic(TRUE);
			omp_set_num_threads(core->app->max_threads);
#endif
			// アンチエイリアスを適用
			if((pen->flags & BRUSH_FLAG_ANTI_ALIAS) != 0)
			{
				ANTI_ALIAS_RECTANGLE range = {start_x - 1, start_y - 1,
					width + 3, height + 3};
				AntiAliasLayer(window->work_layer, window->temp_layer, &range);
			}
skip_draw:
			dx -= step;
			if(dx < 1)
			{
				break;
			}
			else if(dx >= step)
			{
				draw_x += diff_x, draw_y += diff_y;
			}
			else
			{
				draw_x = x;
				draw_y = y;
			}
		} while(1);

		pen->before_x = x, pen->before_y = y;
		window->flags |= DRAW_WINDOW_UPDATE_PART;
	}
}

#define PencilEditSelectionMotionCallBack PencilMotionCallBack

static void PencilReleaseCallBack(
	DRAW_WINDOW* window,
	FLOAT_T x,
	FLOAT_T y,
	FLOAT_T pressure,
	BRUSH_CORE *core,
	void* state
)
{
	if(((GdkEventButton*)state)->button == 1)
	{
		AddBrushHistory(core, window->active_layer);

		window->update.surface_p = cairo_surface_create_for_rectangle(
			window->active_layer->surface_p, window->update.x, window->update.y,
				window->update.width, window->update.height);
		window->update.cairo_p = cairo_create(window->update.surface_p);

		window->part_layer_blend_functions[window->work_layer->layer_mode](window->work_layer, &window->update);

		(void)memset(window->work_layer->pixels, 0, window->work_layer->stride*window->work_layer->height);

		cairo_surface_destroy(window->update.surface_p);
		cairo_destroy(window->update.cairo_p);

		window->work_layer->layer_mode = LAYER_BLEND_NORMAL;
	}
}

#define PencilEditSelectionReleaseCallBack DefaultEditSelectionReleaseCallBack

static void PencilDrawCursor(
	DRAW_WINDOW* window,
	FLOAT_T x,
	FLOAT_T y,
	void* data
)
{
	PENCIL* pen = (PENCIL*)data;
	FLOAT_T r = pen->r * window->zoom_rate;
	cairo_set_line_width(window->disp_temp->cairo_p, 1.0);
	cairo_set_source_rgb(window->disp_temp->cairo_p, 1, 1, 1);
	cairo_arc(window->disp_temp->cairo_p, x, y, r, 0, 2*G_PI);
	cairo_stroke(window->disp_temp->cairo_p);

	cairo_rectangle(window->disp_layer->cairo_p, x - r, y - r,
		(r + BRUSH_UPDATE_MARGIN) * 2, (r + BRUSH_UPDATE_MARGIN) * 2);
	cairo_clip(window->disp_layer->cairo_p);
}

static void PencilButtonUpdate(DRAW_WINDOW* window, FLOAT_T x, FLOAT_T y, PENCIL* pen)
{
	FLOAT_T r = pen->r * window->zoom_rate + 3;
	gtk_widget_queue_draw_area(window->window, (gint)(x - r - 1),
		(gint)(y - r - 1), (gint)(r * 2 + 3), (gint)(r * 2 + 3));
}

static void PencilMotionUpdate(DRAW_WINDOW* window, FLOAT_T x, FLOAT_T y, PENCIL* pen)
{
	FLOAT_T start_x, start_y;
	FLOAT_T width, height;
	FLOAT_T r = pen->r * window->zoom_rate  * 1.275 + BRUSH_UPDATE_MARGIN;

	if(window->before_cursor_x < x)
	{
		start_x = window->before_cursor_x - r;
		width = r * 2 + x - window->before_cursor_x;
	}
	else
	{
		start_x = x - r;
		width = r * 2 + window->before_cursor_x - x;
	}

	if(window->before_cursor_y < y)
	{
		start_y = window->before_cursor_y - r;
		height = r * 2 + y - window->before_cursor_y;
	}
	else
	{
		start_y = y - r;
		height = r * 2 + window->before_cursor_y - y;
	}

	gtk_widget_queue_draw_area(window->window,
		(gint)start_x, (gint)start_y, (gint)width + 2, (gint)height + 2);
}

static void PencilColorChange(const uint8 color[3], void* data)
{
	PENCIL *pen = (PENCIL*)data;
	BrushCoreSetCirclePattern(pen->core, pen->r, pen->outline_hardness * 0.01,
		0.5, pen->alpha * 0.01, color);
}

static void PencilScaleChange(
	GtkAdjustment* slider,
	gpointer data
)
{
	PENCIL* pen = (PENCIL*)data;
	pen->r = gtk_adjustment_get_value(slider) * 0.5;
	BrushCoreSetCirclePattern(pen->core, pen->r, pen->outline_hardness * 0.01,
		0.5, pen->alpha * 0.01, *pen->core->color);
}

static void PencilFlowChange(
	GtkAdjustment* slider,
	gpointer data
)
{
	PENCIL* pen = (PENCIL*)data;
	pen->alpha = gtk_adjustment_get_value(slider);
	BrushCoreSetCirclePattern(pen->core, pen->r, pen->outline_hardness * 0.01,
		0.5, pen->alpha * 0.01, *pen->core->color);
}

static void PencilPressureSizeChange(
	GtkWidget* widget,
	gpointer data
)
{
	PENCIL* pen = (PENCIL*)data;
	if(gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(widget)) == FALSE)
	{
		pen->flags &= ~(BRUSH_FLAG_SIZE);
	}
	else
	{
		pen->flags |= BRUSH_FLAG_SIZE;
	}
}

static void PencilPressureFlowChange(
	GtkWidget* widget,
	gpointer data
)
{
	PENCIL* pen = (PENCIL*)data;
	if(gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(widget)) == FALSE)
	{
		pen->flags &= ~(BRUSH_FLAG_FLOW);
	}
	else
	{
		pen->flags |= BRUSH_FLAG_FLOW;
	}
}

static void PencilSetAntiAlias(
	GtkWidget* widget,
	gpointer data
)
{
	PENCIL* pen = (PENCIL*)data;
	if(gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(widget)) == FALSE)
	{
		pen->flags &= ~(BRUSH_FLAG_ANTI_ALIAS);
	}
	else
	{
		pen->flags |= BRUSH_FLAG_ANTI_ALIAS;
	}
}

static void PencilOutlineHardnessChange(
	GtkAdjustment* slider,
	PENCIL* pen
)
{
	pen->outline_hardness =
		gtk_adjustment_get_value(slider);
	BrushCoreSetCirclePattern(pen->core, pen->r, pen->outline_hardness * 0.01,
		0.5, pen->alpha * 0.01, *pen->core->color);
}

static void PencilSetBlendMode(GtkComboBox* combo, PENCIL* pen)
{
	pen->blend_mode = (uint16)gtk_combo_box_get_active(combo);
}

static void PencilSetMinimumPressure(
	GtkAdjustment* slider,
	PENCIL* pen
)
{
	pen->minimum_pressure = gtk_adjustment_get_value(slider) * 0.01;
	if(pen->minimum_pressure < 0.005)
	{
		pen->minimum_pressure = 0.005;
	}
}

static GtkWidget* CreatePencilDetailUI(APPLICATION* app, BRUSH_CORE* core)
{
#define UI_FONT_SIZE 8.0
	PENCIL* pen = (PENCIL*)core->brush_data;
	GtkWidget* vbox = gtk_vbox_new(FALSE, 2);
	GtkWidget* hbox;
	GtkWidget* brush_scale;
	GtkWidget* table = gtk_table_new(1, 3, TRUE);
	GtkWidget* check_button;
	GtkWidget* label;
	GtkWidget *combo;
	GtkWidget* base_scale;
	GtkAdjustment* brush_scale_adjustment;
	char mark_up_buff[256];
	int i;

	pen->core = core;

	switch(pen->base_scale)
	{
	case 0:
		brush_scale_adjustment =
			GTK_ADJUSTMENT(gtk_adjustment_new(pen->r * 2, 0.1, 10.0, 0.1, 0.1, 0.0));
		break;
	case 1:
		brush_scale_adjustment =
			GTK_ADJUSTMENT(gtk_adjustment_new(pen->r * 2, 1.0, 100.0, 1.0, 1.0, 0.0));
		break;
	default:
		brush_scale_adjustment =
			GTK_ADJUSTMENT(gtk_adjustment_new(pen->r * 2, 5.0, 500.0, 1.0, 1.0, 0.0));
		break;
	}

	{
		const char *mag_str[] = {"x 0.1", "x 1", "x 10"};
		hbox = gtk_hbox_new(FALSE, 0);
		label = gtk_label_new("");
		(void)sprintf(mark_up_buff, "<span font_desc=\"%.2f\">%s : </span>",
			UI_FONT_SIZE * app->gui_scale, app->labels->tool_box.base_scale);
		gtk_label_set_markup(GTK_LABEL(label), mark_up_buff);
		gtk_box_pack_start(GTK_BOX(hbox), label, FALSE, FALSE, 0);

#if GTK_MAJOR_VERSION <= 2
		base_scale = gtk_combo_box_new_text();
		gtk_combo_box_append_text(GTK_COMBO_BOX(base_scale), mag_str[0]);
		gtk_combo_box_append_text(GTK_COMBO_BOX(base_scale), mag_str[1]);
		gtk_combo_box_append_text(GTK_COMBO_BOX(base_scale), mag_str[2]);
#else
		base_scale = gtk_combo_box_text_new();
		gtk_combo_box_text_append_text(GTK_COMBO_BOX_TEXT(base_scale), mag_str[0]);
		gtk_combo_box_text_append_text(GTK_COMBO_BOX_TEXT(base_scale), mag_str[1]);
		gtk_combo_box_text_append_text(GTK_COMBO_BOX_TEXT(base_scale), mag_str[2]);
#endif
		gtk_combo_box_set_active(GTK_COMBO_BOX(base_scale), pen->base_scale);
		gtk_box_pack_start(GTK_BOX(hbox), base_scale, TRUE, TRUE, 0);
		gtk_box_pack_start(GTK_BOX(vbox), hbox, FALSE, FALSE, 0);
	}

	brush_scale = SpinScaleNew(brush_scale_adjustment,
		app->labels->tool_box.brush_scale, 1);
	(void)g_signal_connect(G_OBJECT(brush_scale_adjustment), "value_changed",
		G_CALLBACK(PencilScaleChange), core->brush_data);
	gtk_table_attach_defaults(GTK_TABLE(table), brush_scale, 0, 3, 0, 1);
	gtk_box_pack_start(GTK_BOX(vbox), table, FALSE, TRUE, 0);

	g_object_set_data(G_OBJECT(base_scale), "scale", brush_scale);
	(void)g_signal_connect(G_OBJECT(base_scale), "changed", G_CALLBACK(SetBrushBaseScale), &pen->base_scale);

	brush_scale_adjustment =
		GTK_ADJUSTMENT(gtk_adjustment_new(pen->alpha, 0.0, 100.0, 1.0, 1.0, 0.0));
	brush_scale = SpinScaleNew(brush_scale_adjustment,
		app->labels->tool_box.flow, 1);
	(void)g_signal_connect(G_OBJECT(brush_scale_adjustment), "value_changed",
		G_CALLBACK(PencilFlowChange), core->brush_data);
	table = gtk_table_new(1, 3, TRUE);
	gtk_table_attach_defaults(GTK_TABLE(table), brush_scale, 0, 3, 0, 1);
	gtk_box_pack_start(GTK_BOX(vbox), table, FALSE, TRUE, 0);

	table = gtk_hbox_new(FALSE, 0);
	brush_scale_adjustment = GTK_ADJUSTMENT(gtk_adjustment_new(pen->outline_hardness,
		0, 100, 1, 1, 0));
	(void)g_signal_connect(G_OBJECT(brush_scale_adjustment), "value_changed",
		G_CALLBACK(PencilOutlineHardnessChange), core->brush_data);
	brush_scale = SpinScaleNew(brush_scale_adjustment,
		app->labels->tool_box.outline_hardness, 1);
	gtk_box_pack_start(GTK_BOX(table), brush_scale, TRUE, TRUE, 0);
	gtk_box_pack_start(GTK_BOX(vbox), table, FALSE, TRUE, 0);

	hbox = gtk_hbox_new(FALSE, 0);
	label = gtk_label_new("");
#if GTK_MAJOR_VERSION <= 2
	combo = gtk_combo_box_new_text();
#else
	combo = gtk_combo_box_text_new();
#endif
	(void)sprintf(mark_up_buff, "<span font_desc=\"%.2f\">%s : </span>",
		UI_FONT_SIZE * app->gui_scale, app->labels->layer_window.blend_mode);
	gtk_label_set_markup(GTK_LABEL(label), mark_up_buff);
	gtk_box_pack_start(GTK_BOX(hbox), label, FALSE, FALSE, 0);
	for(i=0; i<LAYER_BLEND_SLELECTABLE_NUM; i++)
	{
#if GTK_MAJOR_VERSION <= 2
		gtk_combo_box_append_text(GTK_COMBO_BOX(combo), app->labels->layer_window.blend_modes[i]);
#else
		gtk_combo_box_text_append_text(GTK_COMBO_BOX_TEXT(combo), app->labels->layer_window.blend_modes[i]);
#endif
	}
	gtk_combo_box_set_active(GTK_COMBO_BOX(combo), pen->blend_mode);
	(void)g_signal_connect(G_OBJECT(combo), "changed",
		G_CALLBACK(PencilSetBlendMode), pen);
	gtk_box_pack_start(GTK_BOX(hbox), combo, FALSE, TRUE, 0);
	gtk_box_pack_start(GTK_BOX(vbox), hbox, FALSE, TRUE, 0);

	table = gtk_hbox_new(FALSE, 0);
	label = gtk_label_new("");
	(void)sprintf(mark_up_buff, "<span font_desc=\"%.2f\">%s : </span>",
		UI_FONT_SIZE * app->gui_scale, app->labels->tool_box.pressure);
	gtk_label_set_markup(GTK_LABEL(label), mark_up_buff);
	gtk_box_pack_start(GTK_BOX(table), label, FALSE, TRUE, 0);
	check_button = gtk_check_button_new_with_label(app->labels->tool_box.scale);
	(void)g_signal_connect(G_OBJECT(check_button), "toggled", G_CALLBACK(PencilPressureSizeChange), core->brush_data);
	gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(check_button), pen->flags & BRUSH_FLAG_SIZE);
	gtk_box_pack_start(GTK_BOX(table), check_button, FALSE, TRUE, 0);
	check_button = gtk_check_button_new_with_label(app->labels->tool_box.flow);
	(void)g_signal_connect(G_OBJECT(check_button), "toggled", G_CALLBACK(PencilPressureFlowChange), core->brush_data);
	gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(check_button), pen->flags & BRUSH_FLAG_FLOW);
	gtk_box_pack_start(GTK_BOX(table), check_button, FALSE, TRUE, 0);
	gtk_box_pack_start(GTK_BOX(vbox), table, FALSE, TRUE, 0);

	check_button = gtk_check_button_new_with_label(app->labels->tool_box.anti_alias);
	(void)g_signal_connect(G_OBJECT(check_button), "toggled", G_CALLBACK(PencilSetAntiAlias), core->brush_data);
	gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(check_button), pen->flags & BRUSH_FLAG_ANTI_ALIAS);
	gtk_box_pack_start(GTK_BOX(vbox), check_button, FALSE, TRUE, 0);

	brush_scale_adjustment = GTK_ADJUSTMENT(gtk_adjustment_new(pen->minimum_pressure * 100,
		0, 100, 1, 1, 0));
	brush_scale = SpinScaleNew(brush_scale_adjustment, app->labels->tool_box.min_pressure, 0);
	(void)g_signal_connect(G_OBJECT(brush_scale_adjustment), "value_changed",
		G_CALLBACK(PencilSetMinimumPressure), pen);
	gtk_box_pack_start(GTK_BOX(vbox), brush_scale, FALSE, TRUE, 0);

	BrushCoreSetCirclePattern(core, pen->r, pen->outline_hardness * 0.01,
		0.5, pen->alpha * 0.01, *core->color);

	return vbox;
}

/***********************************************************
* HardPenButtonPressCallBack関数                           *
* 硬筆ペン使用時のマウスクリックに対するコールバック関数   *
* 引数                                                     *
* window	: 描画領域の情報                               *
* x			: X座標                                        *
* y			: Y座標                                        *
* pressure	: 筆圧                                         *
* core		: ブラシの情報                                 *
* state		: マウスの状態                                 *
***********************************************************/
static void HardPenButtonPressCallBack(
	DRAW_WINDOW* window,
	FLOAT_T x,
	FLOAT_T y,
	FLOAT_T pressure,
	BRUSH_CORE *core,
	void* state
)
{
	// 左クリックならば
	if(((GdkEventButton*)state)->button == 1)
	{
		// ブラシの詳細情報にキャスト
		HARD_PEN* pen = (HARD_PEN*)core->brush_data;
		// 部分描画用のCairoコンテキスト
		cairo_t *update, *temp_update;
		// 部分描画用のサーフェース
		cairo_surface_t *update_surface, *temp_surface;
		// ブラシの半径と不透明度
		FLOAT_T r, alpha;
		// 半径1以下になった際の不透明度
		FLOAT_T alpha_rate = 1;
		// 座標の最大・最小値
		FLOAT_T min_x, min_y, max_x, max_y;
		// 描画用パターン
		cairo_pattern_t *pattern;
		// ピクセルデータをリセットする座標
		int start_x, start_y;
		// ピクセルデータリセット時の幅・高さと1行分のバイト数
		int width, height, stride;
		// 不透明部保護時のマスク用
		uint8 *mask;
		int i;	// for文用のカウンタ

		// 作業レイヤーの合成方法を設定
		window->work_layer->layer_mode = pen->blend_mode;

		// 最低筆圧のチェック
		if(pressure < pen->minimum_pressure)
		{
			pressure = pen->minimum_pressure;
		}

		// 筆圧でサイズ変更するかフラグを見てからブラシの半径決定
		if((pen->flags & BRUSH_FLAG_SIZE) == 0)
		{
			r = pen->r;
		}
		else
		{
			r = pen->r * pressure;
		}
		// 筆圧で不透明度変更するかフラグを見てから不透明度決定
		alpha = ((pen->flags & BRUSH_FLAG_FLOW) == 0) ? pen->alpha * 0.01 : pen->alpha * 0.01 * pressure;

		if(r < 1)
		{
			alpha_rate = r;
			alpha *= r;
			r = 1;
		}

		// マウスの座標とブラシの半径から
			// 描画する座標の最大・最小値を決定
		min_x = x - r, min_y = y - r;
		max_x = x + r + 1, max_y = y + r + 1;

		// Cairoのコンテキスト情報を記憶
		cairo_save(window->temp_layer->cairo_p);
		cairo_save(window->mask_temp->cairo_p);

		// 今回の座標を記憶
		pen->before_x = x, pen->before_y = y;

		// 描画領域からはみ出たら修正
		if(min_x < 0.0)
		{
			min_x = 0.0;
		}
		if(min_y < 0.0)
		{
			min_y = 0.0;
		}
		if(max_x > window->work_layer->width)
		{
			max_x = window->work_layer->width;
		}
		if(max_y > window->work_layer->height)
		{
			max_y = window->work_layer->height;
		}

		if(min_x > window->width || min_y > window->height
			|| max_x < 0 || max_y < 0)
		{
			goto func_end;
		}

		window->update.x = start_x = (int)min_x;
		window->update.y = start_y = (int)min_y;
		width = (int)(window->update.width = (int)max_x - window->update.x);
		stride = (int)window->update.width * 4;
		window->update.height = (int)max_y - window->update.y;
		height = (int)window->update.height;

		// 現在の座標の最大・最小値を記憶しておく
		core->min_x = min_x, core->min_y = min_y;
		core->max_x = max_x, core->max_y = max_y;

		// 作業レイヤーの描画内容の合成方法を通常にしてから
		cairo_set_operator(window->work_layer->cairo_p, CAIRO_OPERATOR_OVER);

		// 描画エリアを0初期化
		for(i=0; i<height; i++)
		{
			(void)memset(&window->temp_layer->pixels[(start_y+i)*window->temp_layer->stride + start_x*4],
				0, stride);
		}
		for(i=0; i<height; i++)
		{
			(void)memset(&window->mask_temp->pixels[(start_y+i)*window->mask_temp->stride + start_x*4],
				0, stride);
		}

		// 描画用円形パターン作成
		pattern = cairo_pattern_create_radial(r, r, 0,
			r, r, r);
		cairo_pattern_set_extend(pattern, CAIRO_EXTEND_NONE);
#if !defined(USE_BGR_COLOR_SPACE) || USE_BGR_COLOR_SPACE == 0
		cairo_pattern_add_color_stop_rgba(pattern, 0, (*core->color)[2]*DIV_PIXEL, (*core->color)[1]*DIV_PIXEL,
			(*core->color)[0]*DIV_PIXEL, alpha);
		cairo_pattern_add_color_stop_rgba(pattern, 1, (*core->color)[2]*DIV_PIXEL, (*core->color)[1]*DIV_PIXEL,
			(*core->color)[0]*DIV_PIXEL, alpha);
#else
		cairo_pattern_add_color_stop_rgba(pattern, 0, (*core->color)[0]*DIV_PIXEL, (*core->color)[1]*DIV_PIXEL,
			(*core->color)[2]*DIV_PIXEL, alpha);
		cairo_pattern_add_color_stop_rgba(pattern, 1, (*core->color)[0]*DIV_PIXEL, (*core->color)[1]*DIV_PIXEL,
			(*core->color)[2]*DIV_PIXEL, alpha);
#endif

		update_surface = cairo_surface_create_for_rectangle(window->mask_temp->surface_p,
			x - r, y - r, r * 2, r * 2);
		update = cairo_create(update_surface);
		temp_surface = cairo_surface_create_for_rectangle(window->temp_layer->surface_p,
			x - r, y - r, r * 2, r * 2);
		temp_update = cairo_create(temp_surface);
#ifdef _OPENMP
		if(height <= MINIMUM_PARALLEL_SIZE)
		{
			omp_set_dynamic(FALSE);
			omp_set_num_threads(1);
		}
#endif

		mask = window->mask_temp->pixels;
		if(window->app->textures.active_texture == 0)
		{
			if((window->flags & DRAW_WINDOW_HAS_SELECTION_AREA) == 0)
			{
				if((window->active_layer->flags & LAYER_LOCK_OPACITY) == 0)
				{
					cairo_set_source(update, pattern);
					cairo_paint(update);
				}
				else
				{
					cairo_set_source(update, pattern);
					cairo_mask_surface(update,
						window->active_layer->surface_p, - x + r, - y + r);
				}
			}
			else
			{
				if((window->active_layer->flags & LAYER_LOCK_OPACITY) == 0)
				{
					cairo_set_source(update, pattern);
					cairo_mask_surface(update,
						window->selection->surface_p, - x + r, - y + r);
				}
				else
				{
					cairo_set_source(temp_update, pattern);
					cairo_mask_surface(temp_update,
						window->selection->surface_p, - x + r, - y + r);
					cairo_set_source_surface(update, temp_surface, 0, 0);
					cairo_mask_surface(update, window->active_layer->surface_p,
						- x + r, - y + r);
				}
			}
		}
		else
		{
			if((window->flags & DRAW_WINDOW_HAS_SELECTION_AREA) == 0)
			{
				if((window->active_layer->flags & LAYER_LOCK_OPACITY) == 0)
				{
					cairo_set_source(update, core->brush_pattern);
					cairo_mask_surface(update, window->texture->surface_p,
						- x + r, - y + r);
				}
				else
				{
					cairo_set_source(temp_update, pattern);
					cairo_mask_surface(temp_update, window->active_layer->surface_p,
						- x + r, - y + r);
					cairo_set_source_surface(update, temp_surface,
						0, 0);
					cairo_mask_surface(update,
						window->texture->surface_p, - x + r, - y + r);
				}
			}
			else
			{
				if((window->active_layer->flags & LAYER_LOCK_OPACITY) == 0)
				{
					cairo_set_source(temp_update, pattern);
					cairo_mask_surface(temp_update,
						window->selection->surface_p, - x + r, - y + r);

					for(i=0; i<height; i++)
					{
						(void)memset(&window->mask_temp->pixels[
							(i+start_y)*window->mask_temp->stride+start_x*4],
							0, stride
						);
					}

					cairo_set_source_surface(update, temp_surface, 0, 0);
					cairo_mask_surface(update, window->texture->surface_p, - x + r, - y + r);
				}
				else
				{
					cairo_set_source(update, pattern);
					cairo_mask_surface(update, window->selection->surface_p,
						- x + r, - y + r);
					cairo_set_source_surface(temp_update, update_surface, 0, 0);

					for(i=0; i<height; i++)
					{
						(void)memset(&window->temp_layer->pixels[
							(i+start_y)*window->temp_layer->stride+start_x*4],
							0, stride
						);
					}

					cairo_mask_surface(temp_update,
						window->active_layer->surface_p, - x + r, - y + r);

					for(i=0; i<height; i++)
					{
						(void)memset(&window->mask_temp->pixels[
							(i+start_y)*window->mask_temp->stride+start_x*4],
							0, stride
						);
					}

					cairo_set_source_surface(update, temp_surface, 0, 0);
					cairo_mask_surface(update, window->texture->surface_p, - x + r, - y + r);
				}
			}
		}

		cairo_destroy(update);
		cairo_surface_destroy(update_surface);
		cairo_destroy(temp_update);
		cairo_surface_destroy(temp_surface);

		if((pen->flags & BRUSH_FLAG_ANTI_ALIAS) == 0)
		{
			uint8 threshold;
			uint8 set_color[4];

			threshold = (uint8)(alpha * alpha_rate * 255 * 0.5);
#if defined(USE_BGR_COLOR_SPACE) && USE_BGR_COLOR_SPACE != 0
			set_color[0] = (uint8)((*core->color)[2] * alpha);
			set_color[1] = (uint8)((*core->color)[1] * alpha);
			set_color[2] = (uint8)((*core->color)[0] * alpha);
#else
			set_color[0] = (uint8)((*core->color)[0] * alpha);
			set_color[1] = (uint8)((*core->color)[1] * alpha);
			set_color[2] = (uint8)((*core->color)[2] * alpha);
#endif
			set_color[3] = (uint8)(alpha * 255 + 0.3);

#ifdef _OPENMP
#pragma omp parallel for firstprivate(width, mask, start_y, start_x, threshold)
#endif
			for(i=0; i<height; i++)
			{
				int j;
				for(j=0; j<width; j++)
				{
					if(mask[(start_y+i)*window->stride+(start_x+j)*4+3] > threshold)
					{
						mask[(start_y+i)*window->stride+(start_x+j)*4] = set_color[0];
						mask[(start_y+i)*window->stride+(start_x+j)*4+1] = set_color[1];
						mask[(start_y+i)*window->stride+(start_x+j)*4+2] = set_color[2];
						mask[(start_y+i)*window->stride+(start_x+j)*4+3] = set_color[3];
					}
					else
					{
						mask[(start_y+i)*window->stride+(start_x+j)*4] = 0;
						mask[(start_y+i)*window->stride+(start_x+j)*4+1] = 0;
						mask[(start_y+i)*window->stride+(start_x+j)*4+2] = 0;
						mask[(start_y+i)*window->stride+(start_x+j)*4+3] = 0;
					}
				}
			}
		}

#ifdef _OPENMP
#pragma omp parallel for firstprivate(mask, width, start_y, start_x)
#endif
		for(i=0; i<height; i++)
		{
			uint8 *mask_pix = &mask[(start_y+i)*window->stride+start_x*4];
			uint8 *ref = &window->work_layer->pixels[(start_y+i)*window->stride+start_x*4];
			int j;
			for(j=0; j<width; mask_pix += 4, ref += 4, j++)
			{
				if(mask_pix[3] >= ref[3])
				{
					ref[0] = (uint8)(((int)mask_pix[0] - (int)ref[0]) * mask_pix[3] >> 8) + ref[0];
					ref[1] = (uint8)(((int)mask_pix[1] - (int)ref[1]) * mask_pix[3] >> 8) + ref[1];
					ref[2] = (uint8)(((int)mask_pix[2] - (int)ref[2]) * mask_pix[3] >> 8) + ref[2];
					ref[3] = (uint8)(((int)mask_pix[3] - (int)ref[3]) * mask_pix[3] >> 8) + ref[3];
				}
			}
		}
#ifdef _OPENMP
		omp_set_dynamic(TRUE);
		omp_set_num_threads(window->app->max_threads);
#endif
func_end:
		pen->before_x = x,	pen->before_y = y;
		pen->before_alpha = alpha;
		pen->before_r = r;

		window->flags |= DRAW_WINDOW_UPDATE_PART;
	}
}

#define HardPenEditSelectionPressCallBack HardPenButtonPressCallBack

static void HardPenMotionCallBack(
	DRAW_WINDOW* window,
	FLOAT_T x,
	FLOAT_T y,
	FLOAT_T pressure,
	BRUSH_CORE *core,
	void* state
)
{
	if(((*(GdkModifierType*)state) & GDK_BUTTON1_MASK) != 0)
	{
		HARD_PEN* pen = (HARD_PEN*)core->brush_data;
		cairo_t *update, *temp_update;
		cairo_surface_t *update_surface, *temp_surface;
		cairo_pattern_t *pattern;
		FLOAT_T r, step, alpha, d;
		FLOAT_T set_alpha;
		FLOAT_T alpha_rate = 1;
		FLOAT_T min_x, min_y, max_x, max_y;
		FLOAT_T draw_x = pen->before_x, draw_y = pen->before_y;
		FLOAT_T dx, dy, diff_x, diff_y;
		int start_x, width, start_y, height;
		int stride;
		uint8 *color = *core->color;
		uint8 *work_pixel = window->work_layer->pixels;
		uint8 *mask;
		int i;

		// 最低筆圧のチェック
		if(pressure < pen->minimum_pressure)
		{
			pressure = pen->minimum_pressure;
		}

		if((pen->flags & BRUSH_FLAG_SIZE) == 0)
		{
			r = pen->r;
		}
		else
		{
			r = pen->r * pressure;
		}
		step = r * 0.125;
		if(step < 0.125)
		{
			step = 0.125;
		}
		set_alpha = alpha = ((pen->flags & BRUSH_FLAG_FLOW) == 0) ?
			pen->alpha * 0.01 : pen->alpha * 0.01 * pressure;
		if(r < 1)
		{
			alpha_rate = r;
			r = 1;
		}
		dx = x-pen->before_x, dy = y-pen->before_y;
		d = sqrt(dx*dx+dy*dy);
		diff_x = step * dx/d, diff_y = step * dy/d;

		if(d < pen->before_r * 0.125)
		{
			return;
		}

		min_x = x - r*2, min_y = y - r*2;
		max_x = x + r*2, max_y = y + r*2;

		if((pen->flags & BRUSH_FLAG_ANTI_ALIAS) != 0)
		{
			max_x++;
			max_y++;
		}

		if(min_x < 0.0)
		{
			min_x = 0.0;
		}
		if(min_y < 0.0)
		{
			min_y = 0.0;
		}
		if(max_x > window->work_layer->width)
		{
			max_x = window->work_layer->width;
		}
		if(max_y > window->work_layer->height)
		{
			max_y = window->work_layer->height;
		}

		if(min_x > window->width || min_y > window->height
			|| max_x < 0 || max_y < 0)
		{
			return;
		}

		if(window->update.x > min_x)
		{
			window->update.width += window->update.x - (int)min_x;
			window->update.x = (int)min_x;
		}
		if(window->update.width + window->update.x < max_x)
		{
			window->update.width += (int)max_x - window->update.width + window->update.x;
		}
		if(window->update.y > min_y)
		{
			window->update.height += window->update.y - (int)min_y;
			window->update.y = (int)min_y;
		}
		if(window->update.height + window->update.y < max_y)
		{
			window->update.height += (int)max_y - window->update.height + window->update.y;
		}

		if(core->min_x > min_x)
		{
			core->min_x = min_x;
		}
		if(core->min_y > min_y)
		{
			core->min_y = min_y;
		}
		if(core->max_x < max_x)
		{
			core->max_x = max_x;
		}
		if(core->max_y < max_y)
		{
			core->max_y = max_y;
		}

		dx = d;
		do
		{
			start_x = (int)(draw_x - r);
			start_y = (int)(draw_y - r);
			width = (int)(draw_x + r + 1);
			height = (int)(draw_y + r + 1);

			if(start_x < 0)
			{
				start_x = 0;
			}
			else if(start_x > window->work_layer->width)
			{
				goto skip_draw;
			}
			if(start_y < 0)
			{
				start_y = 0;
			}
			else if(start_y > window->work_layer->height)
			{
				goto skip_draw;
			}
			if(width > window->work_layer->width)
			{
				width = window->work_layer->width - start_x;
			}
			else
			{
				width = width - start_x;
			}
			if(height > window->work_layer->height)
			{
				height = window->work_layer->height - start_y;
			}
			else
			{
				height = height - start_y;
			}
			stride = width*4;

			if(width <= 0 || height <= 0)
			{
				goto skip_draw;
			}

			window->flags |= DRAW_WINDOW_UPDATE_PART;

			// 描画エリアを0初期化
			for(i=0; i<height; i++)
			{
				(void)memset(&window->temp_layer->pixels[(start_y+i)*window->temp_layer->stride + start_x*4],
					0, stride);
			}
			for(i=0; i<height; i++)
			{
				(void)memset(&window->mask_temp->pixels[(start_y+i)*window->mask_temp->stride + start_x*4],
					0, stride);
			}

			// 描画用円形パターン作成
			pattern = cairo_pattern_create_radial(r, r, 0,
				r, r, r);
			cairo_pattern_set_extend(pattern, CAIRO_EXTEND_NONE);
			set_alpha = ((1 - dx/d) * alpha + dx/d * pen->before_alpha) * alpha_rate;
#if !defined(USE_BGR_COLOR_SPACE) || USE_BGR_COLOR_SPACE == 0
			cairo_pattern_add_color_stop_rgba(pattern, 0, (*core->color)[2]*DIV_PIXEL, (*core->color)[1]*DIV_PIXEL,
				(*core->color)[0]*DIV_PIXEL, set_alpha);
			cairo_pattern_add_color_stop_rgba(pattern, 1, (*core->color)[2]*DIV_PIXEL, (*core->color)[1]*DIV_PIXEL,
				(*core->color)[0]*DIV_PIXEL, set_alpha);
#else
			cairo_pattern_add_color_stop_rgba(pattern, 0, (*core->color)[0]*DIV_PIXEL, (*core->color)[1]*DIV_PIXEL,
				(*core->color)[2]*DIV_PIXEL, set_alpha);
			cairo_pattern_add_color_stop_rgba(pattern, 1, (*core->color)[0]*DIV_PIXEL, (*core->color)[1]*DIV_PIXEL,
				(*core->color)[2]*DIV_PIXEL, set_alpha);
#endif

			update_surface = cairo_surface_create_for_rectangle(window->mask_temp->surface_p,
				draw_x - r, draw_y - r, r * 2, r * 2);
			update = cairo_create(update_surface);
			temp_surface = cairo_surface_create_for_rectangle(window->temp_layer->surface_p,
				draw_x - r, draw_y - r, r * 2, r * 2);
			temp_update = cairo_create(temp_surface);

			mask = window->mask_temp->pixels;
			if(window->app->textures.active_texture == 0)
			{
				if((window->flags & DRAW_WINDOW_HAS_SELECTION_AREA) == 0)
				{
					if((window->active_layer->flags & LAYER_LOCK_OPACITY) == 0)
					{
						cairo_set_source(update, pattern);
						cairo_paint(update);
					}
					else
					{
						cairo_set_source(update, pattern);
						cairo_mask_surface(update,
							window->active_layer->surface_p, - draw_x + r, - draw_y + r);
					}
				}
				else
				{
					if((window->active_layer->flags & LAYER_LOCK_OPACITY) == 0)
					{
						cairo_set_source(update, pattern);
						cairo_mask_surface(update,
							window->selection->surface_p, - draw_x + r, - draw_y + r);
					}
					else
					{
						cairo_set_source(temp_update, pattern);
						cairo_mask_surface(temp_update,
							window->selection->surface_p, - draw_x + r, - draw_y + r);
						cairo_set_source_surface(update, temp_surface, 0, 0);
						cairo_mask_surface(update, window->active_layer->surface_p,
							- draw_x + r, - draw_y + r);
					}
				}
			}
			else
			{
				if((window->flags & DRAW_WINDOW_HAS_SELECTION_AREA) == 0)
				{
					if((window->active_layer->flags & LAYER_LOCK_OPACITY) == 0)
					{
						cairo_set_source(update, core->brush_pattern);
						cairo_mask_surface(update, window->texture->surface_p,
							- draw_x + r, - draw_y + r);
					}
					else
					{
						cairo_set_source(temp_update, pattern);
						cairo_mask_surface(temp_update, window->active_layer->surface_p,
							- draw_x + r, - draw_y + r);
						cairo_set_source_surface(update, temp_surface,
							0, 0);
						cairo_mask_surface(update,
							window->texture->surface_p, - draw_x + r, - draw_y + r);
					}
				}
				else
				{
					if((window->active_layer->flags & LAYER_LOCK_OPACITY) == 0)
					{
						cairo_set_source(temp_update, pattern);
						cairo_mask_surface(temp_update,
							window->selection->surface_p, - draw_x + r, - draw_y + r);

						for(i=0; i<height; i++)
						{
							(void)memset(&window->mask_temp->pixels[
								(i+start_y)*window->mask_temp->stride+start_x*4],
								0, stride
							);
						}

						cairo_set_source_surface(update, temp_surface, 0, 0);
						cairo_mask_surface(update, window->texture->surface_p, - draw_x + r, - draw_y + r);
					}
					else
					{
						cairo_set_source(update, pattern);
						cairo_mask_surface(update, window->selection->surface_p,
							- draw_x + r, - draw_y + r);
						cairo_set_source_surface(temp_update, update_surface, 0, 0);

						for(i=0; i<height; i++)
						{
							(void)memset(&window->temp_layer->pixels[
								(i+start_y)*window->temp_layer->stride+start_x*4],
								0, stride
							);
						}

						cairo_mask_surface(temp_update,
							window->active_layer->surface_p, - draw_x + r, - draw_y + r);

						for(i=0; i<height; i++)
						{
							(void)memset(&window->mask_temp->pixels[
								(i+start_y)*window->mask_temp->stride+start_x*4],
								0, stride
							);
						}

						cairo_set_source_surface(update, temp_surface, 0, 0);
						cairo_mask_surface(update, window->texture->surface_p, - draw_x + r, - draw_y + r);
					}
				}
			}

			cairo_destroy(update);
			cairo_surface_destroy(update_surface);
			cairo_destroy(temp_update);
			cairo_surface_destroy(temp_surface);
#ifdef _OPENMP
			if(height <= MINIMUM_PARALLEL_SIZE)
			{
				omp_set_dynamic(FALSE);
				omp_set_num_threads(1);
			}
#endif
			if((pen->flags & BRUSH_FLAG_ANTI_ALIAS) == 0)
			{
				uint8 threshold;
				uint8 set_color[4];

				threshold = (uint8)(alpha * alpha_rate * 255 * 0.5);
#if defined(USE_BGR_COLOR_SPACE) && USE_BGR_COLOR_SPACE != 0
				set_color[0] = (uint8)((*core->color)[2] * alpha);
				set_color[1] = (uint8)((*core->color)[1] * alpha);
				set_color[2] = (uint8)((*core->color)[0] * alpha);
#else
				set_color[0] = (uint8)((*core->color)[0] * alpha);
				set_color[1] = (uint8)((*core->color)[1] * alpha);
				set_color[2] = (uint8)((*core->color)[2] * alpha);
#endif
				set_color[3] = (uint8)(alpha * 255 + 0.3);

#ifdef _OPENMP
#pragma omp parallel for firstprivate(width, mask, start_x, start_y)
#endif
				for(i=0; i<height; i++)
				{
					int j;
					for(j=0; j<width; j++)
					{
						if(mask[(start_y+i)*window->stride+(start_x+j)*4+3] > threshold)
						{
							mask[(start_y+i)*window->stride+(start_x+j)*4] = set_color[0];
							mask[(start_y+i)*window->stride+(start_x+j)*4+1] = set_color[1];
							mask[(start_y+i)*window->stride+(start_x+j)*4+2] = set_color[2];
							mask[(start_y+i)*window->stride+(start_x+j)*4+3] = set_color[3];
						}
						else
						{
							mask[(start_y+i)*window->stride+(start_x+j)*4] = 0;
							mask[(start_y+i)*window->stride+(start_x+j)*4+1] = 0;
							mask[(start_y+i)*window->stride+(start_x+j)*4+2] = 0;
							mask[(start_y+i)*window->stride+(start_x+j)*4+3] = 0;
						}
					}
				}
			}

#ifdef _OPENMP
#pragma omp parallel for firstprivate(width, mask, work_pixel, start_x, start_y)
#endif
			for(i=0; i<height; i++)
			{
				uint8 *mask_pix = &mask[(start_y+i)*window->stride+start_x*4];
				uint8 *ref = &work_pixel[(start_y+i)*window->stride+start_x*4];
				int j;

				for(j=0; j<width; mask_pix += 4, ref += 4, j++)
				{
					if(mask_pix[3] >= ref[3])
					{
						ref[0] = (uint8)(((int)mask_pix[0] - (int)ref[0]) * mask_pix[3] >> 8) + ref[0];
						ref[1] = (uint8)(((int)mask_pix[1] - (int)ref[1]) * mask_pix[3] >> 8) + ref[1];
						ref[2] = (uint8)(((int)mask_pix[2] - (int)ref[2]) * mask_pix[3] >> 8) + ref[2];
						ref[3] = (uint8)(((int)mask_pix[3] - (int)ref[3]) * mask_pix[3] >> 8) + ref[3];
					}
				}
			}
#ifdef _OPENMP
			omp_set_dynamic(TRUE);
			omp_set_num_threads(window->app->max_threads);
#endif
			pen->before_x = draw_x,	pen->before_y = draw_y;
skip_draw:
			dx -= step;
			if(dx < 1)
			{
				pen->before_alpha = set_alpha;
				pen->before_r = r;
				break;
			}
			else if(dx >= step)
			{
				draw_x += diff_x, draw_y += diff_y;
			}
			else
			{
				draw_x = x;
				draw_y = y;
			}
		} while(1);

		window->flags |= DRAW_WINDOW_UPDATE_PART;
	}
}

#define HardPenEditSelectionMotionCallBack HardPenMotionCallBack

static void HardPenButtonReleaseCallBack(
	DRAW_WINDOW* window,
	FLOAT_T x,
	FLOAT_T y,
	FLOAT_T pressure,
	BRUSH_CORE *core,
	void* state
)
{
	if(((GdkEventButton*)state)->button == 1)
	{
		AddBrushHistory(core, window->active_layer);

		window->update.surface_p = cairo_surface_create_for_rectangle(
			window->active_layer->surface_p, window->update.x, window->update.y,
				window->update.width, window->update.height);
		window->update.cairo_p = cairo_create(window->update.surface_p);

		window->part_layer_blend_functions[window->work_layer->layer_mode](window->work_layer, &window->update);

		(void)memset(window->work_layer->pixels, 0, window->work_layer->stride*window->work_layer->height);

		cairo_surface_destroy(window->update.surface_p);
		cairo_destroy(window->update.cairo_p);

		window->work_layer->layer_mode = LAYER_BLEND_NORMAL;
	}
}

#define HardPenEditSelectionReleaseCallBack DefaultEditSelectionReleaseCallBack


static void HardPenDrawCursor(
	DRAW_WINDOW* window,
	FLOAT_T x,
	FLOAT_T y,
	void* data
)
{
	HARD_PEN* pen = (HARD_PEN*)data;
	FLOAT_T r = pen->r * window->zoom_rate;
	cairo_set_line_width(window->disp_temp->cairo_p, 1.0);
	cairo_set_source_rgb(window->disp_temp->cairo_p, 1, 1, 1);
	cairo_arc(window->disp_temp->cairo_p, x, y, r, 0, 2*G_PI);
	cairo_stroke(window->disp_temp->cairo_p);

	cairo_rectangle(window->disp_layer->cairo_p, x - r, y - r,
		(r + BRUSH_UPDATE_MARGIN) * 2, (r + BRUSH_UPDATE_MARGIN) * 2);
	cairo_clip(window->disp_layer->cairo_p);
}

static void HardPenButtonUpdate(DRAW_WINDOW* window, FLOAT_T x, FLOAT_T y, HARD_PEN* pen)
{
	FLOAT_T r = pen->r * window->zoom_rate + 3;
	gtk_widget_queue_draw_area(window->window, (gint)(x - r - 1),
		(gint)(y - r - 1), (gint)(r * 2 + 3), (gint)(r * 2 + 3));
}

static void HardPenMotionUpdate(DRAW_WINDOW* window, FLOAT_T x, FLOAT_T y, HARD_PEN* pen)
{
	FLOAT_T start_x, start_y;
	FLOAT_T width, height;
	FLOAT_T r = pen->r * window->zoom_rate  * 1.275 + BRUSH_UPDATE_MARGIN;

	if(window->before_cursor_x < x)
	{
		start_x = window->before_cursor_x - r;
		width = r * 2 + x - window->before_cursor_x;
	}
	else
	{
		start_x = x - r;
		width = r * 2 + window->before_cursor_x - x;
	}

	if(window->before_cursor_y < y)
	{
		start_y = window->before_cursor_y - r;
		height = r * 2 + y - window->before_cursor_y;
	}
	else
	{
		start_y = y - r;
		height = r * 2 + window->before_cursor_y - y;
	}

	gtk_widget_queue_draw_area(window->window,
		(gint)start_x, (gint)start_y, (gint)width + 2, (gint)height + 2);
}

static void HardPenScaleChange(
	GtkAdjustment* slider,
	gpointer data
)
{
	HARD_PEN* pen = (HARD_PEN*)data;
	pen->r = gtk_adjustment_get_value(slider) * 0.5;
}

static void HardPenFlowChange(
	GtkAdjustment* slider,
	gpointer data
)
{
	HARD_PEN* pen = (HARD_PEN*)data;
	pen->alpha = gtk_adjustment_get_value(slider);
}

static void HardPenPressureSizeChange(
	GtkWidget* widget,
	gpointer data
)
{
	HARD_PEN* pen = (HARD_PEN*)data;
	if(gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(widget)) == FALSE)
	{
		pen->flags &= ~(BRUSH_FLAG_SIZE);
	}
	else
	{
		pen->flags |= BRUSH_FLAG_SIZE;
	}
}

static void HardPenPressureFlowChange(
	GtkWidget* widget,
	gpointer data
)
{
	HARD_PEN* pen = (HARD_PEN*)data;
	if(gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(widget)) == FALSE)
	{
		pen->flags &= ~(BRUSH_FLAG_FLOW);
	}
	else
	{
		pen->flags |= BRUSH_FLAG_FLOW;
	}
}

static void HardPenSetAntiAlias(
	GtkWidget* widget,
	gpointer data
)
{
	HARD_PEN* pen = (HARD_PEN*)data;
	if(gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(widget)) == FALSE)
	{
		pen->flags &= ~(BRUSH_FLAG_ANTI_ALIAS);
	}
	else
	{
		pen->flags |= BRUSH_FLAG_ANTI_ALIAS;
	}
}

static void HardPenSetBlendMode(GtkComboBox* combo, HARD_PEN* pen)
{
	pen->blend_mode = (uint16)gtk_combo_box_get_active(combo);
}

static void HardPenSetMinimumPressure(
	GtkAdjustment* slider,
	HARD_PEN* pen
)
{
	pen->minimum_pressure = gtk_adjustment_get_value(slider) * 0.01;
	if(pen->minimum_pressure < 0.005)
	{
		pen->minimum_pressure = 0.005;
	}
}

static GtkWidget* CreateHardPenDetailUI(APPLICATION* app, BRUSH_CORE* core)
{
#define UI_FONT_SIZE 8.0
	HARD_PEN* pen = (HARD_PEN*)core->brush_data;
	GtkWidget* vbox = gtk_vbox_new(FALSE, 2);
	GtkWidget* hbox;
	GtkWidget* brush_scale;
	GtkWidget* table = gtk_table_new(1, 3, TRUE);
	GtkWidget* check_button;
	GtkWidget* label;
	GtkWidget *combo;
	GtkWidget* base_scale;
	GtkAdjustment* brush_scale_adjustment;
	char mark_up_buff[256];
	int i;

	pen->core = core;

	switch(pen->base_scale)
	{
	case 0:
		brush_scale_adjustment =
			GTK_ADJUSTMENT(gtk_adjustment_new(pen->r * 2, 0.1, 10.0, 0.1, 0.1, 0.0));
		break;
	case 1:
		brush_scale_adjustment =
			GTK_ADJUSTMENT(gtk_adjustment_new(pen->r * 2, 1.0, 100.0, 1.0, 1.0, 0.0));
		break;
	default:
		brush_scale_adjustment =
			GTK_ADJUSTMENT(gtk_adjustment_new(pen->r * 2, 5.0, 500.0, 1.0, 1.0, 0.0));
		break;
	}

	{
		const char *mag_str[] = {"x 0.1", "x 1", "x 10"};
		hbox = gtk_hbox_new(FALSE, 0);
		label = gtk_label_new("");
		(void)sprintf(mark_up_buff, "<span font_desc=\"%.2f\">%s : </span>",
			UI_FONT_SIZE * app->gui_scale, app->labels->tool_box.base_scale);
		gtk_label_set_markup(GTK_LABEL(label), mark_up_buff);
		gtk_box_pack_start(GTK_BOX(hbox), label, FALSE, FALSE, 0);

#if GTK_MAJOR_VERSION <= 2
		base_scale = gtk_combo_box_new_text();
		gtk_combo_box_append_text(GTK_COMBO_BOX(base_scale), mag_str[0]);
		gtk_combo_box_append_text(GTK_COMBO_BOX(base_scale), mag_str[1]);
		gtk_combo_box_append_text(GTK_COMBO_BOX(base_scale), mag_str[2]);
#else
		base_scale = gtk_combo_box_text_new();
		gtk_combo_box_text_append_text(GTK_COMBO_BOX_TEXT(base_scale), mag_str[0]);
		gtk_combo_box_text_append_text(GTK_COMBO_BOX_TEXT(base_scale), mag_str[1]);
		gtk_combo_box_text_append_text(GTK_COMBO_BOX_TEXT(base_scale), mag_str[2]);
#endif
		gtk_combo_box_set_active(GTK_COMBO_BOX(base_scale), pen->base_scale);
		gtk_box_pack_start(GTK_BOX(hbox), base_scale, TRUE, TRUE, 0);
		gtk_box_pack_start(GTK_BOX(vbox), hbox, FALSE, FALSE, 0);
	}

	brush_scale = SpinScaleNew(brush_scale_adjustment,
		app->labels->tool_box.brush_scale, 1);
	(void)g_signal_connect(G_OBJECT(brush_scale_adjustment), "value_changed",
		G_CALLBACK(HardPenScaleChange), core->brush_data);
	gtk_table_attach_defaults(GTK_TABLE(table), brush_scale, 0, 3, 0, 1);
	gtk_box_pack_start(GTK_BOX(vbox), table, FALSE, FALSE, 0);

	g_object_set_data(G_OBJECT(base_scale), "scale", brush_scale);
	g_signal_connect(G_OBJECT(base_scale), "changed", G_CALLBACK(SetBrushBaseScale), &pen->base_scale);

	brush_scale_adjustment =
		GTK_ADJUSTMENT(gtk_adjustment_new(pen->alpha, 0.0, 100.0, 1.0, 1.0, 0.0));
	brush_scale = SpinScaleNew(brush_scale_adjustment,
		app->labels->tool_box.flow, 1);
	(void)g_signal_connect(G_OBJECT(brush_scale_adjustment), "value_changed",
		G_CALLBACK(HardPenFlowChange), core->brush_data);
	table = gtk_table_new(1, 3, TRUE);
	gtk_table_attach_defaults(GTK_TABLE(table), brush_scale, 0, 3, 0, 1);
	gtk_box_pack_start(GTK_BOX(vbox), table, FALSE, FALSE, 0);

	hbox = gtk_hbox_new(FALSE, 0);
	label = gtk_label_new("");
#if GTK_MAJOR_VERSION <= 2
	combo = gtk_combo_box_new_text();
#else
	combo = gtk_combo_box_text_new();
#endif
	(void)sprintf(mark_up_buff, "<span font_desc=\"%.2f\">%s : </span>",
		UI_FONT_SIZE * app->gui_scale, app->labels->layer_window.blend_mode);
	gtk_label_set_markup(GTK_LABEL(label), mark_up_buff);
	gtk_box_pack_start(GTK_BOX(hbox), label, FALSE, FALSE, 0);
	for(i=0; i<LAYER_BLEND_SLELECTABLE_NUM; i++)
	{
#if GTK_MAJOR_VERSION <= 2
		gtk_combo_box_append_text(GTK_COMBO_BOX(combo), app->labels->layer_window.blend_modes[i]);
#else
		gtk_combo_box_text_append_text(GTK_COMBO_BOX_TEXT(combo), app->labels->layer_window.blend_modes[i]);
#endif
	}
	gtk_combo_box_set_active(GTK_COMBO_BOX(combo), pen->blend_mode);
	(void)g_signal_connect(G_OBJECT(combo), "changed",
		G_CALLBACK(HardPenSetBlendMode), pen);
	gtk_box_pack_start(GTK_BOX(hbox), combo, FALSE, TRUE, 0);
	gtk_box_pack_start(GTK_BOX(vbox), hbox, FALSE, FALSE, 0);

	table = gtk_hbox_new(FALSE, 0);
	label = gtk_label_new("");
	(void)sprintf(mark_up_buff, "<span font_desc=\"%.2f\">%s : </span>",
		UI_FONT_SIZE * app->gui_scale, app->labels->tool_box.pressure);
	gtk_label_set_markup(GTK_LABEL(label), mark_up_buff);
	gtk_box_pack_start(GTK_BOX(table), label, FALSE, TRUE, 0);
	check_button = gtk_check_button_new_with_label(app->labels->tool_box.scale);
	(void)g_signal_connect(G_OBJECT(check_button), "toggled", G_CALLBACK(HardPenPressureSizeChange), core->brush_data);
	gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(check_button), pen->flags & BRUSH_FLAG_SIZE);
	gtk_box_pack_start(GTK_BOX(table), check_button, FALSE, TRUE, 0);
	check_button = gtk_check_button_new_with_label(app->labels->tool_box.flow);
	(void)g_signal_connect(G_OBJECT(check_button), "toggled", G_CALLBACK(HardPenPressureFlowChange), core->brush_data);
	gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(check_button), pen->flags & BRUSH_FLAG_FLOW);
	gtk_box_pack_start(GTK_BOX(table), check_button, FALSE, TRUE, 0);
	gtk_box_pack_start(GTK_BOX(vbox), table, FALSE, FALSE, 0);

	check_button = gtk_check_button_new_with_label(app->labels->tool_box.anti_alias);
	(void)g_signal_connect(G_OBJECT(check_button), "toggled", G_CALLBACK(HardPenSetAntiAlias), core->brush_data);
	gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(check_button), pen->flags & BRUSH_FLAG_ANTI_ALIAS);
	gtk_box_pack_start(GTK_BOX(vbox), check_button, FALSE, FALSE, 0);

	brush_scale_adjustment = GTK_ADJUSTMENT(gtk_adjustment_new(pen->minimum_pressure * 100,
		0, 100, 1, 1, 0));
	brush_scale = SpinScaleNew(brush_scale_adjustment, app->labels->tool_box.min_pressure, 0);
	(void)g_signal_connect(G_OBJECT(brush_scale_adjustment), "value_changed",
		G_CALLBACK(PencilSetMinimumPressure), pen);
	gtk_box_pack_start(GTK_BOX(vbox), brush_scale, FALSE, FALSE, 0);

	return vbox;
}

static void AirBrushPressCallBack(
	DRAW_WINDOW* window,
	FLOAT_T x,
	FLOAT_T y,
	FLOAT_T pressure,
	BRUSH_CORE *core,
	void* state
)
{
	// 左クリックなら
	if(((GdkEventButton*)state)->button == 1)
	{
		// ブラシの詳細情報にキャスト
		AIR_BRUSH *brush = (AIR_BRUSH*)core->brush_data;
		// 更新範囲のイメージ情報
		cairo_surface_t *update_surface;
		cairo_t *update;
		// ブラシの半径と不透明度
		FLOAT_T r, zoom, alpha;
		// 座標の最大値・最小値
		FLOAT_T min_x, min_y, max_x, max_y;
		// ピクセルデータをリセットする座標
		int start_x, start_y;
		// 描画する幅、高さ、一行分のバイト数
		int width, height, stride;
		// レイヤーの一行分のバイト数
		int layer_stride;
		// 作業レイヤーのピクセル
		uint8 *work_pixel = window->work_layer->pixels;
		// 参照ピクセル
		uint8 *mask;
		// 描画位置指定用
		cairo_matrix_t matrix;
		int i;	// for文用のカウンタ

		window->work_layer->layer_mode = brush->blend_mode;

		if((brush->flags & BRUSH_FLAG_SIZE) == 0)
		{
			r = brush->r;
			zoom = 1;
		}
		else
		{
			r = brush->r * pressure;
			zoom = 1/pressure;
		}

		brush->before_x = x, brush->before_y = y;
		brush->points[0][1] = x, brush->points[0][2] = y;
		brush->points[0][3] = pressure;
		brush->sum_distance = brush->travel = brush->finish_length = 0;
		brush->draw_start = r * brush->out * 0.01 * 4;
		brush->enter_length = r * brush->enter * 0.01 * 4;
		brush->enter_size = r * (1 - brush->enter * 0.01);
		brush->num_point = 0;
		brush->draw_finished = 0;
		brush->ref_point = 1;

		min_x = x - r, max_x = x + r;
		min_y = y - r, max_y = y + r;

		update_surface = cairo_surface_create_for_rectangle(
			window->mask_temp->surface_p, min_x, min_y, r*2+1, r*2+1);
		update = cairo_create(update_surface);

		if(min_x < 0.0)
		{
			min_x = 0.0;
		}
		else if(min_x > window->width)
		{
			return;
		}
		if(min_y < 0.0)
		{
			min_y = 0.0;
		}
		else if(min_y > window->height)
		{
			return;
		}
		if(max_x > window->work_layer->width)
		{
			max_x = window->work_layer->width;
		}
		if(max_y > window->work_layer->height)
		{
			max_y = window->work_layer->height;
		}

		window->update.x = (int)min_x, window->update.y = (int)min_y;
		window->update.width = (int)max_x - window->update.x;
		window->update.height = (int)max_y - window->update.y;

		window->flags |= DRAW_WINDOW_UPDATE_PART;

		core->min_x = min_x, core->min_y = min_y;
		core->max_x = max_x, core->max_y = max_y;

		if(brush->enter_length == 0)
		{
			alpha = ((brush->flags & BRUSH_FLAG_FLOW) == 0) ? 1 : pressure;
			start_x = (int)min_x, start_y = (int)min_y;
			width = (int)(max_x - min_x);
			height = (int)(max_y - min_y);
			stride = width*4;

			if(max_x > window->width || max_y > window->height
				|| max_x < 0 || max_y < 0)
			{
				return;
			}

			for(i=0; i<height; i++)
			{
				(void)memset(&window->mask_temp->pixels[
					(i+start_y)*window->mask_temp->stride+start_x*4], 0, stride);
			}

			cairo_set_operator(window->mask_temp->cairo_p, CAIRO_OPERATOR_OVER);

			mask = window->mask_temp->pixels;
			if(window->app->textures.active_texture == 0)
			{
				if((window->flags & DRAW_WINDOW_HAS_SELECTION_AREA) == 0)
				{
					if((window->active_layer->flags & LAYER_LOCK_OPACITY) == 0)
					{
						cairo_matrix_init_scale(&matrix, zoom, zoom);
						cairo_pattern_set_matrix(core->brush_pattern, &matrix);
						cairo_set_source(update, core->brush_pattern);
						cairo_paint_with_alpha(update, alpha);
					}
					else
					{
						cairo_matrix_init_scale(&matrix, zoom, zoom);
						cairo_pattern_set_matrix(core->brush_pattern, &matrix);
						cairo_set_source(core->temp_cairo, core->brush_pattern);
						cairo_paint_with_alpha(core->temp_cairo, alpha);
						cairo_matrix_init_translate(&matrix, 0,0);
						cairo_pattern_set_matrix(core->temp_pattern, &matrix);
						cairo_set_source(update, core->temp_pattern);
						cairo_mask_surface(update,
							window->active_layer->surface_p, - x + r, - y + r);
					}
				}
				else
				{
					if((window->active_layer->flags & LAYER_LOCK_OPACITY) == 0)
					{
						cairo_matrix_init_scale(&matrix, zoom, zoom);
						cairo_pattern_set_matrix(core->brush_pattern, &matrix);
						cairo_set_source(core->temp_cairo, core->brush_pattern);
						cairo_paint_with_alpha(core->temp_cairo, alpha);
						cairo_matrix_init_translate(&matrix, 0, 0);
						cairo_pattern_set_matrix(core->temp_pattern, &matrix);
						cairo_set_source(update, core->temp_pattern);
						cairo_mask_surface(update,
							window->selection->surface_p, - x + r, - y + r);
					}
					else
					{
						cairo_surface_t *temp_surface = cairo_surface_create_for_rectangle(
							window->temp_layer->surface_p, start_x, start_y, r*2+1, r*2+1);
						cairo_t *update_temp = cairo_create(temp_surface);

						cairo_matrix_init_scale(&matrix, zoom, zoom);
						cairo_pattern_set_matrix(core->brush_pattern, &matrix);
						cairo_set_source(core->temp_cairo, core->brush_pattern);
						cairo_paint_with_alpha(core->temp_cairo, alpha);
						cairo_matrix_init_translate(&matrix, 0, 0);
						cairo_pattern_set_matrix(core->temp_pattern, &matrix);
						cairo_set_source(update, core->temp_pattern);

						for(i=0; i<height; i++)
						{
							(void)memset(&window->temp_layer->pixels[
								(i+start_y)*window->temp_layer->stride+start_x*4],
								0, stride
							);
						}

						cairo_mask_surface(update,
							window->selection->surface_p, - x + r, - y + r);
						cairo_set_source_surface(update_temp,
							update_surface, 0, 0);
						cairo_mask_surface(update_temp,
							window->active_layer->surface_p, - x + r, - y + r);

						mask = window->temp_layer->pixels;

						cairo_surface_destroy(temp_surface);
						cairo_destroy(update_temp);
					}
				}
			}
			else
			{
				cairo_surface_t *temp_surface = cairo_surface_create_for_rectangle(
					window->temp_layer->surface_p, min_x, min_y, r*2+1, r*2+1);
				cairo_t *update_temp = cairo_create(temp_surface);

				if((window->flags & DRAW_WINDOW_HAS_SELECTION_AREA) == 0)
				{
					if((window->active_layer->flags & LAYER_LOCK_OPACITY) == 0)
					{
						cairo_matrix_init_scale(&matrix, zoom, zoom);
						cairo_pattern_set_matrix(core->brush_pattern, &matrix);
						cairo_set_source(update, core->brush_pattern);
						cairo_paint_with_alpha(update, alpha);
					}
					else
					{
						cairo_matrix_init_scale(&matrix, zoom, zoom);
						cairo_pattern_set_matrix(core->brush_pattern, &matrix);
						cairo_set_source(core->temp_cairo, core->brush_pattern);
						cairo_paint_with_alpha(core->temp_cairo, alpha);
						cairo_matrix_init_translate(&matrix, 0, 0);
						cairo_pattern_set_matrix(core->temp_pattern, &matrix);
						cairo_set_source(update, core->temp_pattern);
						cairo_mask_surface(update,
							window->active_layer->surface_p, - x + r, - y + r);
					}

					for(i=0; i<height; i++)
					{
						(void)memset(&window->temp_layer->pixels[
							(i+start_y)*window->temp_layer->stride+start_x*4],
							0, stride
						);
					}

					cairo_set_source_surface(update_temp, update_surface, 0, 0);
					cairo_mask_surface(update_temp, window->texture->surface_p, - x + r, - y + r);

					mask = window->temp_layer->pixels;
				}
				else
				{
					if((window->active_layer->flags & LAYER_LOCK_OPACITY) == 0)
					{
						cairo_matrix_init_scale(&matrix, zoom, zoom);
						cairo_pattern_set_matrix(core->brush_pattern, &matrix);
						cairo_set_source(core->temp_cairo, core->brush_pattern);
						cairo_paint_with_alpha(core->temp_cairo, alpha);
						cairo_matrix_init_translate(&matrix, 0, 0);
						cairo_pattern_set_matrix(core->temp_pattern, &matrix);
						cairo_set_source(update, core->temp_pattern);
						cairo_mask_surface(update,
							window->selection->surface_p, - x + r, - y + r);

						for(i=0; i<height; i++)
						{
							(void)memset(&window->temp_layer->pixels[
								(i+start_y)*window->temp_layer->stride+start_x*4],
								0, stride
							);
						}

						cairo_set_source_surface(update_temp, update_surface, 0, 0);
						cairo_mask_surface(update_temp, window->texture->surface_p, - x + r, - y + r);

						mask = window->temp_layer->pixels;
					}
					else
					{
						cairo_matrix_init_scale(&matrix, zoom, zoom);
						cairo_pattern_set_matrix(core->brush_pattern, &matrix);
						cairo_set_source(core->temp_cairo, core->brush_pattern);
						cairo_paint_with_alpha(core->temp_cairo, alpha);
						cairo_matrix_init_translate(&matrix, 0, 0);
						cairo_pattern_set_matrix(core->temp_pattern, &matrix);
						cairo_set_source(update, core->temp_pattern);

						for(i=0; i<height; i++)
						{
							(void)memset(&window->temp_layer->pixels[
								(i+start_y)*window->temp_layer->stride+start_x*4],
								0, stride
							);
						}

						cairo_mask_surface(update,
							window->selection->surface_p, - x + r, - y + r);
						cairo_set_source_surface(update_temp,
							update_surface, 0, 0);
						cairo_mask_surface(update_temp,
							window->active_layer->surface_p, - x + r, - y + r);

						for(i=0; i<height; i++)
						{
							(void)memset(&window->mask_temp->pixels[
								(i+start_y)*window->mask_temp->stride+start_x*4],
								0, stride
							);
						}

						cairo_set_source_surface(update, temp_surface, 0, 0);
						cairo_mask_surface(update, window->texture->surface_p, - x + r, - y + r);
					}
				}

				cairo_surface_destroy(temp_surface);
				cairo_destroy(update_temp);
			}

			cairo_surface_destroy(update_surface);
			cairo_destroy(update);

			/*
			for(i=0; i<height; i++)
			{
				(void)memcpy(
					&window->work_layer->pixels[(start_y+i)*window->work_layer->stride+start_x*4],
					&mask[(start_y+i)*window->work_layer->stride+start_x*4],
					stride
				);
			}
			*/

			layer_stride = window->work_layer->stride;
#ifdef _OPENMP
#pragma omp parallel for firstprivate(width, work_pixel, layer_stride, start_x, start_y)
#endif
			for(i=0; i<height; i++)
			{
				uint8 *ref_pix = &work_pixel[
					(start_y+i)*layer_stride+start_x*4];
				uint8 *mask_pix = &mask[(start_y+i)*layer_stride
					+start_x*4];
				int j;

				for(j=0; j<width; j++, ref_pix+=4, mask_pix+=4)
				{
					ref_pix[0] = (uint8)((uint32)(((int)mask_pix[0]-(int)ref_pix[0])
						* mask_pix[3] >> 8) + ref_pix[0]);
					ref_pix[1] = (uint8)((uint32)(((int)mask_pix[1]-(int)ref_pix[1])
						* mask_pix[3] >> 8) + ref_pix[1]);
					ref_pix[2] = (uint8)((uint32)(((int)mask_pix[2]-(int)ref_pix[2])
						* mask_pix[3] >> 8) + ref_pix[2]);
					ref_pix[3] = (uint8)((uint32)(((int)mask_pix[3]-(int)ref_pix[3])
						* mask_pix[3] >> 8) + ref_pix[3]);
				}
			}
		}	// if(brush->enter_length == 0)
	}	// 左クリックなら
		// if(((GdkEventButton*)state)->button == 1)
}

#define AirBrushEditSelectionPressCallBack AirBrushPressCallBack

static void AirBrushMotionCallBack(
	DRAW_WINDOW* window,
	FLOAT_T x,
	FLOAT_T y,
	FLOAT_T pressure,
	BRUSH_CORE *core,
	void* state
)
{
	// マウスの左ボタンが押されていたら
	if(((*(GdkModifierType*)state) & GDK_BUTTON1_MASK) != 0)
	{
		// ブラシの詳細情報にキャスト
		AIR_BRUSH *brush = (AIR_BRUSH*)core->brush_data;
		FLOAT_T distance;
		int index = brush->ref_point % BRUSH_POINT_BUFFER_SIZE;

		distance = sqrt((x-brush->before_x)*(x-brush->before_x)
			+(y-brush->before_y)*(y-brush->before_y));

		if(distance >= 1.0)
		{
			brush->before_x = x, brush->before_y = y;
			brush->sum_distance += distance;
			brush->travel += distance;
			brush->points[index][0] = distance;
			brush->points[index][1] = x, brush->points[index][2] = y;
			brush->points[index][3] = pressure;
			brush->ref_point++;

			if(brush->sum_distance >= brush->draw_start
				&& brush->sum_distance >= brush->enter_length)
			{
				// 更新範囲のイメージ情報
				cairo_surface_t *update_surface;
				cairo_t *update;
				// ブラシの筆圧による縮小用
				FLOAT_T zoom;
				// 入りの色補正用
				FLOAT_T enter_alpha;
				// ブラシの半径と不透明度
				FLOAT_T r, alpha;
				// 座標の最大・最小値
				FLOAT_T min_x, min_y, max_x, max_y;
				// X、Y方向の移動量
				FLOAT_T dx, dy;
				// ブラシの傾き用
				FLOAT_T diff_x, diff_y;
				// ブラシの移動量
				FLOAT_T d, step;
				// 描画を行う座標
				FLOAT_T draw_x = brush->before_x, draw_y = brush->before_y;
				// 描画座標指定用
				cairo_matrix_t matrix;
				// ピクセルデータをリセットする座標
				int start_x, start_y;
				// 描画する幅、高さ、一行分のバイト数
				int width, height, stride;
				// 作業レイヤーの一行分のバイト数
				int layer_stride = window->work_layer->stride;
				// 作業レイヤーのピクセル
				uint8 *work_pixel = window->work_layer->pixels;
				// 参照ピクセル
				uint8 *mask;
				// 配列のインデックス用
				int ref_point = brush->draw_finished % BRUSH_POINT_BUFFER_SIZE;
				int before_point;
				int i;	// for文用のカウンタ

				while(brush->sum_distance > brush->draw_start
					&& brush->draw_finished < brush->ref_point)
				{
					if(brush->finish_length < brush->enter_length)
					{
						enter_alpha = brush->finish_length / brush->enter_length;
						r = brush->enter_size + brush->finish_length * 0.25;
					}
					else
					{
						zoom = enter_alpha = 1, r = brush->r;
					}
					
					if((brush->flags & BRUSH_FLAG_SIZE) != 0)
					{
						r *= brush->points[ref_point][3];
					}

					
					alpha = ((brush->flags & BRUSH_FLAG_FLOW) == 0)
						? 1 : brush->points[ref_point][3];
					alpha *= enter_alpha;
					before_point = (ref_point == 0) ? BRUSH_POINT_BUFFER_SIZE - 1 : ref_point - 1;
					d = brush->points[ref_point][0];
					brush->sum_distance -= d;

					if(r > MIN_BRUSH_STEP)
					{
						zoom = brush->r / r;
						step = r * BRUSH_STEP;
						if(step < 0.5)
						{
							step = 0.5;
						}

						if(brush->draw_finished == 0)
						{
							draw_x = brush->points[0][1], draw_y = brush->points[0][2];
						}
						else
						{
							draw_x = brush->points[before_point][1];
							draw_y = brush->points[before_point][2];
						}
						dx = brush->points[ref_point][1] - draw_x;
						dy = brush->points[ref_point][2] - draw_y;
						diff_x = step*dx/d, diff_y = step*dy/d;

						min_x = brush->points[ref_point][1] - r - 1;
						max_x = brush->points[ref_point][1] + r + 1;
						min_y = brush->points[ref_point][2] - r - 1;
						max_y = brush->points[ref_point][2] + r + 1;

						if(min_x < 0.0)
						{
							min_x = 0.0;
						}
						if(core->min_x > min_x)
						{
							core->min_x = min_x;
						}
						if(min_y < 0.0)
						{
							min_y = 0.0;
						}
						if(core->min_y > min_y)
						{
							core->min_y = min_y;
						}
						if(max_x > window->work_layer->width)
						{
							max_x = window->work_layer->width;
						}
						if(core->max_x < max_x)
						{
							core->max_x = max_x;
						}
						if(max_y > window->work_layer->height)
						{
							min_y = window->work_layer->height;
						}
						if(core->max_y < max_y)
						{
							core->max_y = max_y;
						}

						if(window->update.x > min_x)
						{
							window->update.width += window->update.x - (int)min_x;
							window->update.x = (int)min_x;
						}
						if(window->update.width + window->update.x < max_x)
						{
							window->update.width += (int)max_x - window->update.width + window->update.x;
						}
						if(window->update.y > min_y)
						{
							window->update.height += window->update.y - (int)min_y;
							window->update.y = (int)min_y;
						}
						if(window->update.height + window->update.y < max_y)
						{
							window->update.height += (int)max_y - window->update.height + window->update.y;
						}

						dx = d;
						do
						{
							start_x = (int)(draw_x - r);
							start_y = (int)(draw_y - r);
							width = (int)(draw_x + r) + 1;
							height = (int)(draw_y + r) + 1;

							if(start_x < 0)
							{
								start_x = 0;
							}
							else if(start_x > window->work_layer->width)
							{
								goto skip_draw;
							}
							if(start_y < 0)
							{
								start_y = 0;
							}
							else if(start_y > window->work_layer->height)
							{
								goto skip_draw;
							}
							if(width > window->work_layer->width)
							{
								width = window->work_layer->width - start_x;
							}
							else
							{
								width = width - start_x;
							}
							if(height > window->work_layer->height)
							{
								height = window->work_layer->height - start_y;
							}
							else
							{
								height = height - start_y;
							}
							stride = width*4;

							if(width <= 0 || height <= 0)
							{
								goto skip_draw;
							}

							update_surface = cairo_surface_create_for_rectangle(
								window->mask_temp->surface_p, draw_x - r, draw_y - r,
									r*2+1, r*2+1);
							update = cairo_create(update_surface);

							window->flags |= DRAW_WINDOW_UPDATE_PART;

							for(i=0; i<height; i++)
							{
								(void)memset(&window->mask_temp->pixels[(i+start_y)*window->mask_temp->stride+start_x*4],
									0, stride);
							}

							cairo_set_operator(window->mask_temp->cairo_p, CAIRO_OPERATOR_OVER);

							mask = window->mask_temp->pixels;
							if(window->app->textures.active_texture == 0)
							{
								if((window->flags & DRAW_WINDOW_HAS_SELECTION_AREA) == 0)
								{
									if((window->active_layer->flags & LAYER_LOCK_OPACITY) == 0)
									{
										cairo_matrix_init_scale(&matrix, zoom, zoom);
										cairo_pattern_set_matrix(core->brush_pattern, &matrix);
										cairo_set_source(update, core->brush_pattern);
										cairo_paint_with_alpha(update, alpha);
									}
									else
									{
										cairo_matrix_init_scale(&matrix, zoom, zoom);
										cairo_pattern_set_matrix(core->brush_pattern, &matrix);
										cairo_set_source(core->temp_cairo, core->brush_pattern);
										cairo_paint_with_alpha(core->temp_cairo, alpha);
										cairo_matrix_init_translate(&matrix, 0, 0);
										cairo_pattern_set_matrix(core->temp_pattern, &matrix);
										cairo_set_source(update, core->temp_pattern);
										cairo_mask_surface(update,
											window->active_layer->surface_p, - draw_x + r, - draw_y + r);
									}
								}
								else
								{
									if((window->active_layer->flags & LAYER_LOCK_OPACITY) == 0)
									{
										cairo_matrix_init_scale(&matrix, zoom, zoom);
										cairo_pattern_set_matrix(core->brush_pattern, &matrix);
										cairo_set_source(core->temp_cairo, core->brush_pattern);
										cairo_paint_with_alpha(core->temp_cairo, alpha);
										cairo_matrix_init_translate(&matrix, 0, 0);
										cairo_pattern_set_matrix(core->temp_pattern, &matrix);
										cairo_set_source(update, core->temp_pattern);
										cairo_mask_surface(update,
											window->selection->surface_p, - draw_x + r, - draw_y + r);
									}
									else
									{
										cairo_surface_t *temp_surface = cairo_surface_create_for_rectangle(
											window->temp_layer->surface_p, start_x, start_y, r*2+1, r*2+1);
										cairo_t *update_temp = cairo_create(temp_surface);

										cairo_matrix_init_scale(&matrix, zoom, zoom);
										cairo_pattern_set_matrix(core->brush_pattern, &matrix);
										cairo_set_source(core->temp_cairo, core->brush_pattern);
										cairo_paint_with_alpha(core->temp_cairo, alpha);
										cairo_matrix_init_translate(&matrix, 0, 0);
										cairo_pattern_set_matrix(core->temp_pattern, &matrix);
										cairo_set_source(update, core->temp_pattern);

										for(i=0; i<height; i++)
										{
											(void)memset(&window->temp_layer->pixels[
												(i+start_y)*window->temp_layer->stride+start_x*4],
												0, stride
											);
										}

										cairo_mask_surface(update,
											window->selection->surface_p, - draw_x + r, - draw_y + r);
										cairo_set_source_surface(update_temp,
											update_surface, 0, 0);
										cairo_mask_surface(update_temp,
											window->active_layer->surface_p, - draw_x + r, - draw_y + r);
	
										mask = window->temp_layer->pixels;

										cairo_surface_destroy(temp_surface);
										cairo_destroy(update_temp);
									}
								}
							}
							else
							{
								cairo_surface_t *temp_surface = cairo_surface_create_for_rectangle(
									window->temp_layer->surface_p, start_x, start_y, r*2+1, r*2+1);
								cairo_t *update_temp = cairo_create(temp_surface);

								if((window->flags & DRAW_WINDOW_HAS_SELECTION_AREA) == 0)
								{
									if((window->active_layer->flags & LAYER_LOCK_OPACITY) == 0)
									{
										cairo_matrix_init_scale(&matrix, zoom, zoom);
										cairo_pattern_set_matrix(core->brush_pattern, &matrix);
										cairo_set_source(update, core->brush_pattern);
										cairo_paint_with_alpha(update, alpha);
									}
									else
									{
										cairo_matrix_init_scale(&matrix, zoom, zoom);
										cairo_pattern_set_matrix(core->brush_pattern, &matrix);
										cairo_set_source(core->temp_cairo, core->brush_pattern);
										cairo_paint_with_alpha(core->temp_cairo, alpha);
										cairo_matrix_init_translate(&matrix, 0, 0);
										cairo_pattern_set_matrix(core->temp_pattern, &matrix);
										cairo_set_source(update, core->temp_pattern);
										cairo_mask_surface(update,
											window->active_layer->surface_p, - draw_x + r, - draw_y + r);
									}

									for(i=0; i<height; i++)
									{
										(void)memset(&window->temp_layer->pixels[
											(i+start_y)*window->temp_layer->stride+start_x*4],
											0, stride
										);
									}

									cairo_set_source_surface(update_temp, update_surface, 0, 0);
									cairo_mask_surface(update_temp, window->texture->surface_p, - draw_x + r, - draw_y + r);

									mask = window->temp_layer->pixels;
								}
								else
								{
									if((window->active_layer->flags & LAYER_LOCK_OPACITY) == 0)
									{
										cairo_matrix_init_scale(&matrix, zoom, zoom);
										cairo_pattern_set_matrix(core->brush_pattern, &matrix);
										cairo_set_source(core->temp_cairo, core->brush_pattern);
										cairo_paint_with_alpha(core->temp_cairo, alpha);
										cairo_matrix_init_translate(&matrix, 0, 0);
										cairo_pattern_set_matrix(core->temp_pattern, &matrix);
										cairo_set_source(update, core->temp_pattern);
										cairo_mask_surface(update,
											window->selection->surface_p, - draw_x + r, - draw_y + r);

										for(i=0; i<height; i++)
										{
											(void)memset(&window->temp_layer->pixels[
												(i+start_y)*window->temp_layer->stride+start_x*4],
												0, stride
											);
										}

										cairo_set_source_surface(update_temp, update_surface, 0, 0);
										cairo_mask_surface(update_temp, window->texture->surface_p, - draw_x + r, - draw_y + r);

										mask = window->temp_layer->pixels;
									}
									else
									{
										cairo_matrix_init_scale(&matrix, zoom, zoom);
										cairo_pattern_set_matrix(core->brush_pattern, &matrix);
										cairo_set_source(core->temp_cairo, core->brush_pattern);
										cairo_paint_with_alpha(core->temp_cairo, alpha);
										cairo_matrix_init_translate(&matrix, 0, 0);
										cairo_pattern_set_matrix(core->temp_pattern, &matrix);
										cairo_set_source(update, core->temp_pattern);

										for(i=0; i<height; i++)
										{
											(void)memset(&window->temp_layer->pixels[
												(i+start_y)*window->temp_layer->stride+start_x*4],
												0, stride
											);
										}

										cairo_mask_surface(update,
											window->selection->surface_p, - draw_x + r, - draw_y + r);
										cairo_set_source_surface(update_temp,
											update_surface, 0, 0);
										cairo_mask_surface(update_temp,
											window->active_layer->surface_p, - draw_x + r, - draw_y + r);
	
										for(i=0; i<height; i++)
										{
											(void)memset(&window->mask_temp->pixels[
												(i+start_y)*window->mask_temp->stride+start_x*4],
												0, stride
											);
										}

										cairo_set_source_surface(update, temp_surface, 0, 0);
										cairo_mask_surface(update, window->texture->surface_p, - draw_x + r, - draw_y + r);
									}
								}

								cairo_surface_destroy(temp_surface);
								cairo_destroy(update_temp);
							}

							cairo_surface_destroy(update_surface);
							cairo_destroy(update);

#ifdef _OPENMP
#pragma omp parallel for firstprivate(width, work_pixel, layer_stride, start_x, start_y, mask)
#endif
							for(i=0; i<height; i++)
							{
								uint8 *ref_pix = &work_pixel[
									(start_y+i)*layer_stride+start_x*4];
								uint8 *mask_pix = &mask[(start_y+i)*layer_stride
									+start_x*4];
								int j;

								for(j=0; j<width; j++, ref_pix+=4, mask_pix+=4)
								{
									if(ref_pix[3] < mask_pix[3])
									{
										ref_pix[0] = (uint8)((uint32)(((int)mask_pix[0]-(int)ref_pix[0])
											* mask_pix[3] >> 8) + ref_pix[0]);
										ref_pix[1] = (uint8)((uint32)(((int)mask_pix[1]-(int)ref_pix[1])
											* mask_pix[3] >> 8) + ref_pix[1]);
										ref_pix[2] = (uint8)((uint32)(((int)mask_pix[2]-(int)ref_pix[2])
											* mask_pix[3] >> 8) + ref_pix[2]);
										ref_pix[3] = (uint8)((uint32)(((int)mask_pix[3]-(int)ref_pix[3])
											* mask_pix[3] >> 8) + ref_pix[3]);
									}
								}
							}

							// アンチエイリアスを適用
							if((brush->flags & BRUSH_FLAG_ANTI_ALIAS) != 0)
							{
								ANTI_ALIAS_RECTANGLE range = {start_x - 1, start_y - 1,
									width + 3, height + 3};
								AntiAliasLayer(window->work_layer, window->temp_layer, &range);
							}
skip_draw:
							dx -= step;
							if(dx < 1)
							{
								break;
							}
							else if(dx >= step)
							{
								draw_x += diff_x, draw_y += diff_y;
							}
							else
							{
								draw_x = brush->points[ref_point][1];
								draw_y = brush->points[ref_point][2];
							}
						} while(1);
					}

					brush->finish_length += d;
					brush->travel += d;
					brush->draw_finished++;
					ref_point = brush->draw_finished % BRUSH_POINT_BUFFER_SIZE;
				}	// while(brush->sum_distance > brush->draw_start
						// && brush->draw_finished < brush->ref_point)
			}	// if(brush->sum_distance >= brush->draw_start
					// && brush->sum_distance >= brush->enter_length)
		}	// if(distance >= 1.0)
	}	// マウスの左ボタンが押されていたら
		// if(((*(GdkModifierType*)state) & GDK_BUTTON1_MASK) != 0)
}

#define AirBrushEditSelectionMotionCallBack AirBrushMotionCallBack

static void AirBrushReleaseCallBack(
	DRAW_WINDOW* window,
	FLOAT_T x,
	FLOAT_T y,
	FLOAT_T pressure,
	BRUSH_CORE *core,
	void* state
)
{
	// マウスの左ボタンなら
	if(((GdkEventButton*)state)->button == 1)
	{
		// ブラシの詳細情報にキャスト
		AIR_BRUSH *brush = (AIR_BRUSH*)core->brush_data;
		// 更新範囲のイメージ情報
		cairo_surface_t *update_surface;
		cairo_t *update;
		// ブラシの縮小率
		FLOAT_T zoom;
		// ブラシの半径と不透明度
		FLOAT_T r, alpha;
		// 座標の最大・最小値
		FLOAT_T min_x, min_y, max_x, max_y;
		// X、Y方向の移動量
		FLOAT_T dx, dy;
		// ブラシの傾き用
		FLOAT_T diff_x, diff_y;
		// ブラシの移動量
		FLOAT_T d, step;
		// 描画を行う座標
		FLOAT_T draw_x, draw_y;
		// 入り、抜き時の色補正
		FLOAT_T enter_alpha, out_alpha;
		// ピクセルデータをリセットする座標
		int start_x, start_y;
		// 描画する幅、高さ、一行分のバイト数
		int width, height, stride;
		// 作業レイヤーの一行分のバイト数
		int layer_stride = window->work_layer->stride;
		// 作業レイヤーのピクセル
		uint8 *work_pixel = window->work_layer->pixels;
		// 描画座標指定用
		cairo_matrix_t matrix;
		// 参照ピクセル
		uint8 *mask;
		// 配列のインデックス用
		int ref_point;
		int before_point;
		int i;	// for文用のカウンタ

		while(brush->ref_point > brush->draw_finished)
		{
			ref_point = brush->draw_finished % BRUSH_POINT_BUFFER_SIZE;

			if(brush->finish_length < brush->enter_length)
			{
				enter_alpha = brush->finish_length / brush->enter_length;
				r = brush->enter_size + brush->finish_length * 0.25;
			}
			else
			{
				enter_alpha = 1;
				r = brush->r;
			}
			if(brush->sum_distance < brush->draw_start)
			{
				out_alpha = brush->sum_distance / brush->draw_start;
				r -= (brush->draw_start - brush->sum_distance) * 0.25;
			}
			else
			{
				out_alpha = 1;
			}

			if(r < 0.0)
			{
				brush->draw_finished++;
				continue;
			}

			if((brush->flags & BRUSH_FLAG_SIZE) != 0)
			{
				r *= brush->points[ref_point][3];
			}
			alpha = ((brush->flags & BRUSH_FLAG_FLOW) == 0)
				? 1 : brush->points[ref_point][3];
			alpha *= enter_alpha * out_alpha;
			before_point = (ref_point == 0) ? BRUSH_POINT_BUFFER_SIZE - 1 : ref_point - 1;
			if(r > MIN_BRUSH_STEP)
			{
				d = brush->points[ref_point][0];
				brush->sum_distance -= d;
				step = r * BRUSH_STEP;
				zoom = brush->r / r;

				if(step < 0.5)
				{
					step = 0.5;
				}
				if(brush->draw_finished == 0)
				{
					draw_x = brush->points[0][1], draw_y = brush->points[0][2];
				}
				else
				{
					draw_x = brush->points[before_point][1], draw_y = brush->points[before_point][2];
				}
				dx = brush->points[ref_point][1] - draw_x;
				dy = brush->points[ref_point][2] - draw_y;
				diff_x = step * dx / d, diff_y = step * dy / d;

				min_x = brush->points[ref_point][1] - r - 1;
				max_x = brush->points[ref_point][1] + r + 1;
				min_y = brush->points[ref_point][2] - r - 1;
				max_y = brush->points[ref_point][2] + r + 1;
				if(min_x < 0.0)
				{
					min_x = 0.0;
				}
				if(core->min_x > min_x)
				{
					core->min_x = min_x;
				}
				if(min_y < 0.0)
				{
					min_y = 0.0;
				}
				if(core->min_y > min_y)
				{
					core->min_y = min_y;
				}
				if(max_x > window->work_layer->width)
				{
					max_x = window->work_layer->width;
				}
				if(core->max_x < max_x)
				{
					core->max_x = max_x;
				}
				if(max_y > window->work_layer->height)
				{
					min_y = window->work_layer->height;
				}
				if(core->max_y < max_y)
				{
					core->max_y = max_y;
				}

				dx = d;
				do
				{
					start_x = (int)(draw_x - r);
					start_y = (int)(draw_y - r);
					width = (int)(draw_x + r);
					height = (int)(draw_y + r);

					if(start_x < 0)
					{
						start_x = 0;
					}
					else if(start_x > window->work_layer->width)
					{
						goto skip_draw;
					}
					if(start_y < 0)
					{
						start_y = 0;
					}
					else if(start_y > window->work_layer->height)
					{
						goto skip_draw;
					}
					if(width > window->work_layer->width)
					{
						width = window->work_layer->width - start_x;
					}
					else
					{
						width = width - start_x;
					}
					if(height > window->work_layer->height)
					{
						height = window->work_layer->height - start_y;
					}
					else
					{
						height = height - start_y;
					}
					stride = width*4;

					if(width <= 0 || height <= 0)
					{
						goto skip_draw;
					}

					update_surface = cairo_surface_create_for_rectangle(
						window->mask_temp->surface_p, draw_x - r, draw_y - r,
							r*2+1, r*2+1);
					update = cairo_create(update_surface);

					if(window->update.x > min_x)
					{
						window->update.width += window->update.x - (int)min_x;
						window->update.x = (int)min_x;
					}
					if(window->update.width + window->update.x < max_x)
					{
						window->update.width += (int)max_x - window->update.width + window->update.x;
					}
					if(window->update.y > min_y)
					{
						window->update.height += window->update.y - (int)min_y;
						window->update.y = (int)min_y;
					}
					if(window->update.height + window->update.y < max_y)
					{
						window->update.height += (int)max_y - window->update.height + window->update.y;
					}

					for(i=0; i<height; i++)
					{
						(void)memset(&window->mask_temp->pixels[(i+start_y)*window->mask_temp->stride+start_x*4],
							0, stride);
					}

					cairo_set_operator(window->mask_temp->cairo_p, CAIRO_OPERATOR_OVER);

					mask = window->mask_temp->pixels;
					if(window->app->textures.active_texture == 0)
					{
						if((window->flags & DRAW_WINDOW_HAS_SELECTION_AREA) == 0)
						{
							if((window->active_layer->flags & LAYER_LOCK_OPACITY) == 0)
							{
								cairo_matrix_init_scale(&matrix, zoom, zoom);
								cairo_pattern_set_matrix(core->brush_pattern, &matrix);
								cairo_set_source(update, core->brush_pattern);
								cairo_paint_with_alpha(update, alpha);
							}
							else
							{
								cairo_matrix_init_scale(&matrix, zoom, zoom);
								cairo_pattern_set_matrix(core->brush_pattern, &matrix);
								cairo_set_source(core->temp_cairo, core->brush_pattern);
								cairo_paint_with_alpha(core->temp_cairo, alpha);
								cairo_matrix_init_translate(&matrix, 0, 0);
								cairo_pattern_set_matrix(core->temp_pattern, &matrix);
								cairo_set_source(update, core->temp_pattern);
								cairo_mask_surface(update,
									window->active_layer->surface_p, - draw_x + r, - draw_y + r);
							}
						}
						else
						{
							if((window->active_layer->flags & LAYER_LOCK_OPACITY) == 0)
							{
								cairo_matrix_init_scale(&matrix, zoom, zoom);
								cairo_pattern_set_matrix(core->brush_pattern, &matrix);
								cairo_set_source(core->temp_cairo, core->brush_pattern);
								cairo_paint_with_alpha(core->temp_cairo, alpha);
								cairo_matrix_init_translate(&matrix, 0, 0);
								cairo_pattern_set_matrix(core->temp_pattern, &matrix);
								cairo_set_source(update, core->temp_pattern);
								cairo_mask_surface(update,
									window->selection->surface_p, - draw_x + r, - draw_y + r);
							}
							else
							{
								cairo_surface_t *temp_surface = cairo_surface_create_for_rectangle(
									window->temp_layer->surface_p, start_x, start_y, r*2+1, r*2+1);
								cairo_t *update_temp = cairo_create(temp_surface);

								cairo_matrix_init_scale(&matrix, zoom, zoom);
								cairo_pattern_set_matrix(core->brush_pattern, &matrix);
								cairo_set_source(core->temp_cairo, core->brush_pattern);
								cairo_paint_with_alpha(core->temp_cairo, alpha);
								cairo_matrix_init_translate(&matrix, 0, 0);
								cairo_pattern_set_matrix(core->temp_pattern, &matrix);
								cairo_set_source(update, core->temp_pattern);

								for(i=0; i<height; i++)
								{
									(void)memset(&window->temp_layer->pixels[
										(i+start_y)*window->temp_layer->stride+start_x*4],
										0, stride
									);
								}

								cairo_mask_surface(update,
									window->selection->surface_p, - draw_x + r, - draw_y + r);
								cairo_set_source_surface(update_temp,
									update_surface, 0, 0);
								cairo_mask_surface(update_temp,
									window->active_layer->surface_p, - draw_x + r, - draw_y + r);
	
								mask = window->temp_layer->pixels;

								cairo_surface_destroy(temp_surface);
								cairo_destroy(update_temp);
							}
						}
					}
					else
					{
						cairo_surface_t *temp_surface = cairo_surface_create_for_rectangle(
							window->temp_layer->surface_p, start_x, start_y, r*2+1, r*2+1);
						cairo_t *update_temp = cairo_create(temp_surface);

						if((window->flags & DRAW_WINDOW_HAS_SELECTION_AREA) == 0)
						{
							if((window->active_layer->flags & LAYER_LOCK_OPACITY) == 0)
							{
								cairo_matrix_init_scale(&matrix, zoom, zoom);
								cairo_pattern_set_matrix(core->brush_pattern, &matrix);
								cairo_set_source(update, core->brush_pattern);
								cairo_paint_with_alpha(update, alpha);
							}
							else
							{
								cairo_matrix_init_scale(&matrix, zoom, zoom);
								cairo_pattern_set_matrix(core->brush_pattern, &matrix);
								cairo_set_source(core->temp_cairo, core->brush_pattern);
								cairo_paint_with_alpha(core->temp_cairo, alpha);
								cairo_matrix_init_translate(&matrix, 0, 0);
								cairo_pattern_set_matrix(core->temp_pattern, &matrix);
								cairo_set_source(update, core->temp_pattern);
								cairo_mask_surface(update,
									window->active_layer->surface_p, - draw_x + r, - draw_y + r);
							}

							for(i=0; i<height; i++)
							{
								(void)memset(&window->temp_layer->pixels[
									(i+start_y)*window->temp_layer->stride+start_x*4],
									0, stride
								);
							}

							cairo_set_source_surface(update_temp, update_surface, 0, 0);
							cairo_mask_surface(update_temp, window->texture->surface_p, - draw_x + r, - draw_y + r);

							mask = window->temp_layer->pixels;
						}
						else
						{
							if((window->active_layer->flags & LAYER_LOCK_OPACITY) == 0)
							{
								cairo_matrix_init_scale(&matrix, zoom, zoom);
								cairo_pattern_set_matrix(core->brush_pattern, &matrix);
								cairo_set_source(core->temp_cairo, core->brush_pattern);
								cairo_paint_with_alpha(core->temp_cairo, alpha);
								cairo_matrix_init_translate(&matrix, 0, 0);
								cairo_pattern_set_matrix(core->temp_pattern, &matrix);
								cairo_set_source(update, core->temp_pattern);
								cairo_mask_surface(update,
									window->selection->surface_p, - draw_x + r, - draw_y + r);

								for(i=0; i<height; i++)
								{
									(void)memset(&window->temp_layer->pixels[
										(i+start_y)*window->temp_layer->stride+start_x*4],
										0, stride
									);
								}

								cairo_set_source_surface(update_temp, update_surface, 0, 0);
								cairo_mask_surface(update_temp, window->texture->surface_p, - draw_x + r, - draw_y + r);

								mask = window->temp_layer->pixels;
							}
							else
							{
								cairo_matrix_init_scale(&matrix, zoom, zoom);
								cairo_pattern_set_matrix(core->brush_pattern, &matrix);
								cairo_set_source(core->temp_cairo, core->brush_pattern);
								cairo_paint_with_alpha(core->temp_cairo, alpha);
								cairo_matrix_init_translate(&matrix, 0, 0);
								cairo_pattern_set_matrix(core->temp_pattern, &matrix);
								cairo_set_source(update, core->temp_pattern);

								for(i=0; i<height; i++)
								{
									(void)memset(&window->temp_layer->pixels[
										(i+start_y)*window->temp_layer->stride+start_x*4],
										0, stride
									);
								}

								cairo_mask_surface(update,
									window->selection->surface_p, - draw_x + r, - draw_y + r);
								cairo_set_source_surface(update_temp,
									update_surface, 0, 0);
								cairo_mask_surface(update_temp,
									window->active_layer->surface_p, - draw_x + r, - draw_y + r);
	
								for(i=0; i<height; i++)
								{
									(void)memset(&window->mask_temp->pixels[
										(i+start_y)*window->mask_temp->stride+start_x*4],
										0, stride
									);
								}

								cairo_set_source_surface(update, temp_surface, 0, 0);
								cairo_mask_surface(update, window->texture->surface_p, - draw_x + r, - draw_y + r);
							}
						}

						cairo_surface_destroy(temp_surface);
						cairo_destroy(update_temp);
					}

					cairo_surface_destroy(update_surface);
					cairo_destroy(update);

#ifdef _OPENMP
#pragma omp parallel for firstprivate(width, work_pixel, layer_stride, start_x, start_y)
#endif
					for(i=0; i<height; i++)
					{
						uint8 *ref_pix = &work_pixel[
							(start_y+i)*layer_stride+start_x*4];
						uint8 *mask_pix = &mask[(start_y+i)*layer_stride
							+start_x*4];
						int j;

						for(j=0; j<width; j++, ref_pix+=4, mask_pix+=4)
						{
							if(ref_pix[3] < mask_pix[3])
							{
								ref_pix[0] = (uint8)((uint32)(((int)mask_pix[0]-(int)ref_pix[0])
									* mask_pix[3] >> 8) + ref_pix[0]);
								ref_pix[1] = (uint8)((uint32)(((int)mask_pix[1]-(int)ref_pix[1])
									* mask_pix[3] >> 8) + ref_pix[1]);
								ref_pix[2] = (uint8)((uint32)(((int)mask_pix[2]-(int)ref_pix[2])
									* mask_pix[3] >> 8) + ref_pix[2]);
								ref_pix[3] = (uint8)((uint32)(((int)mask_pix[3]-(int)ref_pix[3])
									* mask_pix[3] >> 8) + ref_pix[3]);
							}
						}
					}

					// アンチエイリアスを適用
					if((brush->flags & BRUSH_FLAG_ANTI_ALIAS) != 0)
					{
						ANTI_ALIAS_RECTANGLE range = {start_x - 1, start_y - 1,
							width + 3, height + 3};
						AntiAliasLayer(window->work_layer, window->temp_layer, &range);
					}
skip_draw:
					dx -= step;
					if(dx < 1)
					{
						break;
					}
					else if(dx >= step)
					{
						draw_x += diff_x, draw_y += diff_y;
					}
					else
					{
						draw_x = brush->points[ref_point][1];
						draw_y = brush->points[ref_point][2];
					}
				} while(1);
			}

			brush->finish_length += d;
			brush->travel += d;
			brush->draw_finished++;
			ref_point = brush->draw_finished % BRUSH_POINT_BUFFER_SIZE;
		}	// while(brush->ref_point > brush->draw_finished)

		AddBrushHistory(core, window->active_layer);

		window->update.surface_p = cairo_surface_create_for_rectangle(
			window->active_layer->surface_p, window->update.x, window->update.y,
				window->update.width, window->update.height);
		window->update.cairo_p = cairo_create(window->update.surface_p);
		window->part_layer_blend_functions[window->work_layer->layer_mode](window->work_layer, &window->update);
		cairo_surface_destroy(window->update.surface_p);
		cairo_destroy(window->update.cairo_p);

		(void)memset(window->work_layer->pixels, 0, window->work_layer->stride*window->work_layer->height);

		window->work_layer->layer_mode = LAYER_BLEND_NORMAL;
		window->flags |= DRAW_WINDOW_UPDATE_PART;
	}	// マウスの左ボタンなら
		// if(((GdkEventButton*)state)->button == 1)
}

static void AirBrushEditSelectionReleaseCallBack(
	DRAW_WINDOW* window,
	FLOAT_T x,
	FLOAT_T y,
	FLOAT_T pressure,
	BRUSH_CORE *core,
	void* state
)
{
	// マウスの左ボタンなら
	if(((GdkEventButton*)state)->button == 1)
	{
		// ブラシの詳細情報にキャスト
		AIR_BRUSH *brush = (AIR_BRUSH*)core->brush_data;
		// ブラシの縮小率
		FLOAT_T zoom;
		// ブラシの半径と不透明度
		FLOAT_T r, alpha;
		// 座標の最大・最小値
		FLOAT_T min_x, min_y, max_x, max_y;
		// X、Y方向の移動量
		FLOAT_T dx, dy;
		// ブラシの傾き用
		FLOAT_T diff_x, diff_y;
		// ブラシの移動量
		FLOAT_T d, step;
		// 描画を行う座標
		FLOAT_T draw_x, draw_y;
		// 入り、抜き時の色補正
		FLOAT_T enter_alpha, out_alpha;
		// ピクセルデータをリセットする座標
		int start_x, start_y;
		// 描画する幅、高さ、一行分のバイト数
		int width, height, stride;
		// 作業レイヤーの一行分のバイト数
		int layer_stride = window->work_layer->stride;
		// 作業レイヤーのピクセル
		uint8 *work_pixel = window->work_layer->pixels;
		// 描画座標指定用
		cairo_matrix_t matrix;
		// 参照ピクセル
		uint8 *mask;
		// 配列のインデックス用
		int ref_point;
		int before_point;
		int i;	// for文用のカウンタ

		while(brush->ref_point > brush->draw_finished)
		{
			ref_point = brush->draw_finished % BRUSH_POINT_BUFFER_SIZE;

			if(brush->finish_length < brush->enter_length)
			{
				enter_alpha = brush->finish_length / brush->enter_length;
				r = brush->enter_size + brush->finish_length * 0.25;
			}
			else
			{
				enter_alpha = 1;
				r = brush->r;
			}
			if(brush->sum_distance < brush->draw_start)
			{
				out_alpha = brush->sum_distance / brush->draw_start;
				r -= (brush->draw_start - brush->sum_distance) * 0.25;
			}
			else
			{
				out_alpha = 1;
			}

			if(r < 0.0)
			{
				brush->draw_finished++;
				continue;
			}

			if((brush->flags & BRUSH_FLAG_SIZE) != 0)
			{
				r *= brush->points[ref_point][3];
			}
			alpha = ((brush->flags & BRUSH_FLAG_FLOW) == 0)
				? 1 : brush->points[ref_point][3];
			alpha *= enter_alpha * out_alpha;
			before_point = (ref_point == 0) ? BRUSH_POINT_BUFFER_SIZE - 1 : ref_point - 1;
			if(r > MIN_BRUSH_STEP)
			{
				d = brush->points[ref_point][0];
				brush->sum_distance -= d;
				step = r * BRUSH_STEP;
				if(step < 0.5)
				{
					step = 0.5;
				}
				zoom = brush->r / r;
				if(brush->draw_finished == 0)
				{
					draw_x = brush->points[0][1], draw_y = brush->points[0][2];
				}
				else
				{
					draw_x = brush->points[before_point][1], draw_y = brush->points[before_point][2];
				}
				dx = brush->points[ref_point][1] - draw_x;
				dy = brush->points[ref_point][2] - draw_y;
				diff_x = step * dx / d, diff_y = step * dy / d;

				min_x = brush->points[ref_point][1] - r - 1;
				max_x = brush->points[ref_point][1] + r + 1;
				min_y = brush->points[ref_point][2] - r - 1;
				max_y = brush->points[ref_point][2] + r + 1;
				if(min_x < 0.0)
				{
					min_x = 0.0;
				}
				if(core->min_x > min_x)
				{
					core->min_x = min_x;
				}
				if(min_y < 0.0)
				{
					min_y = 0.0;
				}
				if(core->min_y > min_y)
				{
					core->min_y = min_y;
				}
				if(max_x > window->work_layer->width)
				{
					max_x = window->work_layer->width;
				}
				if(core->max_x < max_x)
				{
					core->max_x = max_x;
				}
				if(max_y > window->work_layer->height)
				{
					min_y = window->work_layer->height;
				}
				if(core->max_y < max_y)
				{
					core->max_y = max_y;
				}

				dx = d;
				do
				{
					start_x = (int)(draw_x - r);
					start_y = (int)(draw_y - r);
					width = (int)(draw_x + r);
					height = (int)(draw_y + r);

					if(start_x < 0)
					{
						start_x = 0;
					}
					else if(start_x > window->work_layer->width)
					{
						goto skip_draw;
					}
					if(start_y < 0)
					{
						start_y = 0;
					}
					else if(start_y > window->work_layer->height)
					{
						goto skip_draw;
					}
					if(width > window->work_layer->width)
					{
						width = window->work_layer->width - start_x;
					}
					else
					{
						width = width - start_x;
					}
					if(height > window->work_layer->height)
					{
						height = window->work_layer->height - start_y;
					}
					else
					{
						height = height - start_y;
					}
					stride = width*4;

					if(width <= 0 || height <= 0)
					{
						goto skip_draw;
					}

					for(i=0; i<height; i++)
					{
						(void)memset(&window->mask_temp->pixels[(i+start_y)*window->mask_temp->stride+start_x*4],
							0, stride);
					}

					cairo_set_operator(window->mask_temp->cairo_p, CAIRO_OPERATOR_OVER);

					mask = window->mask_temp->pixels;
					if((window->flags & DRAW_WINDOW_HAS_SELECTION_AREA) == 0)
					{
						if((window->active_layer->flags & LAYER_LOCK_OPACITY) == 0)
						{
							cairo_matrix_init_scale(&matrix, zoom, zoom);
							cairo_matrix_translate(&matrix, - draw_x + r, - draw_y + r);
							cairo_pattern_set_matrix(core->brush_pattern, &matrix);
							cairo_set_source(window->mask_temp->cairo_p, core->brush_pattern);
							cairo_paint_with_alpha(window->mask_temp->cairo_p, alpha);
						}
						else
						{
							cairo_matrix_init_scale(&matrix, zoom, zoom);
							cairo_pattern_set_matrix(core->brush_pattern, &matrix);
							cairo_set_source(core->temp_cairo, core->brush_pattern);
							cairo_paint_with_alpha(core->temp_cairo, alpha);
							cairo_matrix_init_translate(&matrix, - draw_x + r, - draw_y + r);
							cairo_pattern_set_matrix(core->temp_pattern, &matrix);
							cairo_set_source(window->mask_temp->cairo_p, core->temp_pattern);
							cairo_mask_surface(window->mask_temp->cairo_p,
								window->active_layer->surface_p, 0, 0);
						}
					}
					else
					{
						if((window->active_layer->flags & LAYER_LOCK_OPACITY) == 0)
						{
							cairo_matrix_init_scale(&matrix, zoom, zoom);
							cairo_pattern_set_matrix(core->brush_pattern, &matrix);
							cairo_set_source(core->temp_cairo, core->brush_pattern);
							cairo_paint_with_alpha(core->temp_cairo, alpha);
							cairo_matrix_init_translate(&matrix, - draw_x + r, - draw_y + r);
							cairo_pattern_set_matrix(core->temp_pattern, &matrix);
							cairo_set_source(window->mask_temp->cairo_p, core->temp_pattern);
							cairo_mask_surface(window->mask_temp->cairo_p,
								window->selection->surface_p, 0, 0);
						}
						else
						{
							cairo_matrix_init_scale(&matrix, zoom, zoom);
							cairo_pattern_set_matrix(core->brush_pattern, &matrix);
							cairo_set_source(core->temp_cairo, core->brush_pattern);
							cairo_paint_with_alpha(core->temp_cairo, alpha);
							cairo_matrix_init_translate(&matrix, - draw_x + r, - draw_y + r);
							cairo_pattern_set_matrix(core->temp_pattern, &matrix);
							cairo_set_source(window->mask_temp->cairo_p, core->temp_pattern);

							for(i=0; i<height; i++)
							{
								(void)memset(&window->temp_layer->pixels[
									(i+start_y)*window->temp_layer->stride+start_x*4],
									0, stride
								);
							}

							cairo_mask_surface(window->mask_temp->cairo_p,
								window->selection->surface_p, 0, 0);
							cairo_set_source_surface(window->temp_layer->cairo_p,
								window->mask_temp->surface_p, 0, 0);
							cairo_mask_surface(window->temp_layer->cairo_p,
								window->active_layer->surface_p, 0, 0);
	
							mask = window->temp_layer->pixels;
						}
					}

#ifdef _OPENMP
#pragma omp parallel for firstprivate(width, work_pixel, layer_stride, start_x, start_y)
#endif
					for(i=0; i<height; i++)
					{
						uint8 *ref_pix = &work_pixel[
							(start_y+i)*layer_stride+start_x*4];
						uint8 *mask_pix = &mask[(start_y+i)*layer_stride
							+start_x*4];
						int j;

						for(j=0; j<width; j++, ref_pix+=4, mask_pix+=4)
						{
							if(ref_pix[3] < mask_pix[3])
							{
								ref_pix[0] = (uint8)((uint32)(((int)mask_pix[0]-(int)ref_pix[0])
									* mask_pix[3] >> 8) + ref_pix[0]);
								ref_pix[1] = (uint8)((uint32)(((int)mask_pix[1]-(int)ref_pix[1])
									* mask_pix[3] >> 8) + ref_pix[1]);
								ref_pix[2] = (uint8)((uint32)(((int)mask_pix[2]-(int)ref_pix[2])
									* mask_pix[3] >> 8) + ref_pix[2]);
								ref_pix[3] = (uint8)((uint32)(((int)mask_pix[3]-(int)ref_pix[3])
									* mask_pix[3] >> 8) + ref_pix[3]);
							}
						}
					}

					// アンチエイリアスを適用
					if((brush->flags & BRUSH_FLAG_ANTI_ALIAS) != 0)
					{
						ANTI_ALIAS_RECTANGLE range = {start_x - 1, start_y - 1,
							width + 1, height + 1};
						AntiAliasLayer(window->work_layer, window->temp_layer, &range);
					}
skip_draw:
					dx -= step;
					if(dx < 1)
					{
						break;
					}
					else if(dx >= step)
					{
						draw_x += diff_x, draw_y += diff_y;
					}
					else
					{
						draw_x = brush->points[ref_point][1];
						draw_y = brush->points[ref_point][2];
					}
				} while(1);
			}

			brush->finish_length += d;
			brush->travel += d;
			brush->draw_finished++;
			ref_point = brush->draw_finished % BRUSH_POINT_BUFFER_SIZE;
		}	// while(brush->ref_point > brush->draw_finished)

		AddSelectionEditHistory(core, window->selection);

		g_blend_selection_funcs[window->selection->layer_mode](window->work_layer, window->selection);

		(void)memset(window->work_layer->pixels, 0, window->work_layer->stride*window->work_layer->height);

		window->work_layer->layer_mode = LAYER_BLEND_NORMAL;
	}	// マウスの左ボタンなら
		// if(((GdkEventButton*)state)->button == 1)
}

static void AirBrushDrawCursor(
	DRAW_WINDOW* window,
	FLOAT_T x,
	FLOAT_T y,
	void* data
)
{
	AIR_BRUSH* brush = (AIR_BRUSH*)data;
	FLOAT_T r = brush->r * window->zoom_rate;
	cairo_set_line_width(window->disp_temp->cairo_p, 1.0);
	cairo_set_source_rgb(window->disp_temp->cairo_p, 1, 1, 1);
	cairo_arc(window->disp_temp->cairo_p, x, y, r, 0, 2*G_PI);
	cairo_stroke(window->disp_temp->cairo_p);

	cairo_rectangle(window->disp_layer->cairo_p, x - r, y - r,
		(r + BRUSH_UPDATE_MARGIN) * 2, (r + BRUSH_UPDATE_MARGIN) * 2);
	cairo_clip(window->disp_layer->cairo_p);
}

static void AirBrushButtonUpdate(DRAW_WINDOW* window, FLOAT_T x, FLOAT_T y, AIR_BRUSH* brush)
{
	FLOAT_T r = brush->r * window->zoom_rate + 1;
	gtk_widget_queue_draw_area(window->window, (gint)(x - r - 1),
		(gint)(y - r - 1), (gint)(r * 2) + 2, (gint)(r * 2) + 2);
}

static void AirBrushMotionUpdate(DRAW_WINDOW* window, FLOAT_T x, FLOAT_T y, AIR_BRUSH* brush)
{
	FLOAT_T start_x, start_y;
	FLOAT_T width, height;
	FLOAT_T r = brush->r * window->zoom_rate * 1.275 + BRUSH_UPDATE_MARGIN;
	FLOAT_T enter = (brush->enter_length + brush->draw_start) * window->zoom_rate;

	if(window->before_cursor_x < x)
	{
		start_x = window->before_cursor_x - r;
		width = r * 2 + x - window->before_cursor_x;
	}
	else
	{
		start_x = x - r;
		width = r * 2 + window->before_cursor_x - x;
	}

	if(window->before_cursor_y < y)
	{
		start_y = window->before_cursor_y - r;
		height = r * 2 + y - window->before_cursor_y;
	}
	else
	{
		start_y = y - r;
		height = r * 2 + window->before_cursor_y - y;
	}

	start_x -= enter * 4;
	width += enter * 4 * 2 + 2;
	start_y -= enter * 4;
	height += enter * 4 * 2 + 2;

	gtk_widget_queue_draw_area(window->window,
		(gint)start_x, (gint)start_y, (gint)width, (gint)height);
}

static void AirBrushColorChange(const uint8 color[3], void* data)
{
	AIR_BRUSH *brush = (AIR_BRUSH*)data;
	BrushCoreSetCirclePattern(brush->core, brush->r, brush->outline_hardness * 0.01, brush->blur * 0.01,
		brush->opacity * 0.01, *brush->core->color);
}

static void AirBrushSetScale(GtkAdjustment* slider, AIR_BRUSH* brush)
{
	brush->r = gtk_adjustment_get_value(slider) * 0.5;
	BrushCoreSetCirclePattern(brush->core, brush->r, brush->outline_hardness * 0.01, brush->blur * 0.01,
		brush->opacity * 0.01, *brush->core->color);
}

static void AirBrushSetFlow(GtkAdjustment* slider, AIR_BRUSH* brush)
{
	brush->opacity = gtk_adjustment_get_value(slider);
	BrushCoreSetCirclePattern(brush->core, brush->r, brush->outline_hardness * 0.01, brush->blur * 0.01,
		brush->opacity * 0.01, *brush->core->color);
}

static void AirBrushSetBlur(GtkAdjustment* slider, AIR_BRUSH* brush)
{
	brush->blur = gtk_adjustment_get_value(slider);
	BrushCoreSetCirclePattern(brush->core, brush->r, brush->outline_hardness * 0.01, brush->blur * 0.01,
		brush->opacity * 0.01, *brush->core->color);
}

static void AirBrushSetOutlineHardness(GtkAdjustment* slider, AIR_BRUSH* brush)
{
	brush->outline_hardness = gtk_adjustment_get_value(slider);
	BrushCoreSetCirclePattern(brush->core, brush->r, brush->outline_hardness * 0.01, brush->blur * 0.01,
		brush->opacity * 0.01, *brush->core->color);
}

static void AirBrushSetEnterSize(GtkAdjustment* slider, AIR_BRUSH* brush)
{
	brush->enter = gtk_adjustment_get_value(slider);
}

static void AirBrushSetOutSize(GtkAdjustment* slider, AIR_BRUSH* brush)
{
	brush->out = gtk_adjustment_get_value(slider);
}

static void AirBrushSetPressureSize(GtkWidget* button, AIR_BRUSH* brush)
{
	if(gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(button)) == FALSE)
	{
		brush->flags &= ~(BRUSH_FLAG_SIZE);
	}
	else
	{
		brush->flags |= BRUSH_FLAG_SIZE;
	}
}

static void AirBrushSetPressureFlow(GtkWidget* button, AIR_BRUSH* brush)
{
	if(gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(button)) == FALSE)
	{
		brush->flags &= ~(BRUSH_FLAG_FLOW);
	}
	else
	{
		brush->flags |= BRUSH_FLAG_FLOW;
	}
}

static void AirBrushSetBlendMode(GtkComboBox* combo, AIR_BRUSH* brush)
{
	brush->blend_mode = (uint16)gtk_combo_box_get_active(combo);
}

static void AirBrushSetAntiAlias(GtkWidget* button, AIR_BRUSH* brush)
{
	if(gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(button)) == FALSE)
	{
		brush->flags &= ~(BRUSH_FLAG_ANTI_ALIAS);
	}
	else
	{
		brush->flags |= BRUSH_FLAG_ANTI_ALIAS;
	}
}

static GtkWidget* CreateAirBrushDetailUI(APPLICATION* app, BRUSH_CORE* core)
{
#define UI_FONT_SIZE 8.0
	AIR_BRUSH *brush = (AIR_BRUSH*)core->brush_data;
	GtkWidget *vbox = gtk_vbox_new(FALSE, 0);
	GtkWidget *hbox;
	GtkWidget *brush_scale;
	GtkWidget *check_button;
	GtkWidget *combo;
	GtkWidget *label;
	GtkAdjustment *scale_adjustment;
	char mark_up_buff[256];
	int i;

	brush->core = core;

	{
		const char *mag_str[] = {"x 0.1", "x 1", "x 10"};
		hbox = gtk_hbox_new(FALSE, 0);
		label = gtk_label_new("");
		(void)sprintf(mark_up_buff, "<span font_desc=\"%.2f\">%s : </span>",
			UI_FONT_SIZE * app->gui_scale, app->labels->tool_box.base_scale);
		gtk_label_set_markup(GTK_LABEL(label), mark_up_buff);
		gtk_box_pack_start(GTK_BOX(hbox), label, FALSE, FALSE, 0);
#if GTK_MAJOR_VERSION <= 2
		combo = gtk_combo_box_new_text();
		gtk_combo_box_append_text(GTK_COMBO_BOX(combo), mag_str[0]);
		gtk_combo_box_append_text(GTK_COMBO_BOX(combo), mag_str[1]);
		gtk_combo_box_append_text(GTK_COMBO_BOX(combo), mag_str[2]);
#else
		combo = gtk_combo_box_text_new();
		gtk_combo_box_text_append_text(GTK_COMBO_BOX_TEXT(combo), mag_str[0]);
		gtk_combo_box_text_append_text(GTK_COMBO_BOX_TEXT(combo), mag_str[1]);
		gtk_combo_box_text_append_text(GTK_COMBO_BOX_TEXT(combo), mag_str[2]);
#endif
		gtk_combo_box_set_active(GTK_COMBO_BOX(combo), brush->base_scale);
		gtk_box_pack_start(GTK_BOX(hbox), combo, TRUE, TRUE, 0);
		gtk_box_pack_start(GTK_BOX(vbox), hbox, FALSE, FALSE, 0);
	}

	switch(brush->base_scale)
	{
	case 0:
		scale_adjustment = GTK_ADJUSTMENT(gtk_adjustment_new(
			brush->r * 2, 0.1, 10.0, 0.1, 0.1, 0.0));
		break;
	case 1:
		scale_adjustment = GTK_ADJUSTMENT(gtk_adjustment_new(
			brush->r * 2, 1.0, 100.0, 1.0, 1.0, 0.0));
		break;
	default:
		scale_adjustment = GTK_ADJUSTMENT(gtk_adjustment_new(
			brush->r * 2, 5.0, 500.0, 1.0, 1.0, 0.0));
	}

	(void)g_signal_connect(G_OBJECT(scale_adjustment), "value_changed",
		G_CALLBACK(AirBrushSetScale), core->brush_data);
	brush_scale = SpinScaleNew(scale_adjustment, app->labels->tool_box.brush_scale, 1);
	gtk_box_pack_start(GTK_BOX(vbox), brush_scale, FALSE, FALSE, 0);

	g_object_set_data(G_OBJECT(combo), "scale", brush_scale);
	(void)g_signal_connect(G_OBJECT(combo), "changed", G_CALLBACK(SetBrushBaseScale), &brush->base_scale);

	scale_adjustment = GTK_ADJUSTMENT(gtk_adjustment_new(
		brush->opacity, 0.0, 100.0, 1.0, 1.0, 0.0));
	(void)g_signal_connect(G_OBJECT(scale_adjustment), "value_changed",
		G_CALLBACK(AirBrushSetFlow), core->brush_data);
	brush_scale = SpinScaleNew(scale_adjustment, app->labels->tool_box.flow, 1);
	gtk_box_pack_start(GTK_BOX(vbox), brush_scale, FALSE, FALSE, 0);

	scale_adjustment = GTK_ADJUSTMENT(gtk_adjustment_new(
		brush->outline_hardness, 0.0, 100.0, 1.0, 1.0, 0.0));
	(void)g_signal_connect(G_OBJECT(scale_adjustment), "value_changed",
		G_CALLBACK(AirBrushSetOutlineHardness), core->brush_data);
	brush_scale = SpinScaleNew(scale_adjustment, app->labels->tool_box.outline_hardness, 1);
	gtk_box_pack_start(GTK_BOX(vbox), brush_scale, FALSE, FALSE, 0);

	scale_adjustment = GTK_ADJUSTMENT(gtk_adjustment_new(
		brush->blur, 0.0, 100.0, 1.0, 1.0, 0.0));
	(void)g_signal_connect(G_OBJECT(scale_adjustment), "value_changed",
		G_CALLBACK(AirBrushSetBlur), core->brush_data);
	brush_scale = SpinScaleNew(scale_adjustment, app->labels->tool_box.blur, 1);
	gtk_box_pack_start(GTK_BOX(vbox), brush_scale, FALSE, FALSE, 0);

	scale_adjustment = GTK_ADJUSTMENT(gtk_adjustment_new(
		brush->enter, 0.0, 100.0, 1.0, 1.0, 0.0));
	(void)g_signal_connect(G_OBJECT(scale_adjustment), "value_changed",
		G_CALLBACK(AirBrushSetEnterSize), core->brush_data);
	brush_scale = SpinScaleNew(scale_adjustment, app->labels->tool_box.enter, 1);
	gtk_box_pack_start(GTK_BOX(vbox), brush_scale, FALSE, FALSE, 0);

	scale_adjustment = GTK_ADJUSTMENT(gtk_adjustment_new(
		brush->out, 0.0, 100.0, 1.0, 1.0, 0.0));
	(void)g_signal_connect(G_OBJECT(scale_adjustment), "value_changed",
		G_CALLBACK(AirBrushSetOutSize), core->brush_data);
	brush_scale = SpinScaleNew(scale_adjustment, app->labels->tool_box.out, 1);
	gtk_box_pack_start(GTK_BOX(vbox), brush_scale, FALSE, FALSE, 0);

	hbox = gtk_hbox_new(FALSE, 0);
	label = gtk_label_new("");
#if GTK_MAJOR_VERSION <= 2
	combo = gtk_combo_box_new_text();
#else
	combo = gtk_combo_box_text_new();
#endif
	(void)sprintf(mark_up_buff, "<span font_desc=\"%.2f\">%s : </span>",
		UI_FONT_SIZE * app->gui_scale, app->labels->layer_window.blend_mode);
	gtk_label_set_markup(GTK_LABEL(label), mark_up_buff);
	gtk_box_pack_start(GTK_BOX(hbox), label, FALSE, FALSE, 0);
	for(i=0; i<LAYER_BLEND_SLELECTABLE_NUM; i++)
	{
#if GTK_MAJOR_VERSION <= 2
		gtk_combo_box_append_text(GTK_COMBO_BOX(combo), app->labels->layer_window.blend_modes[i]);
#else
		gtk_combo_box_text_append_text(GTK_COMBO_BOX_TEXT(combo), app->labels->layer_window.blend_modes[i]);
#endif
	}
	gtk_combo_box_set_active(GTK_COMBO_BOX(combo), brush->blend_mode);
	(void)g_signal_connect(G_OBJECT(combo), "changed",
		G_CALLBACK(AirBrushSetBlendMode), brush);
	gtk_box_pack_start(GTK_BOX(hbox), combo, FALSE, TRUE, 0);
	gtk_box_pack_start(GTK_BOX(vbox), hbox, FALSE, TRUE, 0);

	hbox = gtk_hbox_new(FALSE, 0);
	label = gtk_label_new("");
	(void)sprintf(mark_up_buff, "<span font_desc=\"%.2f\">%s : </span>",
		UI_FONT_SIZE * app->gui_scale, app->labels->tool_box.pressure);
	gtk_label_set_markup(GTK_LABEL(label), mark_up_buff);
	gtk_box_pack_start(GTK_BOX(hbox), label, FALSE, FALSE, 0);
	check_button = gtk_check_button_new_with_label(app->labels->tool_box.scale);
	(void)g_signal_connect(G_OBJECT(check_button), "toggled",
		G_CALLBACK(AirBrushSetPressureSize), core->brush_data);
	gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(check_button), brush->flags & BRUSH_FLAG_SIZE);
	gtk_box_pack_start(GTK_BOX(hbox), check_button, FALSE, TRUE, 0);
	check_button = gtk_check_button_new_with_label(app->labels->tool_box.flow);
	(void)g_signal_connect(G_OBJECT(check_button), "toggled",
		G_CALLBACK(AirBrushSetPressureFlow), core->brush_data);
	gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(check_button), brush->flags & BRUSH_FLAG_FLOW);
	gtk_box_pack_start(GTK_BOX(hbox), check_button, FALSE, TRUE, 0);
	gtk_box_pack_start(GTK_BOX(vbox), hbox, FALSE, TRUE, 0);

	check_button = gtk_check_button_new_with_label(app->labels->tool_box.anti_alias);
	(void)g_signal_connect(G_OBJECT(check_button), "toggled",
		G_CALLBACK(AirBrushSetAntiAlias), core->brush_data);
	gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(check_button), brush->flags & BRUSH_FLAG_ANTI_ALIAS);
	gtk_box_pack_start(GTK_BOX(vbox), check_button, FALSE, TRUE, 0);

	BrushCoreSetCirclePattern(brush->core, brush->r, brush->outline_hardness * 0.01, brush->blur * 0.01,
		brush->opacity * 0.01, *brush->core->color);

	return vbox;
#undef UI_FONT_SIZE
}

static void OldAirBrushPressCallBack(
	DRAW_WINDOW* window,
	FLOAT_T x,
	FLOAT_T y,
	FLOAT_T pressure,
	BRUSH_CORE *core,
	void* state
)
{
	if(((GdkEventButton*)state)->button == 1)
	{
		OLD_AIR_BRUSH* pen = (OLD_AIR_BRUSH*)core->brush_data;
		FLOAT_T r, alpha;
		FLOAT_T min_x, min_y, max_x, max_y;
		uint8* color = *core->color;
		cairo_pattern_t *brush;

		if((window->active_layer->flags & LAYER_LOCK_OPACITY) == 0)
		{
			window->work_layer->layer_mode = LAYER_BLEND_NORMAL;
		}
		else
		{
			window->work_layer->layer_mode = LAYER_BLEND_ATOP;
		}

		r = ((pen->flags & BRUSH_FLAG_SIZE) == 0) ?
			pen->r : pen->r * pressure;
		alpha = ((pen->flags & BRUSH_FLAG_FLOW) == 0) ?
			pen->opacity * 0.01 : pen->opacity * 0.01 * pressure;

		min_x = x - r, min_y = y - r;
		max_x = x + r, max_y = y + r;

		pen->before_x = x, pen->before_y = y;

		if(min_x < 0.0)
		{
			min_x = 0.0;
		}
		if(min_y < 0.0)
		{
			min_y = 0.0;
		}
		if(max_x > window->work_layer->width)
		{
			max_x = window->work_layer->width;
		}
		if(max_y > window->work_layer->height)
		{
			max_y = window->work_layer->height;
		}

		core->min_x = min_x, core->min_y = min_y;
		core->max_x = max_x, core->max_y = max_y;

		cairo_set_operator(window->work_layer->cairo_p, CAIRO_OPERATOR_OVER);
		brush = cairo_pattern_create_radial(x, y, r * 0.0, x, y, r);
		cairo_pattern_set_extend(brush, CAIRO_EXTEND_NONE);
		cairo_pattern_add_color_stop_rgba(brush, 0.0, color[0]*DIV_PIXEL, color[1]*DIV_PIXEL, color[2]*DIV_PIXEL, alpha);
		cairo_pattern_add_color_stop_rgba(brush, 1-pen->blur*0.01f, color[0]*DIV_PIXEL, color[1]*DIV_PIXEL, color[2]*DIV_PIXEL, alpha);
		cairo_pattern_add_color_stop_rgba(brush, 1.0, color[0]*DIV_PIXEL, color[1]*DIV_PIXEL, color[2]*DIV_PIXEL, alpha*pen->outline_hardness*0.01f);
		cairo_set_source(window->work_layer->cairo_p, brush);

		if((window->flags & DRAW_WINDOW_HAS_SELECTION_AREA) == 0)
		{
			cairo_arc(window->work_layer->cairo_p, x, y, r, 0, 2*G_PI);
			cairo_fill(window->work_layer->cairo_p);
		}
		else
		{
			cairo_mask_surface(window->work_layer->cairo_p, window->selection->surface_p, 0, 0);
		}

		cairo_pattern_destroy(brush);
	}
}

#define OldAirBrushEditSelectionPressCallBack OldAirBrushPressCallBack

static void OldAirBrushMotionCallBack(
	DRAW_WINDOW* window,
	FLOAT_T x,
	FLOAT_T y,
	FLOAT_T pressure,
	BRUSH_CORE *core,
	void* state
)
{
	if(((*(GdkModifierType*)state) & GDK_BUTTON1_MASK) != 0)
	{
		OLD_AIR_BRUSH* pen = (OLD_AIR_BRUSH*)core->brush_data;
		FLOAT_T r, half_r, alpha, d, arg;
		FLOAT_T min_x, min_y, max_x, max_y;
		FLOAT_T draw_x = x, draw_y = y;
		FLOAT_T dx, dy, cos_x, sin_y;
		FLOAT_T hardness = pen->outline_hardness * 0.01f;
		int32 clear_x, clear_width, clear_y, clear_height;
		uint8* color = *core->color;
		cairo_pattern_t *brush;
		uint8 alpha_c;
		int i, j, k;

		r = ((pen->flags & BRUSH_FLAG_SIZE) == 0) ?
			pen->r : pen->r * pressure;
		half_r = 1;//r * 0.125;
		alpha = ((pen->flags & BRUSH_FLAG_FLOW) == 0) ?
			pen->opacity * 0.01 : pen->opacity * 0.01 * pressure;
		alpha_c = (uint8)(alpha * 255);
		dx = x-pen->before_x, dy = y-pen->before_y;
		d = sqrt(dx*dx+dy*dy);
		arg = atan2(dy, dx);
		cos_x = cos(arg), sin_y = sin(arg);

		min_x = x - r*2, min_y = y - r*2;
		max_x = x + r*2, max_y = y + r*2;

		if(min_x < 0.0)
		{
			min_x = 0.0;
		}
		if(min_y < 0.0)
		{
			min_y = 0.0;
		}
		if(max_x > window->work_layer->width)
		{
			max_x = window->work_layer->width;
		}
		if(max_y > window->work_layer->height)
		{
			max_y = window->work_layer->height;
		}

		if(core->min_x > min_x)
		{
			core->min_x = min_x;
		}
		if(core->min_y > min_y)
		{
			core->min_y = min_y;
		}
		if(core->max_x < max_x)
		{
			core->max_x = max_x;
		}
		if(core->max_y < max_y)
		{
			core->max_y = max_y;
		}

		cairo_set_operator(window->work_layer->cairo_p, CAIRO_OPERATOR_OVER);
		dx = d;
		do
		{
			clear_x = (int32)(draw_x - r - 1);
			clear_width = (int32)(draw_x + r + 1);
			clear_y = (int32)(draw_y - r - 1);
			clear_height = (int32)(draw_y + r + 1);

			if(clear_x < 0)
			{
				clear_x = 0;
			}
			else if(clear_x >= window->width)
			{
				goto skip_draw;
			}
			if(clear_y < 0)
			{
				clear_y = 0;
			}
			if(clear_height >= window->height)
			{
				clear_height = window->height;
			}
			clear_width = clear_width - clear_x;
			clear_height = clear_height - clear_y;

			if(clear_width <= 0 || clear_height <= 0)
			{
				goto skip_draw;
			}

			for(i=0; i<clear_height; i++)
			{
				(void)memset(&window->temp_layer->pixels[(i+clear_y)*window->work_layer->stride+clear_x*window->work_layer->channel],
					0x0, clear_width*window->work_layer->channel);
			}
			brush = cairo_pattern_create_radial(draw_x, draw_y, r * 0.0, draw_x, draw_y, r);
			cairo_pattern_set_extend(brush, CAIRO_EXTEND_NONE);
			cairo_pattern_add_color_stop_rgba(brush, 0.0, color[0]*DIV_PIXEL, color[1]*DIV_PIXEL, color[2]*DIV_PIXEL, alpha);
			cairo_pattern_add_color_stop_rgba(brush, 1-pen->blur*0.01f, color[0]*DIV_PIXEL, color[1]*DIV_PIXEL, color[2]*DIV_PIXEL, alpha);
			cairo_pattern_add_color_stop_rgba(brush, 1.0, color[0]*DIV_PIXEL, color[1]*DIV_PIXEL, color[2]*DIV_PIXEL, alpha*hardness);
			cairo_set_source(window->temp_layer->cairo_p, brush);

			if((window->flags & DRAW_WINDOW_HAS_SELECTION_AREA) == 0)
			{
				cairo_arc(window->temp_layer->cairo_p, draw_x, draw_y, r, 0, 2*G_PI);
				cairo_fill(window->temp_layer->cairo_p);
			}
			else
			{
				cairo_mask_surface(window->temp_layer->cairo_p, window->selection->surface_p, 0, 0);
			}
		
			for(i=0; i<clear_height; i++)
			{
				for(j=0; j<clear_width; j++)
				{
					if(window->temp_layer->pixels[(clear_y+i)*window->temp_layer->stride+(clear_x+j)*window->temp_layer->channel+3]
						> window->work_layer->pixels[(clear_y+i)*window->work_layer->stride+(clear_x+j)*window->work_layer->channel+3])
					{
						for(k=0; k<window->temp_layer->channel; k++)
						{
							window->work_layer->pixels[(clear_y+i)*window->work_layer->stride+(clear_x+j)*window->work_layer->channel+k] =
								(uint32)(((int)window->temp_layer->pixels[(clear_y+i)*window->temp_layer->stride+(clear_x+j)*window->temp_layer->channel+k]
								- (int)window->work_layer->pixels[(clear_y+i)*window->work_layer->stride+(clear_x+j)*window->work_layer->channel+k])
									* window->temp_layer->pixels[(clear_y+i)*window->temp_layer->stride+(clear_x+j)*window->temp_layer->channel+3] >> 8)
									+ window->work_layer->pixels[(clear_y+i)*window->work_layer->stride+(clear_x+j)*window->work_layer->channel+k];
						}
					}
				}
			}

			cairo_pattern_destroy(brush);

skip_draw:
			dx -= half_r;
			
			draw_x -= cos_x*half_r, draw_y -= sin_y*half_r;
		} while (dx >= half_r);

		pen->before_x = x, pen->before_y = y;
	}
}

#define OldAirBrushEditSelectionMotionCallBack OldAirBrushMotionCallBack

#define OldAirBrushReleaseCallBack DefaultReleaseCallBack
#define OldAirBrushEditSelectionReleaseCallBack DefaultEditSelectionReleaseCallBack

static void OldAirBrushDrawCursor(
	DRAW_WINDOW* window,
	FLOAT_T x,
	FLOAT_T y,
	void* data
)
{
	OLD_AIR_BRUSH* pen = (OLD_AIR_BRUSH*)data;
	cairo_set_line_width(window->disp_temp->cairo_p, 1.0);
	cairo_set_source_rgb(window->disp_temp->cairo_p, 1, 1, 1);
	cairo_arc(window->disp_temp->cairo_p, x, y, pen->r*window->zoom*0.01, 0, 2*G_PI);
	cairo_stroke(window->disp_temp->cairo_p);
}

static void OldAirBrushScaleChange(
	GtkAdjustment* slider,
	OLD_AIR_BRUSH* brush
)
{
	brush->r = gtk_adjustment_get_value(slider) * 0.5;
}

static void OldAirBrushFlowChange(
	GtkAdjustment* slider,
	OLD_AIR_BRUSH* brush
)
{
	brush->opacity = gtk_adjustment_get_value(slider);
}

static void OldAirBrushOutlineHardnessChange(
	GtkAdjustment* slider,
	OLD_AIR_BRUSH* brush
)
{
	brush->outline_hardness = gtk_adjustment_get_value(slider);
}

static void OldAirBrushBlurChange(
	GtkAdjustment* slider,
	OLD_AIR_BRUSH* brush
)
{
	brush->blur = gtk_adjustment_get_value(slider);
}

static void OldAirBrushPressureSizeChange(
	GtkWidget* widget,
	OLD_AIR_BRUSH* brush
)
{
	if(gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(widget)) == FALSE)
	{
		brush->flags &= ~(BRUSH_FLAG_SIZE);
	}
	else
	{
		brush->flags |= BRUSH_FLAG_SIZE;
	}
}

static void OldAirBrushPressureFlowChange(
	GtkWidget* widget,
	OLD_AIR_BRUSH* brush
)
{
	if(gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(widget)) == FALSE)
	{
		brush->flags &= ~(BRUSH_FLAG_FLOW);
	}
	else
	{
		brush->flags |= BRUSH_FLAG_FLOW;
	}
}

static GtkWidget* CreateOldAirBrushDetailUI(APPLICATION* app, BRUSH_CORE* core)
{
#define UI_FONT_SIZE 8.0
	OLD_AIR_BRUSH* brush = (OLD_AIR_BRUSH*)core->brush_data;
	GtkWidget* vbox = gtk_vbox_new(FALSE, 2);
	GtkWidget* brush_scale;
	GtkWidget* table = gtk_table_new(4, 3, TRUE);
	GtkWidget* check_button;
	GtkWidget* label;
	GtkAdjustment* brush_scale_adjustment =
		GTK_ADJUSTMENT(gtk_adjustment_new(brush->r * 2, 1.0, 100.0, 1.0, 1.0, 0.0));
	char mark_up_buff[256];

	brush_scale = SpinScaleNew(brush_scale_adjustment,
		app->labels->tool_box.brush_scale, 1);
	(void)g_signal_connect(G_OBJECT(brush_scale_adjustment), "value_changed",
		G_CALLBACK(OldAirBrushScaleChange), core->brush_data);
	gtk_table_attach_defaults(GTK_TABLE(table), brush_scale, 0, 3, 0, 1);

	brush_scale_adjustment =
		GTK_ADJUSTMENT(gtk_adjustment_new(brush->opacity, 0.0, 100.0, 1.0, 1.0, 0.0));
	brush_scale = SpinScaleNew(brush_scale_adjustment,
		app->labels->tool_box.flow, 1);
	(void)g_signal_connect(G_OBJECT(brush_scale_adjustment), "value_changed",
		G_CALLBACK(OldAirBrushFlowChange), core->brush_data);
	gtk_table_attach_defaults(GTK_TABLE(table), brush_scale, 0, 3, 1, 2);

	brush_scale_adjustment = GTK_ADJUSTMENT(gtk_adjustment_new(brush->outline_hardness,
		0, 100, 1, 1, 0));
	(void)g_signal_connect(G_OBJECT(brush_scale_adjustment), "value_changed",
		G_CALLBACK(OldAirBrushOutlineHardnessChange), core->brush_data);
	brush_scale = SpinScaleNew(brush_scale_adjustment,
		app->labels->tool_box.outline_hardness, 1);
	gtk_table_attach_defaults(GTK_TABLE(table), brush_scale, 0, 3, 2, 3);

	brush_scale_adjustment = GTK_ADJUSTMENT(gtk_adjustment_new(brush->blur,
		0, 100, 1, 1, 0));
	(void)g_signal_connect(G_OBJECT(brush_scale_adjustment), "value_changed",
		G_CALLBACK(OldAirBrushBlurChange), core->brush_data);
	brush_scale = SpinScaleNew(brush_scale_adjustment,
		app->labels->tool_box.blur, 1);
	gtk_table_attach_defaults(GTK_TABLE(table), brush_scale, 0, 3, 3, 4);
	gtk_box_pack_start(GTK_BOX(vbox), table, FALSE, TRUE, 0);

	table = gtk_hbox_new(FALSE, 0);
	label = gtk_label_new("");
	(void)sprintf(mark_up_buff, "<span font_desc=\"%.2f\">%s : </span>",
		UI_FONT_SIZE * app->gui_scale, app->labels->tool_box.pressure);
	gtk_label_set_markup(GTK_LABEL(label), mark_up_buff);
	gtk_box_pack_start(GTK_BOX(table), label, FALSE, TRUE, 0);
	check_button = gtk_check_button_new_with_label(app->labels->tool_box.scale);
	(void)g_signal_connect(G_OBJECT(check_button), "toggled", G_CALLBACK(OldAirBrushPressureSizeChange), core->brush_data);
	gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(check_button), brush->flags & BRUSH_FLAG_SIZE);
	gtk_box_pack_start(GTK_BOX(table), check_button, FALSE, TRUE, 0);
	check_button = gtk_check_button_new_with_label(app->labels->tool_box.flow);
	(void)g_signal_connect(G_OBJECT(check_button), "toggled", G_CALLBACK(OldAirBrushPressureFlowChange), core->brush_data);
	gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(check_button), brush->flags & BRUSH_FLAG_FLOW);
	gtk_box_pack_start(GTK_BOX(table), check_button, FALSE, TRUE, 0);
	gtk_box_pack_start(GTK_BOX(vbox), table, FALSE, TRUE, 0);

	return vbox;
}

static void BlendBrushButtonPressCallBack(
	DRAW_WINDOW* window,
	FLOAT_T x,
	FLOAT_T y,
	FLOAT_T pressure,
	BRUSH_CORE *core,
	void* state
)
{
	// 左クリックなら
	if(((GdkEventButton*)state)->button == 1)
	{
		// ブラシの詳細情報にキャスト
		BLEND_BRUSH *brush = (BLEND_BRUSH*)core->brush_data;
		// 更新範囲のイメージ情報
		cairo_surface_t *update_surface;
		cairo_t *update;
		// ブラシの半径と不透明度
		FLOAT_T r, zoom, alpha;
		// 座標の最大値・最小値
		FLOAT_T min_x, min_y, max_x, max_y;
		// ピクセルデータをリセットする座標
		int start_x, start_y;
		// 描画する幅、高さ、一行分のバイト数
		int width, height, stride;
		// 作業レイヤーの一行分のバイト数
		int layer_stride = window->work_layer->stride;
		// 作業レイヤーのピクセル
		uint8 *work_pixel = window->work_layer->pixels;
		// 参照ピクセル
		uint8 *mask;
		uint8 *mask_pixel = window->mask->pixels;
		// 描画位置指定用
		cairo_matrix_t matrix;
		// 一時合成用
		cairo_surface_t *draw_surface;
		int i;	// for文用のカウンタ

		window->work_layer->layer_mode = LAYER_BLEND_NORMAL;

		if(brush->target == BLEND_BRUSH_TARGET_UNDER_LAYER && window->active_layer->prev != NULL)
		{
			(void)memcpy(window->brush_buffer, window->active_layer->prev->pixels, window->pixel_buf_size);
		}
		else
		{
			(void)memcpy(window->brush_buffer, window->mixed_layer->pixels, window->pixel_buf_size);
		}

		if((brush->flags & BRUSH_FLAG_SIZE) == 0)
		{
			r = brush->r;
			zoom = 1;
		}
		else
		{
			r = brush->r * pressure;
			zoom = 1/pressure;
		}

		brush->before_x = x, brush->before_y = y;
		brush->points[0][1] = x, brush->points[0][2] = y;
		brush->points[0][3] = pressure;
		brush->sum_distance = brush->travel = brush->finish_length = 0;
		brush->draw_start = r * brush->out * 0.01 * 4;
		brush->enter_length = r * brush->enter * 0.01 * 4;
		brush->enter_size = r * (1 - brush->enter * 0.01);
		brush->num_point = 0;
		brush->draw_finished = 0;
		brush->ref_point = 1;

		min_x = x - r, max_x = x + r;
		min_y = y - r, max_y = y + r;

		update_surface = cairo_surface_create_for_rectangle(
			window->mask_temp->surface_p, min_x, min_y, r*2+1, r*2+1);
		update = cairo_create(update_surface);

		if(min_x < 0.0)
		{
			min_x = 0.0;
		}
		if(min_y < 0.0)
		{
			min_y = 0.0;
		}
		if(max_x > window->work_layer->width)
		{
			max_x = window->work_layer->width;
		}
		if(max_y > window->work_layer->height)
		{
			max_y = window->work_layer->height;
		}

		window->update.x = (int)min_x, window->update.y = (int)min_y;
		window->update.width = (int)max_x - window->update.x;
		window->update.height = (int)max_y - window->update.y;

		window->flags |= DRAW_WINDOW_UPDATE_PART;

		core->min_x = min_x, core->min_y = min_y;
		core->max_x = max_x, core->max_y = max_y;

		if(brush->enter_length == 0)
		{
			alpha = ((brush->flags & BRUSH_FLAG_FLOW) == 0) ? 1 : pressure;
			start_x = (int)min_x, start_y = (int)min_y;
			width = (int)(max_x - min_x);
			height = (int)(max_y - min_y);
			stride = width*4;

			if(max_x > window->width || max_y > window->height
				|| max_x < 0 || max_y < 0)
			{
				return;
			}

			for(i=0; i<height; i++)
			{
				(void)memset(&window->mask_temp->pixels[
					(i+start_y)*window->mask_temp->stride+start_x*4], 0, stride);
			}

			cairo_set_operator(window->mask_temp->cairo_p, CAIRO_OPERATOR_OVER);

			mask = window->mask_temp->pixels;
			if(window->app->textures.active_texture == 0)
			{
				if((window->flags & DRAW_WINDOW_HAS_SELECTION_AREA) == 0)
				{
					if((window->active_layer->flags & LAYER_LOCK_OPACITY) == 0)
					{
						cairo_matrix_init_scale(&matrix, zoom, zoom);
						cairo_pattern_set_matrix(core->brush_pattern, &matrix);
						cairo_set_source(update, core->brush_pattern);
						cairo_paint_with_alpha(update, alpha);
					}
					else
					{
						cairo_matrix_init_scale(&matrix, zoom, zoom);
						cairo_pattern_set_matrix(core->brush_pattern, &matrix);
						cairo_set_source(core->temp_cairo, core->brush_pattern);
						cairo_paint_with_alpha(core->temp_cairo, alpha);
						cairo_matrix_init_translate(&matrix, 0,0);
						cairo_pattern_set_matrix(core->temp_pattern, &matrix);
						cairo_set_source(update, core->temp_pattern);
						cairo_mask_surface(update,
							window->active_layer->surface_p, - x + r, - y + r);
					}
				}
				else
				{
					if((window->active_layer->flags & LAYER_LOCK_OPACITY) == 0)
					{
						cairo_matrix_init_scale(&matrix, zoom, zoom);
						cairo_pattern_set_matrix(core->brush_pattern, &matrix);
						cairo_set_source(core->temp_cairo, core->brush_pattern);
						cairo_paint_with_alpha(core->temp_cairo, alpha);
						cairo_matrix_init_translate(&matrix, 0, 0);
						cairo_pattern_set_matrix(core->temp_pattern, &matrix);
						cairo_set_source(update, core->temp_pattern);
						cairo_mask_surface(window->mask_temp->cairo_p,
							window->selection->surface_p, - x + r, - y + r);
					}
					else
					{
						cairo_surface_t *temp_surface = cairo_surface_create_for_rectangle(
							window->temp_layer->surface_p, start_x, start_y, r*2+1, r*2+1);
						cairo_t *update_temp = cairo_create(temp_surface);

						cairo_matrix_init_scale(&matrix, zoom, zoom);
						cairo_pattern_set_matrix(core->brush_pattern, &matrix);
						cairo_set_source(core->temp_cairo, core->brush_pattern);
						cairo_paint_with_alpha(core->temp_cairo, alpha);
						cairo_matrix_init_translate(&matrix, 0, 0);
						cairo_pattern_set_matrix(core->temp_pattern, &matrix);
						cairo_set_source(update, core->temp_pattern);

						for(i=0; i<height; i++)
						{
							(void)memset(&window->temp_layer->pixels[
								(i+start_y)*window->temp_layer->stride+start_x*4],
								0, stride
							);
						}

						cairo_mask_surface(update,
							window->selection->surface_p, - x + r, - y + r);
						cairo_set_source_surface(update_temp,
							update_surface, 0, 0);
						cairo_mask_surface(update_temp,
							window->active_layer->surface_p, - x + r, - y + r);

						mask = window->temp_layer->pixels;

						cairo_surface_destroy(temp_surface);
						cairo_destroy(update_temp);
					}
				}
			}
			else
			{
				cairo_surface_t *temp_surface = cairo_surface_create_for_rectangle(
					window->temp_layer->surface_p, min_x, min_y, r*2+1, r*2+1);
				cairo_t *update_temp = cairo_create(temp_surface);

				if((window->flags & DRAW_WINDOW_HAS_SELECTION_AREA) == 0)
				{
					if((window->active_layer->flags & LAYER_LOCK_OPACITY) == 0)
					{
						cairo_matrix_init_scale(&matrix, zoom, zoom);
						cairo_pattern_set_matrix(core->brush_pattern, &matrix);
						cairo_set_source(update, core->brush_pattern);
						cairo_paint_with_alpha(update, alpha);
					}
					else
					{
						cairo_matrix_init_scale(&matrix, zoom, zoom);
						cairo_pattern_set_matrix(core->brush_pattern, &matrix);
						cairo_set_source(core->temp_cairo, core->brush_pattern);
						cairo_paint_with_alpha(core->temp_cairo, alpha);
						cairo_matrix_init_translate(&matrix, 0, 0);
						cairo_pattern_set_matrix(core->temp_pattern, &matrix);
						cairo_set_source(update, core->temp_pattern);
						cairo_mask_surface(update,
							window->active_layer->surface_p, - x + r, - y + r);
					}

					for(i=0; i<height; i++)
					{
						(void)memset(&window->temp_layer->pixels[
							(i+start_y)*window->temp_layer->stride+start_x*4],
							0, stride
						);
					}

					cairo_set_source_surface(update_temp, update_surface, 0, 0);
					cairo_mask_surface(update_temp, window->texture->surface_p, - x + r, - y + r);

					mask = window->temp_layer->pixels;
				}
				else
				{
					if((window->active_layer->flags & LAYER_LOCK_OPACITY) == 0)
					{
						cairo_matrix_init_scale(&matrix, zoom, zoom);
						cairo_pattern_set_matrix(core->brush_pattern, &matrix);
						cairo_set_source(core->temp_cairo, core->brush_pattern);
						cairo_paint_with_alpha(core->temp_cairo, alpha);
						cairo_matrix_init_translate(&matrix, 0, 0);
						cairo_pattern_set_matrix(core->temp_pattern, &matrix);
						cairo_set_source(update, core->temp_pattern);
						cairo_mask_surface(update,
							window->selection->surface_p, - x + r, - y + r);

						for(i=0; i<height; i++)
						{
							(void)memset(&window->temp_layer->pixels[
								(i+start_y)*window->temp_layer->stride+start_x*4],
								0, stride
							);
						}

						cairo_set_source_surface(update_temp, update_surface, 0, 0);
						cairo_mask_surface(update_temp, window->texture->surface_p, - x + r, - y + r);

						mask = window->temp_layer->pixels;
					}
					else
					{
						cairo_matrix_init_scale(&matrix, zoom, zoom);
						cairo_pattern_set_matrix(core->brush_pattern, &matrix);
						cairo_set_source(core->temp_cairo, core->brush_pattern);
						cairo_paint_with_alpha(core->temp_cairo, alpha);
						cairo_matrix_init_translate(&matrix, 0, 0);
						cairo_pattern_set_matrix(core->temp_pattern, &matrix);
						cairo_set_source(update, core->temp_pattern);

						for(i=0; i<height; i++)
						{
							(void)memset(&window->temp_layer->pixels[
								(i+start_y)*window->temp_layer->stride+start_x*4],
								0, stride
							);
						}

						cairo_mask_surface(update,
							window->selection->surface_p, - x + r, - y + r);
						cairo_set_source_surface(update_temp,
							update_surface, 0, 0);
						cairo_mask_surface(update_temp,
							window->active_layer->surface_p, - x + r, - y + r);

						for(i=0; i<height; i++)
						{
							(void)memset(&window->mask_temp->pixels[
								(i+start_y)*window->mask_temp->stride+start_x*4],
								0, stride
							);
						}

						cairo_set_source_surface(update, temp_surface, 0, 0);
						cairo_mask_surface(update, window->texture->surface_p, - x + r, - y + r);
					}
				}

				cairo_surface_destroy(temp_surface);
				cairo_destroy(update_temp);
			}

			cairo_surface_destroy(update_surface);
			cairo_destroy(update);

			if(mask == window->mask_temp->pixels)
			{
				update_surface = cairo_surface_create_for_rectangle(
					window->mask_temp->surface_p, start_x, start_y, width, height);
			}
			else
			{
				update_surface = cairo_surface_create_for_rectangle(
					window->temp_layer->surface_p, start_x, start_y, width, height);
			}
			draw_surface = cairo_image_surface_create_for_data(window->mask->pixels,
				CAIRO_FORMAT_ARGB32, width, height, stride);
			for(i=0; i<height; i++)
			{
				(void)memcpy(&window->mask->pixels[i*stride],
					&window->brush_buffer[(start_y+i)*window->stride+start_x*4], stride);
			}

			update = cairo_create(draw_surface);
			cairo_set_operator(update, window->app->layer_blend_operators[brush->blend_mode]);
			cairo_set_source_surface(update, update_surface, 0, 0);
			cairo_paint(update);

			cairo_destroy(update);
			cairo_surface_destroy(draw_surface);
			cairo_surface_destroy(update_surface);

#ifdef _OPENMP
			if(height <= MINIMUM_PARALLEL_SIZE)
			{
				omp_set_dynamic(FALSE);
				omp_set_num_threads(1);
			}
#pragma omp parallel for firstprivate(width, work_pixel, mask_pixel, layer_stride, start_x, start_y, stride)
#endif
			for(i=0; i<height; i++)
			{
				uint8 *mask_pix = &mask[(start_y+i)*layer_stride+start_x*4+3];
				int j;

				for(j=0; j<width; j++, mask_pix+=4)
				{
					work_pixel[(start_y+i)*layer_stride+(start_x+j)*4] =
						(uint8)((uint32)(((int)mask_pixel[i*stride+j*4]) * *mask_pix >> 8));
					work_pixel[(start_y+i)*layer_stride+(start_x+j)*4+1] =
						(uint8)((uint32)(((int)mask_pixel[i*stride+j*4+1]) * *mask_pix >> 8));
					work_pixel[(start_y+i)*layer_stride+(start_x+j)*4+2] =
						(uint8)((uint32)(((int)mask_pixel[i*stride+j*4+2]) * *mask_pix >> 8));
					work_pixel[(start_y+i)*layer_stride+(start_x+j)*4+3] =
						*mask_pix;
				}
			}
#ifdef _OPENMP
			omp_set_dynamic(TRUE);
			omp_set_num_threads(window->app->max_threads);
#endif
		}	// if(brush->enter_length == 0)
	}	// 左クリックなら
		// if(((GdkEventButton*)state)->button == 1)
}

#define BlendBrushEditSelectionButtonPressCallBack BlendBrushButtonPressCallBack

static void BlendBrushMotionCallBack(
	DRAW_WINDOW* window,
	FLOAT_T x,
	FLOAT_T y,
	FLOAT_T pressure,
	BRUSH_CORE *core,
	void* state
)
{
	// マウスの左ボタンが押されていたら
	if(((*(GdkModifierType*)state) & GDK_BUTTON1_MASK) != 0)
	{
		// ブラシの詳細情報にキャスト
		BLEND_BRUSH *brush = (BLEND_BRUSH*)core->brush_data;
		FLOAT_T distance;
		int index = brush->ref_point % BRUSH_POINT_BUFFER_SIZE;

		distance = sqrt((x-brush->before_x)*(x-brush->before_x)
			+(y-brush->before_y)*(y-brush->before_y));

		if(distance >= 1.0)
		{
			brush->before_x = x, brush->before_y = y;
			brush->sum_distance += distance;
			brush->travel += distance;
			brush->points[index][0] = distance;
			brush->points[index][1] = x, brush->points[index][2] = y;
			brush->points[index][3] = pressure;
			brush->ref_point++;

			if(brush->sum_distance >= brush->draw_start
				&& brush->sum_distance >= brush->enter_length)
			{
				// 更新範囲のイメージ情報
				cairo_surface_t *update_surface;
				cairo_t *update;
				// ブラシの筆圧による縮小用
				FLOAT_T zoom;
				// 入りの色補正用
				FLOAT_T enter_alpha;
				// ブラシの半径と不透明度
				FLOAT_T r, alpha;
				// 座標の最大・最小値
				FLOAT_T min_x, min_y, max_x, max_y;
				// X、Y方向の移動量
				FLOAT_T dx, dy;
				// ブラシの傾き用
				FLOAT_T diff_x, diff_y;
				// ブラシの移動量
				FLOAT_T d, step;
				// 描画を行う座標
				FLOAT_T draw_x = brush->before_x, draw_y = brush->before_y;
				// 描画座標指定用
				cairo_matrix_t matrix;
				// 一時合成用
				cairo_surface_t *draw_surface;
				// ピクセルデータをリセットする座標
				int start_x, start_y;
				// 描画する幅、高さ、一行分のバイト数
				int width, height, stride;
				// 作業レイヤーの一行分のバイト数
				int layer_stride = window->work_layer->stride;
				// 作業レイヤーのピクセル
				uint8 *work_pixel = window->work_layer->pixels;
				// 参照ピクセル
				uint8 *mask;
				uint8 *mask_pixel = window->mask->pixels;
				// 配列のインデックス用
				int ref_point = brush->draw_finished % BRUSH_POINT_BUFFER_SIZE;
				int before_point;
				int i;	// for文用のカウンタ

				while(brush->sum_distance > brush->draw_start
					&& brush->draw_finished < brush->ref_point)
				{
					if(brush->finish_length < brush->enter_length)
					{
						enter_alpha = brush->finish_length / brush->enter_length;
						r = brush->enter_size + brush->finish_length * 0.25;
					}
					else
					{
						zoom = enter_alpha = 1, r = brush->r;
					}
					
					if((brush->flags & BRUSH_FLAG_SIZE) != 0)
					{
						r *= brush->points[ref_point][3];
					}

					
					alpha = ((brush->flags & BRUSH_FLAG_FLOW) == 0)
						? 1 : brush->points[ref_point][3];
					alpha *= enter_alpha;
					before_point = (ref_point == 0) ? BRUSH_POINT_BUFFER_SIZE - 1 : ref_point - 1;
					d = brush->points[ref_point][0];
					brush->sum_distance -= d;

					if(r > MIN_BRUSH_STEP)
					{
						zoom = brush->r / r;
						step = r * BRUSH_STEP;
						if(step < 0.5)
						{
							step = 0.5;
						}

						if(brush->draw_finished == 0)
						{
							draw_x = brush->points[0][1], draw_y = brush->points[0][2];
						}
						else
						{
							draw_x = brush->points[before_point][1];
							draw_y = brush->points[before_point][2];
						}
						dx = brush->points[ref_point][1] - draw_x;
						dy = brush->points[ref_point][2] - draw_y;
						diff_x = step*dx/d, diff_y = step*dy/d;

						min_x = brush->points[ref_point][1] - r - 1;
						max_x = brush->points[ref_point][1] + r + 1;
						min_y = brush->points[ref_point][2] - r - 1;
						max_y = brush->points[ref_point][2] + r + 1;

						if(min_x < 0.0)
						{
							min_x = 0.0;
						}
						if(core->min_x > min_x)
						{
							core->min_x = min_x;
						}
						if(min_y < 0.0)
						{
							min_y = 0.0;
						}
						if(core->min_y > min_y)
						{
							core->min_y = min_y;
						}
						if(max_x > window->work_layer->width)
						{
							max_x = window->work_layer->width;
						}
						if(core->max_x < max_x)
						{
							core->max_x = max_x;
						}
						if(max_y > window->work_layer->height)
						{
							min_y = window->work_layer->height;
						}
						if(core->max_y < max_y)
						{
							core->max_y = max_y;
						}

						if(window->update.x > min_x)
						{
							window->update.width += window->update.x - (int)min_x;
							window->update.x = (int)min_x;
						}
						if(window->update.width + window->update.x < max_x)
						{
							window->update.width += (int)max_x - window->update.width + window->update.x;
						}
						if(window->update.y > min_y)
						{
							window->update.height += window->update.y - (int)min_y;
							window->update.y = (int)min_y;
						}
						if(window->update.height + window->update.y < max_y)
						{
							window->update.height += (int)max_y - window->update.height + window->update.y;
						}

						dx = d;
						do
						{
							start_x = (int)(draw_x - r);
							start_y = (int)(draw_y - r);
							width = (int)(draw_x + r);
							height = (int)(draw_y + r);

							if(start_x < 0)
							{
								start_x = 0;
							}
							else if(start_x > window->work_layer->width)
							{
								goto skip_draw;
							}
							if(start_y < 0)
							{
								start_y = 0;
							}
							else if(start_y > window->work_layer->height)
							{
								goto skip_draw;
							}
							if(width > window->work_layer->width)
							{
								width = window->work_layer->width - start_x;
							}
							else
							{
								width = width - start_x;
							}
							if(height > window->work_layer->height)
							{
								height = window->work_layer->height - start_y;
							}
							else
							{
								height = height - start_y;
							}
							stride = width*4;

							if(width <= 0 || height <= 0)
							{
								goto skip_draw;
							}

							update_surface = cairo_surface_create_for_rectangle(
								window->mask_temp->surface_p, draw_x - r, draw_y - r,
									r*2+1, r*2+1);
							update = cairo_create(update_surface);

							window->flags |= DRAW_WINDOW_UPDATE_PART;

							for(i=0; i<height; i++)
							{
								(void)memset(&window->mask_temp->pixels[(i+start_y)*window->mask_temp->stride+start_x*4],
									0, stride);
							}

							cairo_set_operator(window->mask_temp->cairo_p, CAIRO_OPERATOR_OVER);

							mask = window->mask_temp->pixels;
							if(window->app->textures.active_texture == 0)
							{
								if((window->flags & DRAW_WINDOW_HAS_SELECTION_AREA) == 0)
								{
									if((window->active_layer->flags & LAYER_LOCK_OPACITY) == 0)
									{
										cairo_matrix_init_scale(&matrix, zoom, zoom);
										cairo_pattern_set_matrix(core->brush_pattern, &matrix);
										cairo_set_source(update, core->brush_pattern);
										cairo_paint_with_alpha(update, alpha);
									}
									else
									{
										cairo_matrix_init_scale(&matrix, zoom, zoom);
										cairo_pattern_set_matrix(core->brush_pattern, &matrix);
										cairo_set_source(core->temp_cairo, core->brush_pattern);
										cairo_paint_with_alpha(core->temp_cairo, alpha);
										cairo_matrix_init_translate(&matrix, 0, 0);
										cairo_pattern_set_matrix(core->temp_pattern, &matrix);
										cairo_set_source(update, core->temp_pattern);
										cairo_mask_surface(update,
											window->active_layer->surface_p, - draw_x + r, - draw_y + r);
									}
								}
								else
								{
									if((window->active_layer->flags & LAYER_LOCK_OPACITY) == 0)
									{
										cairo_matrix_init_scale(&matrix, zoom, zoom);
										cairo_pattern_set_matrix(core->brush_pattern, &matrix);
										cairo_set_source(core->temp_cairo, core->brush_pattern);
										cairo_paint_with_alpha(core->temp_cairo, alpha);
										cairo_matrix_init_translate(&matrix, 0, 0);
										cairo_pattern_set_matrix(core->temp_pattern, &matrix);
										cairo_set_source(update, core->temp_pattern);
										cairo_mask_surface(update,
											window->selection->surface_p, - draw_x + r, - draw_y + r);
									}
									else
									{
										cairo_surface_t *temp_surface = cairo_surface_create_for_rectangle(
											window->temp_layer->surface_p, start_x, start_y, r*2+1, r*2+1);
										cairo_t *update_temp = cairo_create(temp_surface);

										cairo_matrix_init_scale(&matrix, zoom, zoom);
										cairo_pattern_set_matrix(core->brush_pattern, &matrix);
										cairo_set_source(core->temp_cairo, core->brush_pattern);
										cairo_paint_with_alpha(core->temp_cairo, alpha);
										cairo_matrix_init_translate(&matrix, 0, 0);
										cairo_pattern_set_matrix(core->temp_pattern, &matrix);
										cairo_set_source(update, core->temp_pattern);

										for(i=0; i<height; i++)
										{
											(void)memset(&window->temp_layer->pixels[
												(i+start_y)*window->temp_layer->stride+start_x*4],
												0, stride
											);
										}

										cairo_mask_surface(update,
											window->selection->surface_p, - draw_x + r, - draw_y + r);
										cairo_set_source_surface(update_temp,
											update_surface, 0, 0);
										cairo_mask_surface(update_temp,
											window->active_layer->surface_p, - draw_x + r, - draw_y + r);
	
										mask = window->temp_layer->pixels;

										cairo_surface_destroy(temp_surface);
										cairo_destroy(update_temp);
									}
								}
							}
							else
							{
								cairo_surface_t *temp_surface = cairo_surface_create_for_rectangle(
									window->temp_layer->surface_p, start_x, start_y, r*2+1, r*2+1);
								cairo_t *update_temp = cairo_create(temp_surface);

								if((window->flags & DRAW_WINDOW_HAS_SELECTION_AREA) == 0)
								{
									if((window->active_layer->flags & LAYER_LOCK_OPACITY) == 0)
									{
										cairo_matrix_init_scale(&matrix, zoom, zoom);
										cairo_pattern_set_matrix(core->brush_pattern, &matrix);
										cairo_set_source(update, core->brush_pattern);
										cairo_paint_with_alpha(update, alpha);
									}
									else
									{
										cairo_matrix_init_scale(&matrix, zoom, zoom);
										cairo_pattern_set_matrix(core->brush_pattern, &matrix);
										cairo_set_source(core->temp_cairo, core->brush_pattern);
										cairo_paint_with_alpha(core->temp_cairo, alpha);
										cairo_matrix_init_translate(&matrix, 0, 0);
										cairo_pattern_set_matrix(core->temp_pattern, &matrix);
										cairo_set_source(update, core->temp_pattern);
										cairo_mask_surface(update,
											window->active_layer->surface_p, - draw_x + r, - draw_y + r);
									}

									for(i=0; i<height; i++)
									{
										(void)memset(&window->temp_layer->pixels[
											(i+start_y)*window->temp_layer->stride+start_x*4],
											0, stride
										);
									}

									cairo_set_source_surface(update_temp, update_surface, 0, 0);
									cairo_mask_surface(update_temp, window->texture->surface_p, - draw_x + r, - draw_y + r);

									mask = window->temp_layer->pixels;
								}
								else
								{
									if((window->active_layer->flags & LAYER_LOCK_OPACITY) == 0)
									{
										cairo_matrix_init_scale(&matrix, zoom, zoom);
										cairo_pattern_set_matrix(core->brush_pattern, &matrix);
										cairo_set_source(core->temp_cairo, core->brush_pattern);
										cairo_paint_with_alpha(core->temp_cairo, alpha);
										cairo_matrix_init_translate(&matrix, 0, 0);
										cairo_pattern_set_matrix(core->temp_pattern, &matrix);
										cairo_set_source(update, core->temp_pattern);
										cairo_mask_surface(update,
											window->selection->surface_p, - draw_x + r, - draw_y + r);

										for(i=0; i<height; i++)
										{
											(void)memset(&window->temp_layer->pixels[
												(i+start_y)*window->temp_layer->stride+start_x*4],
												0, stride
											);
										}

										cairo_set_source_surface(update_temp, update_surface, 0, 0);
										cairo_mask_surface(update_temp, window->texture->surface_p, - draw_x + r, - draw_y + r);

										mask = window->temp_layer->pixels;
									}
									else
									{
										cairo_matrix_init_scale(&matrix, zoom, zoom);
										cairo_pattern_set_matrix(core->brush_pattern, &matrix);
										cairo_set_source(core->temp_cairo, core->brush_pattern);
										cairo_paint_with_alpha(core->temp_cairo, alpha);
										cairo_matrix_init_translate(&matrix, 0, 0);
										cairo_pattern_set_matrix(core->temp_pattern, &matrix);
										cairo_set_source(update, core->temp_pattern);

										for(i=0; i<height; i++)
										{
											(void)memset(&window->temp_layer->pixels[
												(i+start_y)*window->temp_layer->stride+start_x*4],
												0, stride
											);
										}

										cairo_mask_surface(update,
											window->selection->surface_p, - draw_x + r, - draw_y + r);
										cairo_set_source_surface(update_temp,
											update_surface, 0, 0);
										cairo_mask_surface(update_temp,
											window->active_layer->surface_p, - draw_x + r, - draw_y + r);
	
										for(i=0; i<height; i++)
										{
											(void)memset(&window->mask_temp->pixels[
												(i+start_y)*window->mask_temp->stride+start_x*4],
												0, stride
											);
										}

										cairo_set_source_surface(update, temp_surface, 0, 0);
										cairo_mask_surface(update, window->texture->surface_p, - draw_x + r, - draw_y + r);
									}
								}

								cairo_surface_destroy(temp_surface);
								cairo_destroy(update_temp);
							}

							cairo_surface_destroy(update_surface);
							cairo_destroy(update);

							if(mask == window->mask_temp->pixels)
							{
								update_surface = cairo_surface_create_for_rectangle(
									window->mask_temp->surface_p, start_x, start_y, width, height);
							}
							else
							{
								update_surface = cairo_surface_create_for_rectangle(
									window->temp_layer->surface_p, start_x, start_y, width, height);
							}
							draw_surface = cairo_image_surface_create_for_data(window->mask->pixels,
								CAIRO_FORMAT_ARGB32, width, height, stride);
							for(i=0; i<height; i++)
							{
								(void)memcpy(&window->mask->pixels[i*stride],
									&window->brush_buffer[(start_y+i)*window->stride+start_x*4], stride);
							}

							update = cairo_create(draw_surface);
							cairo_set_operator(update, window->app->layer_blend_operators[brush->blend_mode]);
							cairo_set_source_surface(update, update_surface, 0, 0);
							cairo_paint(update);

							cairo_destroy(update);
							cairo_surface_destroy(draw_surface);
							cairo_surface_destroy(update_surface);

#ifdef _OPENMP
							if(height <= MINIMUM_PARALLEL_SIZE)
							{
								omp_set_dynamic(FALSE);
								omp_set_num_threads(1);
							}
#pragma omp parallel for firstprivate(width, work_pixel, mask_pixel, layer_stride, start_x, start_y)
#endif
							for(i=0; i<height; i++)
							{
								uint8 *ref_pix = &work_pixel[
									(start_y+i)*layer_stride+start_x*4];
								uint8 *mask_pix = &mask_pixel[i*stride];
								uint8 *alpha_pix = &mask[(start_y+i)*layer_stride
									+start_x*4+3];
								uint8 draw_value;
								int j;

								for(j=0; j<width; j++, ref_pix+=4, mask_pix+=4, alpha_pix+=4)
								{
									if(ref_pix[3] < *alpha_pix)
									{
										draw_value = (uint8)((uint32)(((int)mask_pix[0]) * *alpha_pix >> 8));
										if(draw_value > ref_pix[0])
										{
											ref_pix[0] = (uint8)((uint32)(((int)draw_value-(int)ref_pix[0])
												* *alpha_pix >> 8) + ref_pix[0]);
										}
										draw_value = (uint8)((uint32)(((int)mask_pix[1]) * *alpha_pix >> 8));
										if(draw_value > ref_pix[1])
										{
											ref_pix[1] = (uint8)((uint32)(((int)draw_value-(int)ref_pix[1])
												* *alpha_pix >> 8) + ref_pix[1]);
										}
										draw_value = (uint8)((uint32)(((int)mask_pix[2]) * *alpha_pix >> 8));
										if(draw_value > ref_pix[2])
										{
											ref_pix[2] = (uint8)((uint32)(((int)draw_value-(int)ref_pix[2])
												* *alpha_pix >> 8) + ref_pix[2]);
										}
										ref_pix[3] = (uint8)((uint32)(((int)*alpha_pix-(int)ref_pix[3])
											* *alpha_pix >> 8) + ref_pix[3]);
									}
								}
							}
#ifdef _OPENMP
							omp_set_dynamic(TRUE);
							omp_set_num_threads(window->app->max_threads);
#endif
							// アンチエイリアスを適用
							if((brush->flags & BRUSH_FLAG_ANTI_ALIAS) != 0)
							{
								ANTI_ALIAS_RECTANGLE range = {start_x - 1, start_y - 1,
									width + 1, height + 1};
								AntiAliasLayer(window->work_layer, window->temp_layer, &range);
							}
skip_draw:
							dx -= step;
							if(dx < 1)
							{
								break;
							}
							else if(dx >= step)
							{
								draw_x += diff_x, draw_y += diff_y;
							}
							else
							{
								draw_x = brush->points[ref_point][1];
								draw_y = brush->points[ref_point][2];
							}
						} while(1);
					}

					brush->finish_length += d;
					brush->travel += d;
					brush->draw_finished++;
					ref_point = brush->draw_finished % BRUSH_POINT_BUFFER_SIZE;
				}	// while(brush->sum_distance > brush->draw_start
						// && brush->draw_finished < brush->ref_point)
			}	// if(brush->sum_distance >= brush->draw_start
					// && brush->sum_distance >= brush->enter_length)
		}	// if(distance >= 1.0)
	}	// マウスの左ボタンが押されていたら
		// if(((*(GdkModifierType*)state) & GDK_BUTTON1_MASK) != 0)
}

#define BlendBrushEditSelectionMotionCallBack BlendBrushMotionCallBack

static void BlendBrushButtonReleaseCallBack(
	DRAW_WINDOW* window,
	FLOAT_T x,
	FLOAT_T y,
	FLOAT_T pressure,
	BRUSH_CORE *core,
	void* state
)
{
	// マウスの左ボタンなら
	if(((GdkEventButton*)state)->button == 1)
	{
		// ブラシの詳細情報にキャスト
		BLEND_BRUSH *brush = (BLEND_BRUSH*)core->brush_data;
		// 更新範囲のイメージ情報
		cairo_surface_t *update_surface;
		cairo_t *update;
		// ブラシの縮小率
		FLOAT_T zoom;
		// ブラシの半径と不透明度
		FLOAT_T r, alpha;
		// 座標の最大・最小値
		FLOAT_T min_x, min_y, max_x, max_y;
		// X、Y方向の移動量
		FLOAT_T dx, dy;
		// ブラシの傾き用
		FLOAT_T diff_x, diff_y;
		// ブラシの移動量
		FLOAT_T d = MIN_BRUSH_STEP, step;
		// 描画を行う座標
		FLOAT_T draw_x, draw_y;
		// 入り、抜き時の色補正
		FLOAT_T enter_alpha, out_alpha;
		// ピクセルデータをリセットする座標
		int start_x, start_y;
		// 描画する幅、高さ、一行分のバイト数
		int width, height, stride;
		// 作業レイヤーの一行分のバイト数
		int layer_stride = window->work_layer->stride;
		// 作業レイヤーのピクセル
		uint8 *work_pixel = window->work_layer->pixels;
		// 描画座標指定用
		cairo_matrix_t matrix;
		// 一時合成用
		cairo_surface_t *draw_surface;
		// 参照ピクセル
		uint8 *mask;
		uint8 *mask_pixel = window->mask->pixels;
		// 配列のインデックス用
		int ref_point;
		int before_point;
		int i;	// for文用のカウンタ

		while(brush->ref_point > brush->draw_finished)
		{
			ref_point = brush->draw_finished % BRUSH_POINT_BUFFER_SIZE;

			if(brush->finish_length < brush->enter_length)
			{
				enter_alpha = brush->finish_length / brush->enter_length;
				r = brush->enter_size + brush->finish_length * 0.25;
			}
			else
			{
				enter_alpha = 1;
				r = brush->r;
			}
			if(brush->sum_distance < brush->draw_start)
			{
				out_alpha = brush->sum_distance / brush->draw_start;
				r -= (brush->draw_start - brush->sum_distance) * 0.25;
			}
			else
			{
				out_alpha = 1;
			}

			if(r < 0.0)
			{
				brush->draw_finished++;
				continue;
			}

			if((brush->flags & BRUSH_FLAG_SIZE) != 0)
			{
				r *= brush->points[ref_point][3];
			}
			alpha = ((brush->flags & BRUSH_FLAG_FLOW) == 0)
				? 1 : brush->points[ref_point][3];
			alpha *= enter_alpha * out_alpha;
			before_point = (ref_point == 0) ? BRUSH_POINT_BUFFER_SIZE - 1 : ref_point - 1;
			if(r > MIN_BRUSH_STEP)
			{
				d = brush->points[ref_point][0];
				brush->sum_distance -= d;
				step = r * BRUSH_STEP;
				zoom = brush->r / r;

				if(step < 0.5)
				{
					step = 0.5;
				}
				if(brush->draw_finished == 0)
				{
					draw_x = brush->points[0][1], draw_y = brush->points[0][2];
				}
				else
				{
					draw_x = brush->points[before_point][1], draw_y = brush->points[before_point][2];
				}
				dx = brush->points[ref_point][1] - draw_x;
				dy = brush->points[ref_point][2] - draw_y;
				diff_x = step * dx / d, diff_y = step * dy / d;

				min_x = brush->points[ref_point][1] - r - 1;
				max_x = brush->points[ref_point][1] + r + 1;
				min_y = brush->points[ref_point][2] - r - 1;
				max_y = brush->points[ref_point][2] + r + 1;
				if(min_x < 0.0)
				{
					min_x = 0.0;
				}
				if(core->min_x > min_x)
				{
					core->min_x = min_x;
				}
				if(min_y < 0.0)
				{
					min_y = 0.0;
				}
				if(core->min_y > min_y)
				{
					core->min_y = min_y;
				}
				if(max_x > window->work_layer->width)
				{
					max_x = window->work_layer->width;
				}
				if(core->max_x < max_x)
				{
					core->max_x = max_x;
				}
				if(max_y > window->work_layer->height)
				{
					min_y = window->work_layer->height;
				}
				if(core->max_y < max_y)
				{
					core->max_y = max_y;
				}

				dx = d;
				do
				{
					start_x = (int)(draw_x - r);
					start_y = (int)(draw_y - r);
					width = (int)(draw_x + r);
					height = (int)(draw_y + r);

					if(start_x < 0)
					{
						start_x = 0;
					}
					else if(start_x > window->work_layer->width)
					{
						goto skip_draw;
					}
					if(start_y < 0)
					{
						start_y = 0;
					}
					else if(start_y > window->work_layer->height)
					{
						goto skip_draw;
					}
					if(width > window->work_layer->width)
					{
						width = window->work_layer->width - start_x;
					}
					else
					{
						width = width - start_x;
					}
					if(height > window->work_layer->height)
					{
						height = window->work_layer->height - start_y;
					}
					else
					{
						height = height - start_y;
					}
					stride = width*4;

					if(width <= 0 || height <= 0)
					{
						goto skip_draw;
					}

					update_surface = cairo_surface_create_for_rectangle(
						window->mask_temp->surface_p, draw_x - r, draw_y - r,
							r*2+1, r*2+1);
					update = cairo_create(update_surface);

					if(window->update.x > min_x)
					{
						window->update.width += window->update.x - (int)min_x;
						window->update.x = (int)min_x;
					}
					if(window->update.width + window->update.x < max_x)
					{
						window->update.width += (int)max_x - window->update.width + window->update.x;
					}
					if(window->update.y > min_y)
					{
						window->update.height += window->update.y - (int)min_y;
						window->update.y = (int)min_y;
					}
					if(window->update.height + window->update.y < max_y)
					{
						window->update.height += (int)max_y - window->update.height + window->update.y;
					}

					for(i=0; i<height; i++)
					{
						(void)memset(&window->mask_temp->pixels[(i+start_y)*window->mask_temp->stride+start_x*4],
							0, stride);
					}

					cairo_set_operator(window->mask_temp->cairo_p, CAIRO_OPERATOR_OVER);

					mask = window->mask_temp->pixels;
					if(window->app->textures.active_texture == 0)
					{
						if((window->flags & DRAW_WINDOW_HAS_SELECTION_AREA) == 0)
						{
							if((window->active_layer->flags & LAYER_LOCK_OPACITY) == 0)
							{
								cairo_matrix_init_scale(&matrix, zoom, zoom);
								cairo_pattern_set_matrix(core->brush_pattern, &matrix);
								cairo_set_source(update, core->brush_pattern);
								cairo_paint_with_alpha(update, alpha);
							}
							else
							{
								cairo_matrix_init_scale(&matrix, zoom, zoom);
								cairo_pattern_set_matrix(core->brush_pattern, &matrix);
								cairo_set_source(core->temp_cairo, core->brush_pattern);
								cairo_paint_with_alpha(core->temp_cairo, alpha);
								cairo_matrix_init_translate(&matrix, 0, 0);
								cairo_pattern_set_matrix(core->temp_pattern, &matrix);
								cairo_set_source(update, core->temp_pattern);
								cairo_mask_surface(update,
									window->active_layer->surface_p, - draw_x + r, - draw_y + r);
							}
						}
						else
						{
							if((window->active_layer->flags & LAYER_LOCK_OPACITY) == 0)
							{
								cairo_matrix_init_scale(&matrix, zoom, zoom);
								cairo_pattern_set_matrix(core->brush_pattern, &matrix);
								cairo_set_source(core->temp_cairo, core->brush_pattern);
								cairo_paint_with_alpha(core->temp_cairo, alpha);
								cairo_matrix_init_translate(&matrix, 0, 0);
								cairo_pattern_set_matrix(core->temp_pattern, &matrix);
								cairo_set_source(update, core->temp_pattern);
								cairo_mask_surface(update,
									window->selection->surface_p, - draw_x + r, - draw_y + r);
							}
							else
							{
								cairo_surface_t *temp_surface = cairo_surface_create_for_rectangle(
									window->temp_layer->surface_p, start_x, start_y, r*2+1, r*2+1);
								cairo_t *update_temp = cairo_create(temp_surface);

								cairo_matrix_init_scale(&matrix, zoom, zoom);
								cairo_pattern_set_matrix(core->brush_pattern, &matrix);
								cairo_set_source(core->temp_cairo, core->brush_pattern);
								cairo_paint_with_alpha(core->temp_cairo, alpha);
								cairo_matrix_init_translate(&matrix, 0, 0);
								cairo_pattern_set_matrix(core->temp_pattern, &matrix);
								cairo_set_source(update, core->temp_pattern);

								for(i=0; i<height; i++)
								{
									(void)memset(&window->temp_layer->pixels[
										(i+start_y)*window->temp_layer->stride+start_x*4],
										0, stride
									);
								}

								cairo_mask_surface(update,
									window->selection->surface_p, - draw_x + r, - draw_y + r);
								cairo_set_source_surface(update_temp,
									update_surface, 0, 0);
								cairo_mask_surface(update_temp,
									window->active_layer->surface_p, - draw_x + r, - draw_y + r);
	
								mask = window->temp_layer->pixels;

								cairo_surface_destroy(temp_surface);
								cairo_destroy(update_temp);
							}
						}
					}
					else
					{
						cairo_surface_t *temp_surface = cairo_surface_create_for_rectangle(
							window->temp_layer->surface_p, start_x, start_y, r*2+1, r*2+1);
						cairo_t *update_temp = cairo_create(temp_surface);

						if((window->flags & DRAW_WINDOW_HAS_SELECTION_AREA) == 0)
						{
							if((window->active_layer->flags & LAYER_LOCK_OPACITY) == 0)
							{
								cairo_matrix_init_scale(&matrix, zoom, zoom);
								cairo_pattern_set_matrix(core->brush_pattern, &matrix);
								cairo_set_source(update, core->brush_pattern);
								cairo_paint_with_alpha(update, alpha);
							}
							else
							{
								cairo_matrix_init_scale(&matrix, zoom, zoom);
								cairo_pattern_set_matrix(core->brush_pattern, &matrix);
								cairo_set_source(core->temp_cairo, core->brush_pattern);
								cairo_paint_with_alpha(core->temp_cairo, alpha);
								cairo_matrix_init_translate(&matrix, 0, 0);
								cairo_pattern_set_matrix(core->temp_pattern, &matrix);
								cairo_set_source(update, core->temp_pattern);
								cairo_mask_surface(update,
									window->active_layer->surface_p, - draw_x + r, - draw_y + r);
							}

							for(i=0; i<height; i++)
							{
								(void)memset(&window->temp_layer->pixels[
									(i+start_y)*window->temp_layer->stride+start_x*4],
									0, stride
								);
							}

							cairo_set_source_surface(update_temp, update_surface, 0, 0);
							cairo_mask_surface(update_temp, window->texture->surface_p, - draw_x + r, - draw_y + r);

							mask = window->temp_layer->pixels;
						}
						else
						{
							if((window->active_layer->flags & LAYER_LOCK_OPACITY) == 0)
							{
								cairo_matrix_init_scale(&matrix, zoom, zoom);
								cairo_pattern_set_matrix(core->brush_pattern, &matrix);
								cairo_set_source(core->temp_cairo, core->brush_pattern);
								cairo_paint_with_alpha(core->temp_cairo, alpha);
								cairo_matrix_init_translate(&matrix, 0, 0);
								cairo_pattern_set_matrix(core->temp_pattern, &matrix);
								cairo_set_source(update, core->temp_pattern);
								cairo_mask_surface(update,
									window->selection->surface_p, - draw_x + r, - draw_y + r);

								for(i=0; i<height; i++)
								{
									(void)memset(&window->temp_layer->pixels[
										(i+start_y)*window->temp_layer->stride+start_x*4],
										0, stride
									);
								}

								cairo_set_source_surface(update_temp, update_surface, 0, 0);
								cairo_mask_surface(update_temp, window->texture->surface_p, - draw_x + r, - draw_y + r);

								mask = window->temp_layer->pixels;
							}
							else
							{
								cairo_matrix_init_scale(&matrix, zoom, zoom);
								cairo_pattern_set_matrix(core->brush_pattern, &matrix);
								cairo_set_source(core->temp_cairo, core->brush_pattern);
								cairo_paint_with_alpha(core->temp_cairo, alpha);
								cairo_matrix_init_translate(&matrix, 0, 0);
								cairo_pattern_set_matrix(core->temp_pattern, &matrix);
								cairo_set_source(update, core->temp_pattern);

								for(i=0; i<height; i++)
								{
									(void)memset(&window->temp_layer->pixels[
										(i+start_y)*window->temp_layer->stride+start_x*4],
										0, stride
									);
								}

								cairo_mask_surface(update,
									window->selection->surface_p, - draw_x + r, - draw_y + r);
								cairo_set_source_surface(update_temp,
									update_surface, 0, 0);
								cairo_mask_surface(update_temp,
									window->active_layer->surface_p, - draw_x + r, - draw_y + r);
	
								for(i=0; i<height; i++)
								{
									(void)memset(&window->mask_temp->pixels[
										(i+start_y)*window->mask_temp->stride+start_x*4],
										0, stride
									);
								}

								cairo_set_source_surface(update, temp_surface, 0, 0);
								cairo_mask_surface(update, window->texture->surface_p, - draw_x + r, - draw_y + r);
							}
						}

						cairo_surface_destroy(temp_surface);
						cairo_destroy(update_temp);
					}

					cairo_surface_destroy(update_surface);
					cairo_destroy(update);

					if(mask == window->mask_temp->pixels)
					{
						update_surface = cairo_surface_create_for_rectangle(
							window->mask_temp->surface_p, start_x, start_y, width, height);
					}
					else
					{
						update_surface = cairo_surface_create_for_rectangle(
							window->temp_layer->surface_p, start_x, start_y, width, height);
					}
					draw_surface = cairo_image_surface_create_for_data(window->mask->pixels,
						CAIRO_FORMAT_ARGB32, width, height, stride);
					for(i=0; i<height; i++)
					{
						(void)memcpy(&window->mask->pixels[i*stride],
							&window->brush_buffer[(start_y+i)*window->stride+start_x*4], stride);
					}

					update = cairo_create(draw_surface);
					cairo_set_operator(update, window->app->layer_blend_operators[brush->blend_mode]);
					cairo_set_source_surface(update, update_surface, 0, 0);
					cairo_paint(update);

					cairo_destroy(update);
					cairo_surface_destroy(draw_surface);
					cairo_surface_destroy(update_surface);

#ifdef _OPENMP
					if(height <= MINIMUM_PARALLEL_SIZE)
					{
						omp_set_dynamic(FALSE);
						omp_set_num_threads(1);
					}
#pragma omp parallel for firstprivate(width, work_pixel, mask_pixel, layer_stride, start_x, start_y)
#endif
					for(i=0; i<height; i++)
					{
						uint8 *ref_pix = &work_pixel[
							(start_y+i)*layer_stride+start_x*4];
						uint8 *mask_pix = &mask_pixel[i*stride];
						uint8 *alpha_pix = &mask[(start_y+i)*layer_stride
							+start_x*4+3];
						uint8 draw_value;
						int j;

						for(j=0; j<width; j++, ref_pix+=4, mask_pix+=4, alpha_pix+=4)
						{
							if(ref_pix[3] < *alpha_pix)
							{
								draw_value = (uint8)((uint32)(((int)mask_pix[0]) * *alpha_pix >> 8));
								if(draw_value > ref_pix[0])
								{
									ref_pix[0] = (uint8)((uint32)(((int)draw_value-(int)ref_pix[0])
										* *alpha_pix >> 8) + ref_pix[0]);
								}
								draw_value = (uint8)((uint32)(((int)mask_pix[1]) * *alpha_pix >> 8));
								if(draw_value > ref_pix[1])
								{
									ref_pix[1] = (uint8)((uint32)(((int)draw_value-(int)ref_pix[1])
										* *alpha_pix >> 8) + ref_pix[1]);
								}
								draw_value = (uint8)((uint32)(((int)mask_pix[2]) * *alpha_pix >> 8));
								if(draw_value > ref_pix[2])
								{
									ref_pix[2] = (uint8)((uint32)(((int)draw_value-(int)ref_pix[2])
										* *alpha_pix >> 8) + ref_pix[2]);
								}
								ref_pix[3] = (uint8)((uint32)(((int)*alpha_pix-(int)ref_pix[3])
									* *alpha_pix >> 8) + ref_pix[3]);
							}
						}
					}
#ifdef _OPENMP
					omp_set_dynamic(TRUE);
					omp_set_num_threads(window->app->max_threads);
#endif

					// アンチエイリアスを適用
					if((brush->flags & BRUSH_FLAG_ANTI_ALIAS) != 0)
					{
						ANTI_ALIAS_RECTANGLE range = {start_x - 1, start_y - 1,
							width + 1, height + 1};
						AntiAliasLayer(window->work_layer, window->temp_layer, &range);
					}
skip_draw:
					dx -= step;
					if(dx < 1)
					{
						break;
					}
					else if(dx >= step)
					{
						draw_x += diff_x, draw_y += diff_y;
					}
					else
					{
						draw_x = brush->points[ref_point][1];
						draw_y = brush->points[ref_point][2];
					}
				} while(1);
			}

			brush->finish_length += d;
			brush->travel += d;
			brush->draw_finished++;
			ref_point = brush->draw_finished % BRUSH_POINT_BUFFER_SIZE;
		}	// while(brush->ref_point > brush->draw_finished)

		AddBrushHistory(core, window->active_layer);

		window->update.surface_p = cairo_surface_create_for_rectangle(
			window->active_layer->surface_p, window->update.x, window->update.y,
				window->update.width, window->update.height);
		window->update.cairo_p = cairo_create(window->update.surface_p);
		window->part_layer_blend_functions[window->work_layer->layer_mode](window->work_layer, &window->update);
		cairo_surface_destroy(window->update.surface_p);
		cairo_destroy(window->update.cairo_p);

		(void)memset(window->work_layer->pixels, 0, window->work_layer->stride*window->work_layer->height);

		window->work_layer->layer_mode = LAYER_BLEND_NORMAL;
		window->flags |= DRAW_WINDOW_UPDATE_PART;
	}	// マウスの左ボタンなら
		// if(((GdkEventButton*)state)->button == 1)
}

static void BlendBrushEditSelectionButtonReleaseCallBack(
	DRAW_WINDOW* window,
	FLOAT_T x,
	FLOAT_T y,
	FLOAT_T pressure,
	BRUSH_CORE *core,
	void* state
)
{
	// マウスの左ボタンなら
	if(((GdkEventButton*)state)->button == 1)
	{
		// ブラシの詳細情報にキャスト
		BLEND_BRUSH *brush = (BLEND_BRUSH*)core->brush_data;
		// ブラシの縮小率
		FLOAT_T zoom;
		// ブラシの半径と不透明度
		FLOAT_T r, alpha;
		// 座標の最大・最小値
		FLOAT_T min_x, min_y, max_x, max_y;
		// X、Y方向の移動量
		FLOAT_T dx, dy;
		// ブラシの傾き用
		FLOAT_T diff_x, diff_y;
		// ブラシの移動量
		FLOAT_T d, step;
		// 描画を行う座標
		FLOAT_T draw_x, draw_y;
		// 入り、抜き時の色補正
		FLOAT_T enter_alpha, out_alpha;
		// ピクセルデータをリセットする座標
		int start_x, start_y;
		// 描画する幅、高さ、一行分のバイト数
		int width, height, stride;
		// 作業レイヤーの一行分のバイト数
		int layer_stride = window->work_layer->stride;
		// 作業レイヤーのピクセル
		uint8 *work_pixel = window->work_layer->pixels;
		// 描画座標指定用
		cairo_matrix_t matrix;
		// 参照ピクセル
		uint8 *mask;
		// 配列のインデックス用
		int ref_point;
		int before_point;
		int i;	// for文用のカウンタ

		while(brush->ref_point > brush->draw_finished)
		{
			ref_point = brush->draw_finished % BRUSH_POINT_BUFFER_SIZE;

			if(brush->finish_length < brush->enter_length)
			{
				enter_alpha = brush->finish_length / brush->enter_length;
				r = brush->enter_size + brush->finish_length * 0.25;
			}
			else
			{
				enter_alpha = 1;
				r = brush->r;
			}
			if(brush->sum_distance < brush->draw_start)
			{
				out_alpha = brush->sum_distance / brush->draw_start;
				r -= (brush->draw_start - brush->sum_distance) * 0.25;
			}
			else
			{
				out_alpha = 1;
			}

			if(r < 0.0)
			{
				brush->draw_finished++;
				continue;
			}

			if((brush->flags & BRUSH_FLAG_SIZE) != 0)
			{
				r *= brush->points[ref_point][3];
			}
			alpha = ((brush->flags & BRUSH_FLAG_FLOW) == 0)
				? 1 : brush->points[ref_point][3];
			alpha *= enter_alpha * out_alpha;
			before_point = (ref_point == 0) ? BRUSH_POINT_BUFFER_SIZE - 1 : ref_point - 1;
			if(r > MIN_BRUSH_STEP)
			{
				d = brush->points[ref_point][0];
				brush->sum_distance -= d;
				step = r * BRUSH_STEP;
				if(step < 0.5)
				{
					step = 0.5;
				}
				zoom = brush->r / r;
				if(brush->draw_finished == 0)
				{
					draw_x = brush->points[0][1], draw_y = brush->points[0][2];
				}
				else
				{
					draw_x = brush->points[before_point][1], draw_y = brush->points[before_point][2];
				}
				dx = brush->points[ref_point][1] - draw_x;
				dy = brush->points[ref_point][2] - draw_y;
				diff_x = step * dx / d, diff_y = step * dy / d;

				min_x = brush->points[ref_point][1] - r - 1;
				max_x = brush->points[ref_point][1] + r + 1;
				min_y = brush->points[ref_point][2] - r - 1;
				max_y = brush->points[ref_point][2] + r + 1;
				if(min_x < 0.0)
				{
					min_x = 0.0;
				}
				if(core->min_x > min_x)
				{
					core->min_x = min_x;
				}
				if(min_y < 0.0)
				{
					min_y = 0.0;
				}
				if(core->min_y > min_y)
				{
					core->min_y = min_y;
				}
				if(max_x > window->work_layer->width)
				{
					max_x = window->work_layer->width;
				}
				if(core->max_x < max_x)
				{
					core->max_x = max_x;
				}
				if(max_y > window->work_layer->height)
				{
					min_y = window->work_layer->height;
				}
				if(core->max_y < max_y)
				{
					core->max_y = max_y;
				}

				dx = d;
				do
				{
					start_x = (int)(draw_x - r);
					start_y = (int)(draw_y - r);
					width = (int)(draw_x + r);
					height = (int)(draw_y + r);

					if(start_x < 0)
					{
						start_x = 0;
					}
					else if(start_x > window->work_layer->width)
					{
						goto skip_draw;
					}
					if(start_y < 0)
					{
						start_y = 0;
					}
					else if(start_y > window->work_layer->height)
					{
						goto skip_draw;
					}
					if(width > window->work_layer->width)
					{
						width = window->work_layer->width - start_x;
					}
					else
					{
						width = width - start_x;
					}
					if(height > window->work_layer->height)
					{
						height = window->work_layer->height - start_y;
					}
					else
					{
						height = height - start_y;
					}
					stride = width*4;

					if(width <= 0 || height <= 0)
					{
						goto skip_draw;
					}

					for(i=0; i<height; i++)
					{
						(void)memset(&window->mask_temp->pixels[(i+start_y)*window->mask_temp->stride+start_x*4],
							0, stride);
					}

					cairo_set_operator(window->mask_temp->cairo_p, CAIRO_OPERATOR_OVER);

					mask = window->mask_temp->pixels;
					if((window->flags & DRAW_WINDOW_HAS_SELECTION_AREA) == 0)
					{
						if((window->active_layer->flags & LAYER_LOCK_OPACITY) == 0)
						{
							cairo_matrix_init_scale(&matrix, zoom, zoom);
							cairo_matrix_translate(&matrix, - draw_x + r, - draw_y + r);
							cairo_pattern_set_matrix(core->brush_pattern, &matrix);
							cairo_set_source(window->mask_temp->cairo_p, core->brush_pattern);
							cairo_paint_with_alpha(window->mask_temp->cairo_p, alpha);
						}
						else
						{
							cairo_matrix_init_scale(&matrix, zoom, zoom);
							cairo_pattern_set_matrix(core->brush_pattern, &matrix);
							cairo_set_source(core->temp_cairo, core->brush_pattern);
							cairo_paint_with_alpha(core->temp_cairo, alpha);
							cairo_matrix_init_translate(&matrix, - draw_x + r, - draw_y + r);
							cairo_pattern_set_matrix(core->temp_pattern, &matrix);
							cairo_set_source(window->mask_temp->cairo_p, core->temp_pattern);
							cairo_mask_surface(window->mask_temp->cairo_p,
								window->active_layer->surface_p, 0, 0);
						}
					}
					else
					{
						if((window->active_layer->flags & LAYER_LOCK_OPACITY) == 0)
						{
							cairo_matrix_init_scale(&matrix, zoom, zoom);
							cairo_pattern_set_matrix(core->brush_pattern, &matrix);
							cairo_set_source(core->temp_cairo, core->brush_pattern);
							cairo_paint_with_alpha(core->temp_cairo, alpha);
							cairo_matrix_init_translate(&matrix, - draw_x + r, - draw_y + r);
							cairo_pattern_set_matrix(core->temp_pattern, &matrix);
							cairo_set_source(window->mask_temp->cairo_p, core->temp_pattern);
							cairo_mask_surface(window->mask_temp->cairo_p,
								window->selection->surface_p, 0, 0);
						}
						else
						{
							cairo_matrix_init_scale(&matrix, zoom, zoom);
							cairo_pattern_set_matrix(core->brush_pattern, &matrix);
							cairo_set_source(core->temp_cairo, core->brush_pattern);
							cairo_paint_with_alpha(core->temp_cairo, alpha);
							cairo_matrix_init_translate(&matrix, - draw_x + r, - draw_y + r);
							cairo_pattern_set_matrix(core->temp_pattern, &matrix);
							cairo_set_source(window->mask_temp->cairo_p, core->temp_pattern);

							for(i=0; i<height; i++)
							{
								(void)memset(&window->temp_layer->pixels[
									(i+start_y)*window->temp_layer->stride+start_x*4],
									0, stride
								);
							}

							cairo_mask_surface(window->mask_temp->cairo_p,
								window->selection->surface_p, 0, 0);
							cairo_set_source_surface(window->temp_layer->cairo_p,
								window->mask_temp->surface_p, 0, 0);
							cairo_mask_surface(window->temp_layer->cairo_p,
								window->active_layer->surface_p, 0, 0);
	
							mask = window->temp_layer->pixels;
						}
					}

#ifdef _OPENMP
					if(height <= MINIMUM_PARALLEL_SIZE)
					{
						omp_set_dynamic(FALSE);
						omp_set_num_threads(1);
					}
#pragma omp parallel for firstprivate(width, work_pixel, layer_stride, start_x, start_y)
#endif
					for(i=0; i<height; i++)
					{
						uint8 *ref_pix = &work_pixel[
							(start_y+i)*layer_stride+start_x*4];
						uint8 *mask_pix = &mask[(start_y+i)*layer_stride
							+start_x*4];
						int j;

						for(j=0; j<width; j++, ref_pix+=4, mask_pix+=4)
						{
							if(ref_pix[3] < mask_pix[3])
							{
								ref_pix[0] = (uint8)((uint32)(((int)mask_pix[0]-(int)ref_pix[0])
									* mask_pix[3] >> 8) + ref_pix[0]);
								ref_pix[1] = (uint8)((uint32)(((int)mask_pix[1]-(int)ref_pix[1])
									* mask_pix[3] >> 8) + ref_pix[1]);
								ref_pix[2] = (uint8)((uint32)(((int)mask_pix[2]-(int)ref_pix[2])
									* mask_pix[3] >> 8) + ref_pix[2]);
								ref_pix[3] = (uint8)((uint32)(((int)mask_pix[3]-(int)ref_pix[3])
									* mask_pix[3] >> 8) + ref_pix[3]);
							}
						}
					}
#ifdef _OPENMP
					omp_set_dynamic(TRUE);
					omp_set_num_threads(window->app->max_threads);
#endif
					// アンチエイリアスを適用
					if((brush->flags & BRUSH_FLAG_ANTI_ALIAS) != 0)
					{
						ANTI_ALIAS_RECTANGLE range = {start_x - 1, start_y - 1,
							width + 1, height + 1};
						AntiAliasLayer(window->work_layer, window->temp_layer, &range);
					}
skip_draw:
					dx -= step;
					if(dx < 1)
					{
						break;
					}
					else if(dx >= step)
					{
						draw_x += diff_x, draw_y += diff_y;
					}
					else
					{
						draw_x = brush->points[ref_point][1];
						draw_y = brush->points[ref_point][2];
					}
				} while(1);
			}

			brush->finish_length += d;
			brush->travel += d;
			brush->draw_finished++;
			ref_point = brush->draw_finished % BRUSH_POINT_BUFFER_SIZE;
		}	// while(brush->ref_point > brush->draw_finished)

		AddSelectionEditHistory(core, window->selection);

		g_blend_selection_funcs[window->selection->layer_mode](window->work_layer, window->selection);

		(void)memset(window->work_layer->pixels, 0, window->work_layer->stride*window->work_layer->height);

		window->work_layer->layer_mode = LAYER_BLEND_NORMAL;
	}	// マウスの左ボタンなら
		// if(((GdkEventButton*)state)->button == 1)
}

static void BlendBrushDrawCursor(
	DRAW_WINDOW* window,
	FLOAT_T x,
	FLOAT_T y,
	void* data
)
{
	BLEND_BRUSH* brush = (BLEND_BRUSH*)data;
	FLOAT_T r = brush->r * window->zoom_rate;
	cairo_set_line_width(window->disp_temp->cairo_p, 1.0);
	cairo_set_source_rgb(window->disp_temp->cairo_p, 1, 1, 1);
	cairo_arc(window->disp_temp->cairo_p, x, y, r, 0, 2*G_PI);
	cairo_stroke(window->disp_temp->cairo_p);

	cairo_rectangle(window->disp_layer->cairo_p, x - r, y - r,
		(r + BRUSH_UPDATE_MARGIN) * 2, (r + BRUSH_UPDATE_MARGIN) * 2);
	cairo_clip(window->disp_layer->cairo_p);
}

static void BlendBrushButtonUpdate(DRAW_WINDOW* window, FLOAT_T x, FLOAT_T y, BLEND_BRUSH* brush)
{
	FLOAT_T r = brush->r * window->zoom_rate + 1;
	gtk_widget_queue_draw_area(window->window, (gint)(x - r - 1),
		(gint)(y - r - 1), (gint)(r * 2) + 2, (gint)(r * 2) + 2);
}

static void BlendBrushMotionUpdate(DRAW_WINDOW* window, FLOAT_T x, FLOAT_T y, BLEND_BRUSH* brush)
{
	FLOAT_T start_x, start_y;
	FLOAT_T width, height;
	FLOAT_T r = brush->r * window->zoom_rate * 1.275 + BRUSH_UPDATE_MARGIN;
	FLOAT_T enter = (brush->enter_length + brush->draw_start) * window->zoom_rate;

	if(window->before_cursor_x < x)
	{
		start_x = window->before_cursor_x - r;
		width = r * 2 + x - window->before_cursor_x;
	}
	else
	{
		start_x = x - r;
		width = r * 2 + window->before_cursor_x - x;
	}

	if(window->before_cursor_y < y)
	{
		start_y = window->before_cursor_y - r;
		height = r * 2 + y - window->before_cursor_y;
	}
	else
	{
		start_y = y - r;
		height = r * 2 + window->before_cursor_y - y;
	}

	start_x -= enter * 4;
	width += enter * 4 * 2 + 2;
	start_y -= enter * 4;
	height += enter * 4 * 2 + 2;

	gtk_widget_queue_draw_area(window->window,
		(gint)start_x, (gint)start_y, (gint)width, (gint)height);
}

static void BlendBrushColorChange(const uint8 color[3], void* data)
{
	BLEND_BRUSH *brush = (BLEND_BRUSH*)data;
	BrushCoreSetCirclePattern(brush->core, brush->r, brush->outline_hardness * 0.01, brush->blur * 0.01,
		brush->opacity * 0.01, *brush->core->color);
}

static void BlendBrushSetScale(GtkAdjustment* slider, BLEND_BRUSH* brush)
{
	brush->r = gtk_adjustment_get_value(slider) * 0.5;
	BrushCoreSetCirclePattern(brush->core, brush->r, brush->outline_hardness * 0.01, brush->blur * 0.01,
		brush->opacity * 0.01, *brush->core->color);
}

static void BlendBrushSetFlow(GtkAdjustment* slider, BLEND_BRUSH* brush)
{
	brush->opacity = gtk_adjustment_get_value(slider);
	BrushCoreSetCirclePattern(brush->core, brush->r, brush->outline_hardness * 0.01, brush->blur * 0.01,
		brush->opacity * 0.01, *brush->core->color);
}

static void BlendBrushSetBlur(GtkAdjustment* slider, BLEND_BRUSH* brush)
{
	brush->blur = gtk_adjustment_get_value(slider);
	BrushCoreSetCirclePattern(brush->core, brush->r, brush->outline_hardness * 0.01, brush->blur * 0.01,
		brush->opacity * 0.01, *brush->core->color);
}

static void BlendBrushSetOutlineHardness(GtkAdjustment* slider, BLEND_BRUSH* brush)
{
	brush->outline_hardness = gtk_adjustment_get_value(slider);
	BrushCoreSetCirclePattern(brush->core, brush->r, brush->outline_hardness * 0.01, brush->blur * 0.01,
		brush->opacity * 0.01, *brush->core->color);
}

static void BlendBrushSetEnterSize(GtkAdjustment* slider, BLEND_BRUSH* brush)
{
	brush->enter = gtk_adjustment_get_value(slider);
}

static void BlendBrushSetOutSize(GtkAdjustment* slider, BLEND_BRUSH* brush)
{
	brush->out = gtk_adjustment_get_value(slider);
}

static void BlendBrushSetPressureSize(GtkWidget* button, BLEND_BRUSH* brush)
{
	if(gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(button)) == FALSE)
	{
		brush->flags &= ~(BRUSH_FLAG_SIZE);
	}
	else
	{
		brush->flags |= BRUSH_FLAG_SIZE;
	}
}

static void BlendBrushSetPressureFlow(GtkWidget* button, BLEND_BRUSH* brush)
{
	if(gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(button)) == FALSE)
	{
		brush->flags &= ~(BRUSH_FLAG_FLOW);
	}
	else
	{
		brush->flags |= BRUSH_FLAG_FLOW;
	}
}

static void BlendBrushSetBlendMode(GtkComboBox* combo, BLEND_BRUSH* brush)
{
	brush->blend_mode = (uint16)gtk_combo_box_get_active(combo);
}

static void BlendBrushSetBlendTarget(GtkWidget* button, BLEND_BRUSH* brush)
{
	int target = GPOINTER_TO_INT(g_object_get_data(G_OBJECT(button), "target"));
	if(gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(button)) != FALSE)
	{
		brush->target = (uint8)target;
	}
}

static void BlendBrushSetAntiAlias(GtkWidget* button, BLEND_BRUSH* brush)
{
	if(gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(button)) == FALSE)
	{
		brush->flags &= ~(BRUSH_FLAG_ANTI_ALIAS);
	}
	else
	{
		brush->flags |= BRUSH_FLAG_ANTI_ALIAS;
	}
}

static GtkWidget* CreateBlendBrushDetailUI(APPLICATION* app, BRUSH_CORE* core)
{
#define UI_FONT_SIZE 8.0
	BLEND_BRUSH *brush = (BLEND_BRUSH*)core->brush_data;
	GtkWidget *vbox = gtk_vbox_new(FALSE, 0);
	GtkWidget *hbox;
	GtkWidget *brush_scale;
	GtkWidget *check_button;
	GtkWidget *buttons[2];
	GtkWidget *combo;
	GtkWidget *label;
	GtkAdjustment *scale_adjustment;
	char mark_up_buff[256];
	int i;

	brush->core = core;

	{
		const char *mag_str[] = {"x 0.1", "x 1", "x 10"};
		hbox = gtk_hbox_new(FALSE, 0);
		label = gtk_label_new("");
		(void)sprintf(mark_up_buff, "<span font_desc=\"%.2f\">%s : </span>",
			UI_FONT_SIZE * app->gui_scale, app->labels->tool_box.base_scale);
		gtk_label_set_markup(GTK_LABEL(label), mark_up_buff);
		gtk_box_pack_start(GTK_BOX(hbox), label, FALSE, FALSE, 0);
#if GTK_MAJOR_VERSION <= 2
		combo = gtk_combo_box_new_text();
		gtk_combo_box_append_text(GTK_COMBO_BOX(combo), mag_str[0]);
		gtk_combo_box_append_text(GTK_COMBO_BOX(combo), mag_str[1]);
		gtk_combo_box_append_text(GTK_COMBO_BOX(combo), mag_str[2]);
#else
		combo = gtk_combo_box_text_new();
		gtk_combo_box_text_append_text(GTK_COMBO_BOX_TEXT(combo), mag_str[0]);
		gtk_combo_box_text_append_text(GTK_COMBO_BOX_TEXT(combo), mag_str[1]);
		gtk_combo_box_text_append_text(GTK_COMBO_BOX_TEXT(combo), mag_str[2]);
#endif
		gtk_combo_box_set_active(GTK_COMBO_BOX(combo), brush->base_scale);
		gtk_box_pack_start(GTK_BOX(hbox), combo, TRUE, TRUE, 0);
		gtk_box_pack_start(GTK_BOX(vbox), hbox, FALSE, FALSE, 0);
	}

	switch(brush->base_scale)
	{
	case 0:
		scale_adjustment = GTK_ADJUSTMENT(gtk_adjustment_new(
			brush->r * 2, 0.1, 10.0, 0.1, 0.1, 0.0));
		break;
	case 1:
		scale_adjustment = GTK_ADJUSTMENT(gtk_adjustment_new(
			brush->r * 2, 1.0, 100.0, 1.0, 1.0, 0.0));
		break;
	default:
		scale_adjustment = GTK_ADJUSTMENT(gtk_adjustment_new(
			brush->r * 2, 5.0, 500.0, 1.0, 1.0, 0.0));
	}

	(void)g_signal_connect(G_OBJECT(scale_adjustment), "value_changed",
		G_CALLBACK(BlendBrushSetScale), core->brush_data);
	brush_scale = SpinScaleNew(scale_adjustment, app->labels->tool_box.brush_scale, 1);
	gtk_box_pack_start(GTK_BOX(vbox), brush_scale, FALSE, FALSE, 0);

	g_object_set_data(G_OBJECT(combo), "scale", brush_scale);
	(void)g_signal_connect(G_OBJECT(combo), "changed", G_CALLBACK(SetBrushBaseScale), &brush->base_scale);

	scale_adjustment = GTK_ADJUSTMENT(gtk_adjustment_new(
		brush->opacity, 0.0, 100.0, 1.0, 1.0, 0.0));
	(void)g_signal_connect(G_OBJECT(scale_adjustment), "value_changed",
		G_CALLBACK(BlendBrushSetFlow), core->brush_data);
	brush_scale = SpinScaleNew(scale_adjustment, app->labels->tool_box.flow, 1);
	gtk_box_pack_start(GTK_BOX(vbox), brush_scale, FALSE, FALSE, 0);

	scale_adjustment = GTK_ADJUSTMENT(gtk_adjustment_new(
		brush->outline_hardness, 0.0, 100.0, 1.0, 1.0, 0.0));
	(void)g_signal_connect(G_OBJECT(scale_adjustment), "value_changed",
		G_CALLBACK(BlendBrushSetOutlineHardness), core->brush_data);
	brush_scale = SpinScaleNew(scale_adjustment, app->labels->tool_box.outline_hardness, 1);
	gtk_box_pack_start(GTK_BOX(vbox), brush_scale, FALSE, FALSE, 0);

	scale_adjustment = GTK_ADJUSTMENT(gtk_adjustment_new(
		brush->blur, 0.0, 100.0, 1.0, 1.0, 0.0));
	(void)g_signal_connect(G_OBJECT(scale_adjustment), "value_changed",
		G_CALLBACK(BlendBrushSetBlur), core->brush_data);
	brush_scale = SpinScaleNew(scale_adjustment, app->labels->tool_box.blur, 1);
	gtk_box_pack_start(GTK_BOX(vbox), brush_scale, FALSE, FALSE, 0);

	scale_adjustment = GTK_ADJUSTMENT(gtk_adjustment_new(
		brush->enter, 0.0, 100.0, 1.0, 1.0, 0.0));
	(void)g_signal_connect(G_OBJECT(scale_adjustment), "value_changed",
		G_CALLBACK(BlendBrushSetEnterSize), core->brush_data);
	brush_scale = SpinScaleNew(scale_adjustment, app->labels->tool_box.enter, 1);
	gtk_box_pack_start(GTK_BOX(vbox), brush_scale, FALSE, FALSE, 0);

	scale_adjustment = GTK_ADJUSTMENT(gtk_adjustment_new(
		brush->out, 0.0, 100.0, 1.0, 1.0, 0.0));
	(void)g_signal_connect(G_OBJECT(scale_adjustment), "value_changed",
		G_CALLBACK(BlendBrushSetOutSize), core->brush_data);
	brush_scale = SpinScaleNew(scale_adjustment, app->labels->tool_box.out, 1);
	gtk_box_pack_start(GTK_BOX(vbox), brush_scale, FALSE, FALSE, 0);

	hbox = gtk_hbox_new(FALSE, 0);
	label = gtk_label_new("");
#if GTK_MAJOR_VERSION <= 2
	combo = gtk_combo_box_new_text();
#else
	combo = gtk_combo_box_text_new();
#endif
	(void)sprintf(mark_up_buff, "<span font_desc=\"%.2f\">%s : </span>",
		UI_FONT_SIZE * app->gui_scale, app->labels->layer_window.blend_mode);
	gtk_label_set_markup(GTK_LABEL(label), mark_up_buff);
	gtk_box_pack_start(GTK_BOX(hbox), label, FALSE, FALSE, 0);
	for(i=0; i<LAYER_BLEND_SLELECTABLE_NUM; i++)
	{
#if GTK_MAJOR_VERSION <= 2
		gtk_combo_box_append_text(GTK_COMBO_BOX(combo), app->labels->layer_window.blend_modes[i]);
#else
		gtk_combo_box_text_append_text(GTK_COMBO_BOX_TEXT(combo), app->labels->layer_window.blend_modes[i]);
#endif
	}
	gtk_combo_box_set_active(GTK_COMBO_BOX(combo), brush->blend_mode);
	(void)g_signal_connect(G_OBJECT(combo), "changed",
		G_CALLBACK(BlendBrushSetBlendMode), brush);
	gtk_box_pack_start(GTK_BOX(hbox), combo, FALSE, TRUE, 0);
	gtk_box_pack_start(GTK_BOX(vbox), hbox, FALSE, TRUE, 0);

	label = gtk_label_new("");
	(void)sprintf(mark_up_buff, "<span font_desc=\"%.2f\">%s : </span>",
		UI_FONT_SIZE * app->gui_scale, app->labels->tool_box.select.target);
	gtk_label_set_markup(GTK_LABEL(label), mark_up_buff);
	hbox = gtk_hbox_new(FALSE, 0);
	gtk_box_pack_start(GTK_BOX(hbox), label, FALSE, FALSE, 0);
	gtk_box_pack_start(GTK_BOX(vbox), hbox, FALSE, FALSE, 0);
	buttons[0] = gtk_radio_button_new_with_label(NULL, app->labels->tool_box.select.under_layer);
	g_object_set_data(G_OBJECT(buttons[0]), "target", GINT_TO_POINTER(BLEND_BRUSH_TARGET_UNDER_LAYER));
	(void)g_signal_connect(G_OBJECT(buttons[0]), "toggled", G_CALLBACK(BlendBrushSetBlendTarget), brush);
	buttons[1] = gtk_radio_button_new_with_label(gtk_radio_button_get_group(
		GTK_RADIO_BUTTON(buttons[0])), app->labels->tool_box.select.canvas);
	g_object_set_data(G_OBJECT(buttons[1]), "target", GINT_TO_POINTER(BLEND_BRUSH_TARGET_CANVAS));
	(void)g_signal_connect(G_OBJECT(buttons[1]), "toggled", G_CALLBACK(BlendBrushSetBlendTarget), brush);
	gtk_box_pack_start(GTK_BOX(vbox), buttons[0], FALSE, FALSE, 0);
	gtk_box_pack_start(GTK_BOX(vbox), buttons[1], FALSE, FALSE, 0);
	gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(buttons[brush->target]), TRUE);

	hbox = gtk_hbox_new(FALSE, 0);
	label = gtk_label_new("");
	(void)sprintf(mark_up_buff, "<span font_desc=\"%.2f\">%s : </span>",
		UI_FONT_SIZE * app->gui_scale, app->labels->tool_box.pressure);
	gtk_label_set_markup(GTK_LABEL(label), mark_up_buff);
	gtk_box_pack_start(GTK_BOX(hbox), label, FALSE, FALSE, 0);
	check_button = gtk_check_button_new_with_label(app->labels->tool_box.scale);
	(void)g_signal_connect(G_OBJECT(check_button), "toggled",
		G_CALLBACK(BlendBrushSetPressureSize), core->brush_data);
	gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(check_button), brush->flags & BRUSH_FLAG_SIZE);
	gtk_box_pack_start(GTK_BOX(hbox), check_button, FALSE, TRUE, 0);
	check_button = gtk_check_button_new_with_label(app->labels->tool_box.flow);
	(void)g_signal_connect(G_OBJECT(check_button), "toggled",
		G_CALLBACK(BlendBrushSetPressureFlow), core->brush_data);
	gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(check_button), brush->flags & BRUSH_FLAG_FLOW);
	gtk_box_pack_start(GTK_BOX(hbox), check_button, FALSE, TRUE, 0);
	gtk_box_pack_start(GTK_BOX(vbox), hbox, FALSE, TRUE, 0);

	check_button = gtk_check_button_new_with_label(app->labels->tool_box.anti_alias);
	(void)g_signal_connect(G_OBJECT(check_button), "toggled",
		G_CALLBACK(BlendBrushSetAntiAlias), core->brush_data);
	gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(check_button), brush->flags & BRUSH_FLAG_ANTI_ALIAS);
	gtk_box_pack_start(GTK_BOX(vbox), check_button, FALSE, TRUE, 0);

	BrushCoreSetCirclePattern(brush->core, brush->r, brush->outline_hardness * 0.01, brush->blur * 0.01,
		brush->opacity * 0.01, *brush->core->color);

	return vbox;
#undef UI_FONT_SIZE
}

static void WaterColorBrushPressCallBack(
	DRAW_WINDOW* window,
	FLOAT_T x,
	FLOAT_T y,
	FLOAT_T pressure,
	BRUSH_CORE *core,
	void* state
)
{
	// 左クリックならば
	if(((GdkEventButton*)state)->button == 1)
	{
		// ブラシの詳細情報にキャスト
		WATER_COLOR_BRUSH *brush = (WATER_COLOR_BRUSH*)core->brush_data;
		// 更新範囲のイメージ情報
		cairo_t *update;
		cairo_surface_t *update_surface;
		// ブラシの半径と不透明度
		FLOAT_T r, alpha;
		// ブラシの拡大率
		FLOAT_T zoom;
		// 座標の最大値・最小値
		FLOAT_T min_x, min_y, max_x, max_y;
		// ピクセルデータをリセットする座標
		int start_x, start_y;
		// 描画する幅・高さ
		int width, height;
		// 作業レイヤーの幅
		int layer_width = window->work_layer->width;
		// 作業レイヤーの一行分のバイト数
		int layer_stride = window->work_layer->stride;
		// 作業レイヤーのピクセル
		uint8 *work_pixel = window->work_layer->pixels;
		// ブラシの位置設定用
		cairo_matrix_t matrix;
		// ブラシ位置のピクセル値合計
		unsigned int sum_color0 = 0, sum_color1 = 0, sum_color2 = 0,
			sum_color3 = 1, sum_color4 = 0, sum_color5 = 1;
		// 参照ピクセル
		uint8  *mask;
		// 描画する色
		int color[4];
		int rev_alpha;
		uint8 blend_alpha;
		// 混色具合
		uint8 mix = (uint8)(brush->mix * 2.55 + 0.5);
		int i;	// for文用のカウンタ

		(void)memcpy(window->work_layer->pixels, window->active_layer->pixels, window->pixel_buf_size);
		(void)memset(window->brush_buffer, 0, window->pixel_buf_size);

		window->work_layer->layer_mode = LAYER_BLEND_SOURCE;

		brush->before_x = brush->last_draw_x = x;
		brush->before_y = brush->last_draw_y = y;
		brush->points[0][1] = x, brush->points[0][2] = y;
		brush->points[0][3] = pressure;

		if((brush->flags & BRUSH_FLAG_SIZE) != 0)
		{
			r = brush->r * pressure;
			zoom = 1/pressure;
		}
		else
		{
			r = brush->r;
			zoom = 1;
		}

		brush->sum_distance = brush->travel = brush->finish_length = 0.0;
		brush->draw_start = r * brush->out * 0.01 * 4;
		brush->enter_length = r * brush->enter * 0.01 * 4;
		brush->enter_size = r * (1 - brush->enter * 0.01);
		brush->num_point = 0;
		brush->draw_finished = 0;
		brush->ref_point = 1;

		min_x = x - r, max_x = x + r;
		min_y = y - r, max_y = y + r;

		if(min_x < 0.0)
		{
			min_x = 0.0;
		}
		if(min_y < 0.0)
		{
			min_y = 0.0;
		}
		if(max_x > window->work_layer->width)
		{
			max_x = window->work_layer->width;
		}
		if(max_y > window->work_layer->height)
		{
			max_y = window->work_layer->height;
		}

		core->min_x = min_x, core->min_y = min_y;
		core->max_x = max_x, core->max_y = max_y;

		window->update.x = (int)min_x, window->update.y = (int)min_y;
		window->update.width = (int)max_x - window->update.x;
		window->update.height = (int)max_y - window->update.y;

		window->flags |= DRAW_WINDOW_UPDATE_PART;

		if(brush->enter_length == 0 && r > 0.5)
		{
			alpha = ((brush->flags & BRUSH_FLAG_FLOW) == 0) ? 1 : pressure;
			start_x = (int)min_x, start_y = (int)min_y;
			width = (int)(max_x - min_x);
			height = (int)(max_y - min_y);

			update_surface = cairo_surface_create_for_rectangle(
				window->alpha_surface, x - r, y - r, r*2+1, r*2+1
			);
			update = cairo_create(update_surface);

			(void)memset(window->mask->pixels, 0, window->width*window->height);

			mask = window->mask->pixels;
			cairo_set_operator(window->alpha_cairo, CAIRO_OPERATOR_OVER);
			if(window->app->textures.active_texture == 0)
			{
				if((window->flags & DRAW_WINDOW_HAS_SELECTION_AREA) == 0)
				{
					if((window->active_layer->flags & LAYER_LOCK_OPACITY) == 0)
					{
						cairo_matrix_init_scale(&matrix, zoom, zoom);
						cairo_pattern_set_matrix(core->brush_pattern, &matrix);
						cairo_set_source(update, core->brush_pattern);
						cairo_paint_with_alpha(update, alpha);
					}
					else
					{
						cairo_matrix_init_scale(&matrix, zoom, zoom);
						cairo_pattern_set_matrix(core->brush_pattern, &matrix);
						cairo_set_source(core->temp_cairo, core->brush_pattern);
						cairo_paint_with_alpha(core->temp_cairo, alpha);
						cairo_matrix_init_translate(&matrix, 0, 0);
						cairo_pattern_set_matrix(core->temp_pattern, &matrix);
						cairo_set_source(update, core->temp_pattern);
						cairo_mask_surface(update,
							window->active_layer->surface_p, - x + r, - y + r);
					}
				}
				else
				{
					if((window->active_layer->flags & LAYER_LOCK_OPACITY) == 0)
					{
						cairo_matrix_init_scale(&matrix, zoom, zoom);
						cairo_pattern_set_matrix(core->brush_pattern, &matrix);
						cairo_set_source(core->temp_cairo, core->brush_pattern);
						cairo_paint_with_alpha(core->temp_cairo, alpha);
						cairo_matrix_init_translate(&matrix, 0, 0);
						cairo_pattern_set_matrix(core->temp_pattern, &matrix);
						cairo_set_source(update, core->temp_pattern);
						cairo_mask_surface(update,
							window->selection->surface_p, - x + r, - y + r);
					}
					else
					{
						cairo_surface_t *temp_surface = cairo_surface_create_for_rectangle(
							window->alpha_temp, x - r, y - r, r*2+1, r*2+1);
						cairo_t *update_temp = cairo_create(temp_surface);

						cairo_matrix_init_scale(&matrix, zoom, zoom);
						cairo_pattern_set_matrix(core->brush_pattern, &matrix);
						cairo_set_source(core->temp_cairo, core->brush_pattern);
						cairo_paint_with_alpha(core->temp_cairo, alpha);
						cairo_matrix_init_translate(&matrix, 0, 0);
						cairo_pattern_set_matrix(core->temp_pattern, &matrix);
						cairo_set_source(update, core->temp_pattern);

						(void)memset(window->temp_layer->pixels, 0,
							window->width*window->height);

						cairo_mask_surface(update,
							window->selection->surface_p, 0, 0);
						cairo_set_source_surface(update_temp,
							update_surface, 0, 0);
						cairo_mask_surface(update_temp,
							window->active_layer->surface_p, - x + r, - y + r);

						mask = window->temp_layer->pixels;

						cairo_surface_destroy(temp_surface);
						cairo_destroy(update_temp);
					}
				}
			}
			else
			{
				cairo_surface_t *temp_surface = cairo_surface_create_for_rectangle(
					window->alpha_temp, x - r, y - r, r*2+1, r*2+1);
				cairo_t *update_temp = cairo_create(temp_surface);

				if((window->flags & DRAW_WINDOW_HAS_SELECTION_AREA) == 0)
				{
					if((window->active_layer->flags & LAYER_LOCK_OPACITY) == 0)
					{
						cairo_matrix_init_scale(&matrix, zoom, zoom);
						cairo_pattern_set_matrix(core->brush_pattern, &matrix);
						cairo_set_source(update, core->brush_pattern);
						cairo_paint_with_alpha(update, alpha);
					}
					else
					{
						cairo_matrix_init_scale(&matrix, zoom, zoom);
						cairo_pattern_set_matrix(core->brush_pattern, &matrix);
						cairo_set_source(core->temp_cairo, core->brush_pattern);
						cairo_paint_with_alpha(core->temp_cairo, alpha);
						cairo_matrix_init_translate(&matrix, 0, 0);
						cairo_pattern_set_matrix(core->temp_pattern, &matrix);
						cairo_set_source(update, core->temp_pattern);
						cairo_mask_surface(update,
							window->active_layer->surface_p, - x + r, - y + r);
					}

					cairo_set_source_surface(update_temp, update_surface, 0, 0);
					cairo_mask_surface(update_temp, window->texture->surface_p, - x + r, - y + r);

					mask = window->temp_layer->pixels;
				}
				else
				{
					if((window->active_layer->flags & LAYER_LOCK_OPACITY) == 0)
					{
						cairo_matrix_init_scale(&matrix, zoom, zoom);
						cairo_pattern_set_matrix(core->brush_pattern, &matrix);
						cairo_set_source(core->temp_cairo, core->brush_pattern);
						cairo_paint_with_alpha(core->temp_cairo, alpha);
						cairo_matrix_init_translate(&matrix, 0, 0);
						cairo_pattern_set_matrix(core->temp_pattern, &matrix);
						cairo_set_source(update, core->temp_pattern);
						cairo_mask_surface(update,
							window->selection->surface_p, - x + r, - y + r);

						cairo_set_source_surface(update_temp, update_surface, 0, 0);
						cairo_mask_surface(update_temp, window->texture->surface_p, - x + r, - y + r);

						mask = window->temp_layer->pixels;
					}
					else
					{
						cairo_matrix_init_scale(&matrix, zoom, zoom);
						cairo_pattern_set_matrix(core->brush_pattern, &matrix);
						cairo_set_source(core->temp_cairo, core->brush_pattern);
						cairo_paint_with_alpha(core->temp_cairo, alpha);
						cairo_matrix_init_translate(&matrix, 0, 0);
						cairo_pattern_set_matrix(core->temp_pattern, &matrix);
						cairo_set_source(update, core->temp_pattern);

						(void)memset(window->temp_layer->pixels, 0,
							window->width*window->height);

						cairo_mask_surface(update,
							window->selection->surface_p, 0, 0);
						cairo_set_source_surface(update_temp,
							update_surface, 0, 0);
						cairo_mask_surface(update_temp,
							window->active_layer->surface_p, - x + r, - y + r);

						cairo_set_operator(update, CAIRO_OPERATOR_SOURCE);
						cairo_set_source_surface(update, temp_surface, 0, 0);
						cairo_mask_surface(update, window->texture->surface_p, - x + r, - y + r);
					}
				}

				cairo_surface_destroy(temp_surface);
				cairo_destroy(update_temp);
			}

			cairo_surface_destroy(update_surface);
			cairo_destroy(update);

#ifdef _OPENMP
#pragma omp parallel for reduction( +: sum_color0, sum_color1, sum_color2, sum_color3, sum_color4, sum_color5) firstprivate(width, work_pixel, layer_width, layer_stride, start_x, start_y)
#endif
			for(i=0; i<height; i++)
			{
				uint8 *ref_pix = &work_pixel[(i+start_y)*layer_stride+start_x*4];
				uint8 *mask_pix = &mask[(i+start_y)*layer_width+start_x];
				int j;

				for(j=0; j<width; j++, ref_pix+=4, mask_pix++)
				{
					sum_color0 += ((ref_pix[0]+1) * *mask_pix * ref_pix[3]) >> 8;
					sum_color1 += ((ref_pix[1]+1) * *mask_pix * ref_pix[3]) >> 8;
					sum_color2 += ((ref_pix[2]+1) * *mask_pix * ref_pix[3]) >> 8;
					sum_color3 += ((ref_pix[3]+1) * *mask_pix) >> 8;
					sum_color4 += ref_pix[3] * *mask_pix;
					sum_color5 += *mask_pix;
				}
			}

			color[0] = (sum_color0 + sum_color3 / 2) / sum_color3;
			if(color[0] > 0xff)
			{
				color[0] = 0xff;
			}
			color[1] = (sum_color1 + sum_color3 / 2) / sum_color3;
			if(color[1] > 0xff)
			{
				color[1] = 0xff;
			}
			color[2] = (sum_color2 + sum_color3 / 2) / sum_color3;
			if(color[2] > 0xff)
			{
				color[2] = 0xff;
			}
			color[3] = (uint8)(sum_color4 / sum_color5);

			// 描画する色を決定
			rev_alpha = 0xff-mix+1;
			blend_alpha = (uint8)(brush->alpha * 2.55 + 0.5);
#if defined(USE_BGR_COLOR_SPACE) && USE_BGR_COLOR_SPACE != 0
			color[0] = (rev_alpha*(*core->color)[2]+(mix+1)*color[0])>>8;
			color[1] = (rev_alpha*(*core->color)[1]+(mix+1)*color[1])>>8;
			color[2] = (rev_alpha*(*core->color)[0]+(mix+1)*color[2])>>8;
			color[3] = (rev_alpha*blend_alpha+(mix+1)*color[3])>>8;
#else
			color[0] = (rev_alpha*(*core->color)[0]+(mix+1)*color[0])>>8;
			color[1] = (rev_alpha*(*core->color)[1]+(mix+1)*color[1])>>8;
			color[2] = (rev_alpha*(*core->color)[2]+(mix+1)*color[2])>>8;
			color[3] = (rev_alpha*blend_alpha+(mix+1)*color[3])>>8;
#endif

			// 現在の色を記憶
			brush->before_color[0] = color[0];
			brush->before_color[1] = color[1];
			brush->before_color[2] = color[2];
			brush->before_color[3] = color[3];

#ifdef _OPENMP
#pragma omp parallel for firstprivate(width, work_pixel, layer_width, layer_stride, start_x, start_y)
#endif
			// 作業レイヤーに描画
			for(i=0; i<height; i++)
			{
				uint8 *ref_pix = &work_pixel[(i+start_y)*layer_stride+start_x*4];
				uint8 *mask_pix = &mask[(i+start_y)*layer_width+start_x];
				uint8 mask_value;
				int j;

				for(j=0; j<width; j++, ref_pix+=4, mask_pix++)
				{
					mask_value = *mask_pix;
					ref_pix[3] = ((mask_value+1)*color[3]+(0xff-mask_value+1)*ref_pix[3])>>8;

					ref_pix[0] = (uint8)(((mask_value+1)*color[0]+(0xff-mask_value+1)*ref_pix[0])>>8);
					ref_pix[1] = (uint8)(((mask_value+1)*color[1]+(0xff-mask_value+1)*ref_pix[1])>>8);
					ref_pix[2] = (uint8)(((mask_value+1)*color[2]+(0xff-mask_value+1)*ref_pix[2])>>8);
				}
			}

			(void)memcpy(window->brush_buffer, mask, window->width*window->height);

			for(i=0; i<height; i++)
			{
				(void)memcpy(&window->temp_layer->pixels[(i+start_y)*window->stride+start_x*4],
					&window->work_layer->pixels[(i+start_y)*window->stride+start_x*4], width*4);
			}
			update_surface = cairo_surface_create_for_rectangle(window->work_layer->surface_p,
				start_x, start_y, width, height);
			update = cairo_create(update_surface);
			cairo_set_source_surface(update, window->temp_layer->surface_p, start_x, start_y);
			cairo_mask_surface(update, window->temp_layer->surface_p, start_x, start_y);
			cairo_surface_destroy(update_surface);
			cairo_destroy(update);

			brush->draw_finished++;
		}
	}
}

static void WaterColorBrushEditSelectionPressCallBack(
	DRAW_WINDOW* window,
	FLOAT_T x,
	FLOAT_T y,
	FLOAT_T pressure,
	BRUSH_CORE *core,
	void* state
)
{
	// 左クリックならば
	if(((GdkEventButton*)state)->button == 1)
	{
		// ブラシの詳細情報にキャスト
		WATER_COLOR_BRUSH *brush = (WATER_COLOR_BRUSH*)core->brush_data;
		// ブラシの半径と不透明度
		FLOAT_T r, alpha;
		// ブラシの拡大率
		FLOAT_T zoom;
		// ブラシの座標指定用
		cairo_matrix_t matrix;
		// 座標の最大値・最小値
		FLOAT_T min_x, min_y, max_x, max_y;
		// ピクセルデータをリセットする座標
		int start_x, start_y;
		// 描画する幅・高さ
		int width, height;
		// キャンバスの幅
		int canvas_width = window->width;
		// ブラシ位置のピクセル値合計
		unsigned int sum_color0 = 1, sum_color1 = 1;
		// 作業レイヤーのピクセル
		uint8 *work_pixel = window->work_layer->pixels;
		// 参照ピクセル
		uint8 *mask;
		// 描画する色
		uint8 color[2];
		int rev_alpha;
		uint8 blend_alpha;
		// 混色具合
		uint8 mix = (uint8)(brush->mix * 2.55);
		int i;	// for文用のカウンタ

		(void)memcpy(window->work_layer->pixels, window->selection->pixels, window->width * window->height);
		(void)memset(window->brush_buffer, 0, window->width*window->height);

		window->selection->layer_mode = SELECTION_BLEND_COPY;

		brush->before_x = brush->last_draw_x = x;
		brush->before_y = brush->last_draw_y = y;
		brush->points[0][1] = x, brush->points[0][2] = y;
		brush->points[0][3] = pressure;

		if((brush->flags & BRUSH_FLAG_SIZE) != 0)
		{
			r = brush->r * pressure;
			zoom = 1/pressure;
		}
		else
		{
			r = brush->r;
			zoom = 1;
		}

		brush->sum_distance = brush->travel = brush->finish_length = 0.0;
		brush->draw_start = r * brush->out * 0.01 * 4;
		brush->enter_length = r * brush->enter * 0.01 * 4;
		brush->enter_size = r * (1 - brush->enter * 0.01);
		brush->num_point = 0;
		brush->draw_finished = 0;
		brush->ref_point = 1;

		min_x = x - r, max_x = x + r;
		min_y = y - r, max_y = y + r;

		if(min_x < 0.0)
		{
			min_x = 0.0;
		}
		if(min_y < 0.0)
		{
			min_y = 0.0;
		}
		if(max_x > window->work_layer->width)
		{
			max_x = window->work_layer->width;
		}
		if(max_y > window->work_layer->height)
		{
			max_y = window->work_layer->height;
		}

		core->min_x = min_x, core->min_y = min_y;
		core->max_x = max_x, core->max_y = max_y;

		if(brush->enter_length == 0)
		{
			alpha = ((brush->flags & BRUSH_FLAG_FLOW) == 0) ? 1 : pressure;
			start_x = (int)min_x, start_y = (int)min_y;
			width = (int)(max_x - min_x);
			height = (int)(max_y - min_y);

			(void)memset(window->mask->pixels, 0, window->width*window->height);

			mask = window->mask->pixels;
			cairo_set_operator(window->alpha_cairo, CAIRO_OPERATOR_OVER);
			if((window->flags & DRAW_WINDOW_HAS_SELECTION_AREA) == 0)
			{
				if((window->active_layer->flags & LAYER_LOCK_OPACITY) == 0)
				{
					cairo_matrix_init_scale(&matrix, zoom, zoom);
					cairo_matrix_translate(&matrix, - x + r, - y + r);
					cairo_pattern_set_matrix(core->brush_pattern, &matrix);
					cairo_set_source(window->alpha_cairo, core->brush_pattern);
					cairo_paint_with_alpha(window->alpha_cairo, alpha);
				}
				else
				{
					cairo_matrix_init_scale(&matrix, zoom, zoom);
					cairo_pattern_set_matrix(core->brush_pattern, &matrix);
					cairo_set_source(core->temp_cairo, core->brush_pattern);
					cairo_paint_with_alpha(core->temp_cairo, alpha);
					cairo_matrix_init_translate(&matrix, - x + r, - y + r);
					cairo_pattern_set_matrix(core->temp_pattern, &matrix);
					cairo_set_source(window->alpha_cairo, core->temp_pattern);
					cairo_mask_surface(window->alpha_cairo,
						window->active_layer->surface_p, 0, 0);
				}
			}
			else
			{
				if((window->active_layer->flags & LAYER_LOCK_OPACITY) == 0)
				{
					cairo_matrix_init_scale(&matrix, zoom, zoom);
					cairo_pattern_set_matrix(core->brush_pattern, &matrix);
					cairo_set_source(core->temp_cairo, core->brush_pattern);
					cairo_paint_with_alpha(core->temp_cairo, alpha);
					cairo_matrix_init_translate(&matrix, - x + r, - y + r);
					cairo_pattern_set_matrix(core->temp_pattern, &matrix);
					cairo_set_source(window->alpha_cairo, core->temp_pattern);
					cairo_mask_surface(window->alpha_cairo,
						window->selection->surface_p, 0, 0);
				}
				else
				{
					cairo_matrix_init_scale(&matrix, zoom, zoom);
					cairo_pattern_set_matrix(core->brush_pattern, &matrix);
					cairo_set_source(core->temp_cairo, core->brush_pattern);
					cairo_paint_with_alpha(core->temp_cairo, alpha);
					cairo_matrix_init_translate(&matrix, - x + r, - y + r);
					cairo_pattern_set_matrix(core->temp_pattern, &matrix);
					cairo_set_source(window->alpha_cairo, core->temp_pattern);

					(void)memset(window->temp_layer->pixels, 0, window->width*window->height);

					cairo_mask_surface(window->alpha_cairo,
						window->selection->surface_p, 0, 0);
					cairo_set_source_surface(window->alpha_temp_cairo,
						window->alpha_surface, 0, 0);
					cairo_mask_surface(window->alpha_temp_cairo,
						window->active_layer->surface_p, 0, 0);

					mask = window->temp_layer->pixels;
				}
			}

#ifdef _OPENMP
#pragma omp parallel for reduction( +: sum_color0, sum_color1) firstprivate(width, work_pixel, canvas_width, start_x, start_y)
#endif
			for(i=0; i<height; i++)
			{
				uint8 *ref_pix = &work_pixel[(i+start_y)*canvas_width+start_x];
				uint8 *mask_pix = &mask[(i+start_y)*canvas_width+start_x];
				int j;

				for(j=0; j<width; j++, ref_pix++, mask_pix++)
				{
					sum_color0 += ((ref_pix[0]+1) * *mask_pix) >> 8;
					sum_color1 += *mask_pix;
				}
			}

			color[0] = (uint8)((sum_color0 + (sum_color1 / 255) / 2) / (sum_color1 / 255.0));

			// 描画する色を決定
			rev_alpha = 0xff-mix+1;
			blend_alpha = (uint8)(brush->alpha * 2.55);
			color[0] = (rev_alpha*blend_alpha+mix*color[0])>>8;

			// 現在の色を記憶
			brush->before_color[0] = color[0];

#ifdef _OPENMP
#pragma omp parallel for firstprivate(width, work_pixel, canvas_width, start_x, start_y)
#endif
			// 作業レイヤーに描画
			for(i=0; i<height; i++)
			{
				uint8 *ref_pix = &work_pixel[(i+start_y)*canvas_width+start_x];
				uint8 *mask_pix = &mask[(i+start_y)*canvas_width+start_x];
				uint8 *comp_pix = &window->brush_buffer[(i+start_y)*canvas_width+start_x];
				uint8 blend_alpha;
				int j;

				for(j=0; j<width; j++, ref_pix++, mask_pix++, comp_pix++)
				{
					*comp_pix = mask_pix[0];
					blend_alpha = ((mask_pix[0]+1)*(color[0])+(0xff-mask_pix[0]+1)*ref_pix[0])>>8;
					if(blend_alpha != 0)
					{
						ref_pix[0] = blend_alpha;
					}
				}
			}

			(void)memcpy(window->brush_buffer, mask, window->width*window->height);

			brush->draw_finished++;
		}
	}
}

static void WaterColorBrushMotionCallBack(
	DRAW_WINDOW* window,
	FLOAT_T x,
	FLOAT_T y,
	FLOAT_T pressure,
	BRUSH_CORE *core,
	void* state
)
{
	if(((*(GdkModifierType*)state) & GDK_BUTTON1_MASK) != 0)
	{
		WATER_COLOR_BRUSH *brush = (WATER_COLOR_BRUSH*)core->brush_data;
		FLOAT_T distance;
		int index = brush->ref_point % BRUSH_POINT_BUFFER_SIZE;

		distance = sqrt((x-brush->before_x)*(x-brush->before_x)+(y-brush->before_y)*(y-brush->before_y));

		if(distance >= 1.0)
		{
			brush->before_x = x, brush->before_y = y;
			brush->sum_distance += distance;
			brush->travel += distance;
			brush->points[index][0] = distance;
			brush->points[index][1] = x;
			brush->points[index][2] = y;
			brush->points[index][3] = pressure;
			brush->ref_point++;

			if(brush->sum_distance >= brush->draw_start
				&& brush->sum_distance >= brush->enter_length)
			{
				// 入りの色補正用
				FLOAT_T enter_alpha;
				// 更新範囲のイメージ情報
				cairo_t *update;
				cairo_surface_t *update_surface;
				// ブラシの半径と不透明度
				FLOAT_T r, alpha;
				// ブラシの拡大率
				FLOAT_T zoom;
				// ブラシの位置指定用
				cairo_matrix_t matrix;
				// 座標の最大・最小値
				FLOAT_T min_x, min_y, max_x, max_y;
				// X、Y方向の移動量
				FLOAT_T dx, dy;
				// ブラシの傾き用
				FLOAT_T diff_x, diff_y;
				// ブラシの移動量
				FLOAT_T d, step;
				// 描画を行う座標
				FLOAT_T draw_x = brush->before_x, draw_y = brush->before_y;
				// ピクセルデータをリセットする座標
				int start_x, start_y;
				// 描画する幅、高さ、一行分のバイト数
				int width, height;
				// 作業レイヤーの幅、高さ
				int layer_width = window->work_layer->width;
				int layer_height = window->work_layer->height;
				// 作業レイヤーの一行分のバイト数
				int layer_stride = window->work_layer->stride;
				// 作業レイヤーのピクセル
				uint8 *work_pixel = window->work_layer->pixels;
				// ブラシ位置のピクセル値合計
				unsigned int sum_color0 = 0, sum_color1 = 0, sum_color2 = 0,
					sum_color3 = 1, sum_color4 = 0, sum_color5 = 1;
				// 参照ピクセル
				uint8 *mask;
				uint8 *brush_buffer = window->brush_buffer;
				// αブレンド用
				int rev_alpha;
				uint8 blend_alpha;
				// バッファ更新用
				int clear_start_x, clear_start_y;
				int clear_width, clear_height;
				// 描画の要否判定
				gboolean skip_draw;
				// 描画する色
				int color[4];
				// 前回の色
				uint8 before_color[4];
				// 混色具合
				uint8 mix = (uint8)(brush->mix * 2.555);
				// 色延び具合
				uint8 extend = (uint8)(brush->extend * 2.555);
				// 配列のインデックス用
				int ref_point = brush->draw_finished % BRUSH_POINT_BUFFER_SIZE;
				int before_point;
				int i;	// for文用のカウンタ

				while(brush->sum_distance > brush->draw_start
					&& brush->draw_finished < brush->ref_point)
				{
					skip_draw = FALSE;

					if(brush->finish_length < brush->enter_length)
					{
						enter_alpha = brush->finish_length / brush->enter_length;
						r = brush->enter_size + brush->finish_length * 0.25;
					}
					else
					{
						enter_alpha = 1;
						r = brush->r;
					}
					if((brush->flags & BRUSH_FLAG_SIZE) != 0)
					{
						r *= brush->points[ref_point][3];
					}

					d = brush->points[ref_point][0];
					if(r > 0.5)
					{
						zoom = brush->r / r;
						step = r * BRUSH_STEP;
						if(step < 1)
						{
							step = 1;
						}
						alpha = ((brush->flags & BRUSH_FLAG_FLOW) == 0)
							? 1 : brush->points[ref_point][3];
						alpha *= enter_alpha;
						before_point = (ref_point == 0) ? BRUSH_POINT_BUFFER_SIZE - 1 : ref_point - 1;
						brush->sum_distance -= d;
						if(brush->draw_finished == 0)
						{
							draw_x = brush->points[0][1], draw_y = brush->points[0][2];
						}
						else
						{
							draw_x = brush->points[before_point][1], draw_y = brush->points[before_point][2];
						}
						dx = brush->points[ref_point][1] - draw_x;
						dy = brush->points[ref_point][2] - draw_y;
						diff_x = step * dx / d, diff_y = step * dy / d;

						min_x = brush->points[ref_point][1] - r - 1;
						max_x = brush->points[ref_point][1] + r + 1;
						min_y = brush->points[ref_point][2] - r - 1;
						max_y = brush->points[ref_point][2] + r + 1;
						if(min_x < 0.0)
						{
							min_x = 0.0;
						}
						if(core->min_x > min_x)
						{
							core->min_x = min_x;
						}
							if(min_y < 0.0)
						{
								min_y = 0.0;
						}
						if(core->min_y > min_y)
						{
							core->min_y = min_y;
						}
							if(max_x > window->work_layer->width)
						{
							max_x = window->work_layer->width;
						}
							if(core->max_x < max_x)
						{
							core->max_x = max_x;
						}
						if(max_y > window->work_layer->height)
						{
							min_y = window->work_layer->height;
						}
						if(core->max_y < max_y)
						{
							core->max_y = max_y;
						}

						if(window->update.x > min_x)
						{
							window->update.width += window->update.x - (int)min_x;
							window->update.x = (int)min_x;
						}
						if(window->update.width + window->update.x < max_x)
						{
							window->update.width += (int)max_x - window->update.width + window->update.x;
						}
						if(window->update.x + window->update.width > window->width)
						{
							window->update.width = window->width - window->update.x;
						}

						if(window->update.y > min_y)
						{
							window->update.height += window->update.y - (int)min_y;
							window->update.y = (int)min_y;
						}
						if(window->update.height + window->update.y < max_y)
						{
							window->update.height += (int)max_y - window->update.height + window->update.y;
						}
						if(window->update.y + window->update.height > window->height)
						{
							window->update.height = window->height - window->update.y;
						}

						dx = d;
						do
						{
							start_x = (int)(draw_x - r);
							start_y = (int)(draw_y - r);
							width = (int)(draw_x + r+1);
							height = (int)(draw_y + r+1);

							if(width < 0 || height < 0)
							{
								skip_draw = TRUE;
							}

							if(start_x < 0)
							{
								start_x = 0;
							}
							else if(start_x > window->work_layer->width)
							{
								skip_draw = TRUE;
							}
							if(start_y < 0)
							{
								start_y = 0;
							}
							else if(start_y > window->work_layer->height)
							{
								skip_draw = TRUE;
							}
							if(width > window->work_layer->width)
							{
								width = window->work_layer->width - start_x;
							}
							else
							{
								width = width - start_x;
							}
							if(height > window->work_layer->height)
							{
								height = window->work_layer->height - start_y;
							}
							else
							{
								height = height - start_y;
							}

							if(skip_draw == FALSE)
							{
								(void)memset(window->mask->pixels, 0, window->width*window->height);

								update_surface = cairo_surface_create_for_rectangle(
									window->alpha_surface, draw_x - r, draw_y - r, r*2+1, r*2+1);
								update = cairo_create(update_surface);

								mask = window->mask->pixels;
								cairo_set_operator(window->alpha_cairo, CAIRO_OPERATOR_OVER);
								if(window->app->textures.active_texture == 0)
								{
									if((window->flags & DRAW_WINDOW_HAS_SELECTION_AREA) == 0)
									{
										if((window->active_layer->flags & LAYER_LOCK_OPACITY) == 0)
										{
											cairo_matrix_init_scale(&matrix, zoom, zoom);
											cairo_pattern_set_matrix(core->brush_pattern, &matrix);
											cairo_set_source(update, core->brush_pattern);
											cairo_paint_with_alpha(update, alpha);
										}
										else
										{
											cairo_matrix_init_scale(&matrix, zoom, zoom);
											cairo_pattern_set_matrix(core->brush_pattern, &matrix);
											cairo_set_source(core->temp_cairo, core->brush_pattern);
											cairo_paint_with_alpha(core->temp_cairo, alpha);
											cairo_matrix_init_translate(&matrix, 0, 0);
											cairo_pattern_set_matrix(core->temp_pattern, &matrix);
											cairo_set_source(update, core->temp_pattern);
											cairo_mask_surface(update,
												window->active_layer->surface_p, - draw_x + r, - draw_y + r);
										}
									}
									else
									{
										if((window->active_layer->flags & LAYER_LOCK_OPACITY) == 0)
										{
											cairo_matrix_init_scale(&matrix, zoom, zoom);
											cairo_pattern_set_matrix(core->brush_pattern, &matrix);
											cairo_set_source(core->temp_cairo, core->brush_pattern);
											cairo_paint_with_alpha(core->temp_cairo, alpha);
											cairo_matrix_init_translate(&matrix, 0, 0);
											cairo_pattern_set_matrix(core->temp_pattern, &matrix);
											cairo_set_source(update, core->temp_pattern);
											cairo_mask_surface(update,
												window->selection->surface_p, - draw_x + r, - draw_y + r);
										}
										else
										{
											cairo_surface_t *temp_surface = cairo_surface_create_for_rectangle(
												window->alpha_temp, draw_x - r, draw_y - r, r*2+1, r*2+1);
											cairo_t *update_temp = cairo_create(temp_surface);

											cairo_matrix_init_scale(&matrix, zoom, zoom);
											cairo_pattern_set_matrix(core->brush_pattern, &matrix);
											cairo_set_source(core->temp_cairo, core->brush_pattern);
											cairo_paint_with_alpha(core->temp_cairo, alpha);
											cairo_matrix_init_translate(&matrix, 0, 0);
											cairo_pattern_set_matrix(core->temp_pattern, &matrix);
											cairo_set_source(update, core->temp_pattern);

											(void)memset(window->temp_layer->pixels, 0,
												window->width*window->height);

											cairo_mask_surface(update,
												window->selection->surface_p, 0, 0);
											cairo_set_source_surface(update_temp,
												update_surface, 0, 0);
											cairo_mask_surface(update_temp,
												window->active_layer->surface_p, - draw_x + r, - draw_y + r);

											mask = window->temp_layer->pixels;

											cairo_surface_destroy(temp_surface);
											cairo_destroy(update_temp);
										}
									}
								}
								else
								{
									cairo_surface_t *temp_surface = cairo_surface_create_for_rectangle(
										window->alpha_temp, draw_x - r, draw_y - r, r*2+1, r*2+1);
									cairo_t *update_temp = cairo_create(temp_surface);

									if((window->flags & DRAW_WINDOW_HAS_SELECTION_AREA) == 0)
									{
										if((window->active_layer->flags & LAYER_LOCK_OPACITY) == 0)
										{
											cairo_matrix_init_scale(&matrix, zoom, zoom);
											cairo_pattern_set_matrix(core->brush_pattern, &matrix);
											cairo_set_source(update, core->brush_pattern);
											cairo_paint_with_alpha(update, alpha);
										}
										else
										{
											cairo_matrix_init_scale(&matrix, zoom, zoom);
											cairo_pattern_set_matrix(core->brush_pattern, &matrix);
											cairo_set_source(core->temp_cairo, core->brush_pattern);
											cairo_paint_with_alpha(core->temp_cairo, alpha);
											cairo_matrix_init_translate(&matrix, 0, 0);
											cairo_pattern_set_matrix(core->temp_pattern, &matrix);
											cairo_set_source(update, core->temp_pattern);
											cairo_mask_surface(update,
												window->active_layer->surface_p, - draw_x + r, - draw_y + r);
										}

										cairo_set_source_surface(update_temp, update_surface, 0, 0);
										cairo_mask_surface(update_temp, window->texture->surface_p, - draw_x + r, - draw_y + r);

										mask = window->temp_layer->pixels;
									}
									else
									{
										if((window->active_layer->flags & LAYER_LOCK_OPACITY) == 0)
										{
											cairo_matrix_init_scale(&matrix, zoom, zoom);
											cairo_pattern_set_matrix(core->brush_pattern, &matrix);
											cairo_set_source(core->temp_cairo, core->brush_pattern);
											cairo_paint_with_alpha(core->temp_cairo, alpha);
											cairo_matrix_init_translate(&matrix, 0, 0);
											cairo_pattern_set_matrix(core->temp_pattern, &matrix);
											cairo_set_source(update, core->temp_pattern);
											cairo_mask_surface(update,
												window->selection->surface_p, - draw_x + r, - draw_y + r);

											cairo_set_source_surface(update_temp, update_surface, 0, 0);
											cairo_mask_surface(update_temp, window->texture->surface_p, - draw_x + r, - draw_y + r);

											mask = window->temp_layer->pixels;
										}
										else
										{
											cairo_matrix_init_scale(&matrix, zoom, zoom);
											cairo_pattern_set_matrix(core->brush_pattern, &matrix);
											cairo_set_source(core->temp_cairo, core->brush_pattern);
											cairo_paint_with_alpha(core->temp_cairo, alpha);
											cairo_matrix_init_translate(&matrix, 0, 0);
											cairo_pattern_set_matrix(core->temp_pattern, &matrix);
											cairo_set_source(update, core->temp_pattern);

											(void)memset(window->temp_layer->pixels, 0,
												window->width*window->height);

											cairo_mask_surface(update,
												window->selection->surface_p, 0, 0);
											cairo_set_source_surface(update_temp,
												update_surface, 0, 0);
											cairo_mask_surface(update_temp,
												window->active_layer->surface_p, - draw_x + r, - draw_y + r);

											cairo_set_operator(update, CAIRO_OPERATOR_SOURCE);
											cairo_set_source_surface(update, temp_surface, 0, 0);
											cairo_mask_surface(update, window->texture->surface_p, - draw_x + r, - draw_y + r);
										}
									}

									cairo_surface_destroy(temp_surface);
									cairo_destroy(update_temp);
								}

								cairo_surface_destroy(update_surface);
								cairo_destroy(update);

								sum_color0 = sum_color1 = sum_color2 = sum_color4 = 0;
								sum_color3 = sum_color5 = 1;

#ifdef _OPENMP
#pragma omp parallel for reduction( +: sum_color0, sum_color1, sum_color2, sum_color3, sum_color4, sum_color5) firstprivate(width, work_pixel, layer_width, layer_stride, start_x, start_y)
#endif
								for(i=0; i<height; i++)
								{
									uint8 *ref_pix = &work_pixel[(i+start_y)*layer_stride+start_x*4];
									uint8 *mask_pix = &mask[(i+start_y)*layer_width+start_x];
									int j;

									for(j=0; j<width; j++, ref_pix+=4, mask_pix++)
									{
										sum_color0 += ((ref_pix[0]+1) * *mask_pix * ref_pix[3]) >> 8;
										sum_color1 += ((ref_pix[1]+1) * *mask_pix * ref_pix[3]) >> 8;
										sum_color2 += ((ref_pix[2]+1) * *mask_pix * ref_pix[3]) >> 8;
										sum_color3 += ((ref_pix[3]+1) * *mask_pix) >> 8;
										sum_color4 += *mask_pix * ref_pix[3];
										sum_color5 += *mask_pix;
									}
								}

								color[0] = (sum_color0 + sum_color3 / 2) / sum_color3;
								if(color[0] > 0xff)
								{
									color[0] = 0xff;
								}
								color[1] = (sum_color1 + sum_color3 / 2) / sum_color3;
								if(color[1] > 0xff)
								{
									color[1] = 0xff;
								}
								color[2] = (sum_color2 + sum_color3 / 2) / sum_color3;
								if(color[2] > 0xff)
								{
									color[2] = 0xff;
								}
								color[3] = (uint8)((sum_color4) / sum_color5);

								// 描画する色を決定
								rev_alpha = 0xff-mix+1;
								blend_alpha = (uint8)(brush->alpha * 2.55);
#if defined(USE_BGR_COLOR_SPACE) && USE_BGR_COLOR_SPACE != 0
								color[0] = (rev_alpha*(*core->color)[2]+(mix+1)*color[0])>>8;
								color[1] = (rev_alpha*(*core->color)[1]+(mix+1)*color[1])>>8;
								color[2] = (rev_alpha*(*core->color)[0]+(mix+1)*color[2])>>8;
								color[3] = (rev_alpha*blend_alpha+(mix+1)*color[3])>>8;
#else
								color[0] = (rev_alpha*(*core->color)[0]+(mix+1)*color[0])>>8;
								color[1] = (rev_alpha*(*core->color)[1]+(mix+1)*color[1])>>8;
								color[2] = (rev_alpha*(*core->color)[2]+(mix+1)*color[2])>>8;
								color[3] = (rev_alpha*blend_alpha+(mix+1)*color[3])>>8;
#endif

								before_color[0] = color[0];
								before_color[1] = color[1];
								before_color[2] = color[2];
								before_color[3] = color[3];

								if(extend != 0 && ref_point != 0)
								{
									rev_alpha = 0xff-extend+1;
									color[0] = (rev_alpha*color[0]+(extend+1)*brush->before_color[0])>>8;
									color[1] = (rev_alpha*color[1]+(extend+1)*brush->before_color[1])>>8;
									color[2] = (rev_alpha*color[2]+(extend+1)*brush->before_color[2])>>8;
									color[3] = (rev_alpha*color[3]+(extend+1)*brush->before_color[3])>>8;
								}

								// 現在の色を記憶
								brush->before_color[0] = before_color[0];
								brush->before_color[1] = before_color[1];
								brush->before_color[2] = before_color[2];
								brush->before_color[3] = before_color[3];

#define CLEAR_MARGINE 3
								//	αブレンド用のバッファを更新
								if(draw_x > brush->last_draw_x)
								{
									clear_start_x = (int)(brush->last_draw_x - brush->r * CLEAR_MARGINE);
									clear_width = (int)(draw_x + brush->r * CLEAR_MARGINE);
								}
								else
								{
									clear_start_x = (int)(draw_x - brush->r * CLEAR_MARGINE);
									clear_width = (int)(brush->last_draw_x + brush->r * CLEAR_MARGINE);
								}

								if(clear_start_x < 0)
								{
									clear_start_x = 0;
								}
								if(clear_width > window->width)
								{
									clear_width = window->width;
								}
								clear_width = clear_width - clear_start_x;

								if(draw_y > brush->last_draw_y)
								{
									clear_start_y = (int)(brush->last_draw_y - brush->r * CLEAR_MARGINE);
									clear_height = (int)(draw_y - brush->r * CLEAR_MARGINE);
								}
								else
								{
									clear_start_y = (int)(draw_y - brush->r * CLEAR_MARGINE);
									clear_height = (int)(brush->last_draw_y + brush->r * CLEAR_MARGINE);
								}

								if(clear_start_y < 0)
								{
									clear_start_y = 0;
								}
								if(clear_height > window->height)
								{
									clear_height = window->height;
								}

								for(i=clear_start_y; i<clear_height; i++)
								{
									(void)memset(&mask[window->width*window->height+i*window->width+clear_start_x],
										0, clear_width);
								}
								for(i=0; i<height; i++)
								{
									(void)memcpy(&mask[window->width*window->height+(i+start_y)*window->width+start_x],
										&window->brush_buffer[(i+start_y)*window->width+start_x], width);
								}
#undef CLEAR_MARGINE

#define COLOR_MARGINE 1

#ifdef _OPENMP
#pragma omp parallel for firstprivate(width, work_pixel, layer_width, layer_height, layer_stride, start_x, start_y, brush_buffer)
#endif
								for(i=0; i<height; i++)
								{
									uint8 *ref_pix = &work_pixel[(i+start_y)*layer_stride+start_x*4];
									uint8 *comp_pix = &brush_buffer[(i+start_y)*layer_width+start_x];
									uint8 *alpha_pix = &mask[(i+start_y)*layer_width+start_x];
									uint8 *memory_pix = &mask[layer_width*layer_height+(i+start_y)*layer_width+start_x];
									uint8 blend_alpha;
									uint8 mask_value;
									int j;

									for(j=0; j<width; j++, ref_pix+=4, comp_pix++, alpha_pix++, memory_pix++)
									{
										mask_value = *alpha_pix;

										if(mask_value > *comp_pix)
										{
											*memory_pix = mask_value;

											blend_alpha /*= dst_value*/ = (mask_value - *comp_pix);
											*comp_pix = mask_value;
											ref_pix[3] = ((blend_alpha+1)*color[3]+(0xff-blend_alpha+1)*ref_pix[3])>>8;
												blend_alpha = MINIMUM(ref_pix[3]*2, 0xff);

											ref_pix[0] = (uint8)MINIMUM(
												(((mask_value+1)*color[0]+(0xff-mask_value+1)*ref_pix[0])>>8), blend_alpha);
											ref_pix[1] = (uint8)MINIMUM(
												(((mask_value+1)*color[1]+(0xff-mask_value+1)*ref_pix[1])>>8), blend_alpha);
											ref_pix[2] = (uint8)MINIMUM(
												(((mask_value+1)*color[2]+(0xff-mask_value+1)*ref_pix[2])>>8), blend_alpha);
										}
									}
								}

								for(i=clear_start_y; i<clear_height; i++)
								{
									(void)memcpy(&window->brush_buffer[i*window->width+clear_start_x],
										&mask[window->width*window->height+i*window->width+clear_start_x], clear_width);
								}
								brush->last_draw_x = draw_x, brush->last_draw_y = draw_y;
							}

							dx -= step;
							if(dx < 1)
							{
								skip_draw = TRUE;
							}
							else
							{
								skip_draw = FALSE;
								if(dx >= step)
								{
									draw_x += diff_x, draw_y += diff_y;
								}
								else
								{
									draw_x = brush->points[ref_point][1];
									draw_y = brush->points[ref_point][2];
								}
							}
						} while(skip_draw == FALSE);
					}

					brush->finish_length += d;
					brush->travel += d;
					brush->draw_finished++;
					ref_point = brush->draw_finished % BRUSH_POINT_BUFFER_SIZE;
				}	// while(brush->sum_distance >= brush->draw_start)
			}	// if(brush->sum_distance >= brush->draw_start
					// && brush->sum_distance >= brush->enter_length)
		}	// if(distance >= 1.0)
	}

	window->flags |= DRAW_WINDOW_UPDATE_PART;
}

static void WaterColorBrushEditSelectionMotionCallBack(
	DRAW_WINDOW* window,
	FLOAT_T x,
	FLOAT_T y,
	FLOAT_T pressure,
	BRUSH_CORE *core,
	void* state
)
{
	if(((*(GdkModifierType*)state) & GDK_BUTTON1_MASK) != 0)
	{
		WATER_COLOR_BRUSH *brush = (WATER_COLOR_BRUSH*)core->brush_data;
		FLOAT_T distance;
		int index = brush->ref_point % BRUSH_POINT_BUFFER_SIZE;

		distance = sqrt((x-brush->before_x)*(x-brush->before_x)+(y-brush->before_y)*(y-brush->before_y));

		if(distance >= 1.0)
		{
			brush->before_x = x, brush->before_y = y;
			brush->sum_distance += distance;
			brush->travel += distance;
			brush->points[index][0] = distance;
			brush->points[index][1] = x;
			brush->points[index][2] = y;
			brush->points[index][3] = pressure;
			brush->ref_point++;

			if(brush->sum_distance >= brush->draw_start
				&& brush->sum_distance >= brush->enter_length)
			{
				// 入りの色補正用
				FLOAT_T enter_alpha;
				// ブラシの半径と不透明度
				FLOAT_T r, alpha;
				// ブラシの拡大率
				FLOAT_T zoom;
				// ブラシの座標指定用
				cairo_matrix_t matrix;
				// 座標の最大・最小値
				FLOAT_T min_x, min_y, max_x, max_y;
				// X、Y方向の移動量
				FLOAT_T dx, dy;
				// ブラシの傾き用
				FLOAT_T diff_x, diff_y;
				// ブラシの移動量
				FLOAT_T d, step;
				// 描画を行う座標
				FLOAT_T draw_x = brush->before_x, draw_y = brush->before_y;
				// ピクセルデータをリセットする座標
				int start_x, start_y;
				// 描画する幅、高さ
				int width, height;
				// キャンバスの幅
				int canvas_width = window->width;
				// 作業レイヤーのピクセル
				uint8 *work_pixel = window->work_layer->pixels;
				// ブラシ位置のピクセル値合計
				unsigned int sum_color0 = 0, sum_color1 = 0;
				// 描画の要否判定
				gboolean skip_draw;
				// 参照ピクセル
				uint8 *mask;
				uint8 *brush_buffer = window->brush_buffer;
				int rev_alpha;
				uint8 blend_alpha;
				FLOAT_T inv_alpha;
				// 描画する色
				uint8 color[2];
				// 混色具合
				uint8 mix = (uint8)(brush->mix * 2.55);
				// 色延び具合
				uint8 extend = (uint8)(brush->extend * 2.55);
				// 配列のインデックス用
				int ref_point = brush->draw_finished % BRUSH_POINT_BUFFER_SIZE;
				int before_point;
				int i;	// for文用のカウンタ

				while(brush->sum_distance > brush->draw_start
					&& brush->draw_finished < brush->ref_point)
				{
					if(brush->finish_length < brush->enter_length)
					{
						enter_alpha = brush->finish_length / brush->enter_length;
						r = brush->enter_size + brush->finish_length * 0.25;
					}
					else
					{
						enter_alpha = 1;
						r = brush->r;
					}
					if((brush->flags & BRUSH_FLAG_SIZE) != 0)
					{
						r *= brush->points[ref_point][3];
					}

					d = brush->points[ref_point][0];
					if(r > 0.5)
					{
						zoom = brush->r / r;
						step = r * BRUSH_STEP;
						if(step < 1)
						{
							step = 1;
						}
						alpha = ((brush->flags & BRUSH_FLAG_FLOW) == 0)
							? 1 : brush->points[ref_point][3];
						alpha *= enter_alpha;
						before_point = (ref_point == 0) ? BRUSH_POINT_BUFFER_SIZE - 1 : ref_point - 1;
						brush->sum_distance -= d;
						if(brush->draw_finished == 0)
						{
							draw_x = brush->points[0][1], draw_y = brush->points[0][2];
						}
						else
						{
							draw_x = brush->points[before_point][1], draw_y = brush->points[before_point][2];
						}
						dx = brush->points[ref_point][1] - draw_x;
						dy = brush->points[ref_point][2] - draw_y;
						diff_x = step * dx / d, diff_y = step * dy / d;

						min_x = brush->points[ref_point][1] - r - 1;
						max_x = brush->points[ref_point][1] + r + 1;
						min_y = brush->points[ref_point][2] - r - 1;
						max_y = brush->points[ref_point][2] + r + 1;
						if(min_x < 0.0)
						{
							min_x = 0.0;
						}
						if(core->min_x > min_x)
						{
							core->min_x = min_x;
						}
						if(min_y < 0.0)
						{
							min_y = 0.0;
						}
						if(core->min_y > min_y)
						{
							core->min_y = min_y;
						}
						if(max_x > window->work_layer->width)
						{
							max_x = window->work_layer->width;
						}
						if(core->max_x < max_x)
						{
							core->max_x = max_x;
						}
						if(max_y > window->work_layer->height)
						{
							min_y = window->work_layer->height;
						}
						if(core->max_y < max_y)
						{
							core->max_y = max_y;
						}

						dx = d;
						do
						{
							skip_draw = FALSE;

							start_x = (int)(draw_x - r);
							start_y = (int)(draw_y - r);
							width = (int)(draw_x + r);
							height = (int)(draw_y + r);

							if(start_x < 0)
							{
								start_x = 0;
							}
							else if(start_x > window->work_layer->width)
							{
								skip_draw = TRUE;
							}
							if(start_y < 0)
							{
								start_y = 0;
							}
							else if(start_y > window->work_layer->height)
							{
								skip_draw = TRUE;
							}
							if(width > window->work_layer->width)
							{
								width = window->work_layer->width - start_x;
							}
							else
							{
								width = width - start_x;
							}
							if(height > window->work_layer->height)
							{
								height = window->work_layer->height - start_y;
							}
							else
							{
								height = height - start_y;
							}

							if(skip_draw == FALSE)
							{
								(void)memset(window->mask->pixels, 0, window->width*window->height);

								mask = window->mask->pixels;
								cairo_set_operator(window->alpha_cairo, CAIRO_OPERATOR_OVER);
								if((window->flags & DRAW_WINDOW_HAS_SELECTION_AREA) == 0)
								{
									if((window->active_layer->flags & LAYER_LOCK_OPACITY) == 0)
									{
										cairo_matrix_init_scale(&matrix, zoom, zoom);
										cairo_matrix_translate(&matrix, - draw_x + r, - draw_y + r);
										cairo_pattern_set_matrix(core->brush_pattern, &matrix);
										cairo_set_source(window->alpha_cairo, core->brush_pattern);
										cairo_paint_with_alpha(window->alpha_cairo, alpha);
									}
									else
									{
										cairo_matrix_init_scale(&matrix, zoom, zoom);
										cairo_pattern_set_matrix(core->brush_pattern, &matrix);
										cairo_set_source(core->temp_cairo, core->brush_pattern);
										cairo_paint_with_alpha(core->temp_cairo, alpha);
										cairo_matrix_init_translate(&matrix, - draw_x + r, - draw_y + r);
										cairo_pattern_set_matrix(core->temp_pattern, &matrix);
										cairo_set_source(window->alpha_cairo, core->temp_pattern);
										cairo_mask_surface(window->alpha_cairo,
											window->active_layer->surface_p, 0, 0);
									}
								}
								else
								{
									if((window->active_layer->flags & LAYER_LOCK_OPACITY) == 0)
									{
										cairo_matrix_init_scale(&matrix, zoom, zoom);
										cairo_pattern_set_matrix(core->brush_pattern, &matrix);
										cairo_set_source(core->temp_cairo, core->brush_pattern);
										cairo_paint_with_alpha(core->temp_cairo, alpha);
										cairo_matrix_init_translate(&matrix, - draw_x + r, - draw_y + r);
										cairo_pattern_set_matrix(core->temp_pattern, &matrix);
										cairo_set_source(window->alpha_cairo, core->temp_pattern);
										cairo_mask_surface(window->alpha_cairo,
											window->selection->surface_p, 0, 0);
									}
									else
									{
										cairo_matrix_init_scale(&matrix, zoom, zoom);
										cairo_pattern_set_matrix(core->brush_pattern, &matrix);
										cairo_set_source(core->temp_cairo, core->brush_pattern);
										cairo_paint_with_alpha(core->temp_cairo, alpha);
										cairo_matrix_init_translate(&matrix, - x + r, - y + r);
										cairo_pattern_set_matrix(core->temp_pattern, &matrix);
										cairo_set_source(window->alpha_cairo, core->temp_pattern);

										(void)memset(window->temp_layer->pixels, 0, window->width*window->height);

										cairo_mask_surface(window->alpha_cairo,
											window->selection->surface_p, 0, 0);
										cairo_set_source_surface(window->alpha_temp_cairo,
											window->alpha_surface, 0, 0);
										cairo_mask_surface(window->alpha_temp_cairo,
											window->active_layer->surface_p, 0, 0);

										mask = window->temp_layer->pixels;
									}
								}

								sum_color0 = sum_color1 = 1;

#ifdef _OPENMP
#pragma omp parallel for reduction( +: sum_color0, sum_color1) firstprivate(width, work_pixel, canvas_width, start_x, start_y)
#endif
								for(i=0; i<height; i++)
								{
									uint8 *ref_pix = &work_pixel[(i+start_y)*canvas_width+start_x];
									uint8 *mask_pix = &mask[(i+start_y)*canvas_width+start_x];
									int j;

									for(j=0; j<width; j++, ref_pix++, mask_pix++)
									{
										sum_color0 += ((ref_pix[0]+1) * *mask_pix) >> 8;
										sum_color1 += *mask_pix;
									}
								}

								color[0] = (uint8)((sum_color0 + (sum_color1 / 255) / 2) / (sum_color1 / 255.0));

								// 描画する色を決定
								rev_alpha = 0xff-mix+1;
								blend_alpha = (uint8)(brush->alpha * 2.55);
								color[0] = (rev_alpha*blend_alpha+mix*color[0])>>8;

								if(extend != 0 && ref_point != 0)
								{
									rev_alpha = 0xff-extend+1;
									color[0] = (rev_alpha*color[0]+extend*brush->before_color[0])>>8;
								}

								// 現在の色を記憶
								brush->before_color[0] = color[0];
								inv_alpha = color[0] * DIV_PIXEL;

#ifdef _OPENMP
#pragma omp parallel for firstprivate(width, work_pixel, canvas_width, start_x, start_y, brush_buffer)
#endif
								for(i=0; i<height; i++)
								{
									uint8 *ref_pix = &work_pixel[(i+start_y)*canvas_width+start_x];
									uint8 *comp_pix = &brush_buffer[(i+start_y)*canvas_width+start_x];
									uint8 *alpha_pix = &mask[(i+start_y)*canvas_width+start_x];
									uint8 mask_value;
									int j;

									for(j=0; j<width; j++, ref_pix++, comp_pix++, alpha_pix++)
									{
										mask_value = *alpha_pix;
										*alpha_pix = (uint8)(*alpha_pix * inv_alpha);

										if(mask_value > 0)
										{
											if(mask_value == 0xff)
											{
												ref_pix[0] = *alpha_pix;
											}
											else
											{
												ref_pix[0] = (mask_value > ref_pix[0]) ? *alpha_pix : ref_pix[0];
											}
										}
									}
								}
								(void)memcpy(window->brush_buffer, mask, window->width*window->height);

							}

							dx -= step;
							if(dx < 1)
							{
								skip_draw = TRUE;
							}
							else
							{
								skip_draw = FALSE;
								if(dx >= step)
								{
									draw_x += diff_x, draw_y += diff_y;
								}
								else
								{
									draw_x = brush->points[before_point][1];
									draw_y = brush->points[before_point][2];
								}
							}
						} while(skip_draw == FALSE);
					}

					brush->finish_length += d;
					brush->travel += d;
					brush->draw_finished++;
					ref_point = brush->draw_finished % BRUSH_POINT_BUFFER_SIZE;
				}	// while(brush->sum_distance >= brush->draw_start)
			}	// if(brush->sum_distance >= brush->draw_start
					// && brush->sum_distance >= brush->enter_length)
		}	// if(distance >= 1.0)
	}
}

static void WaterColorBrushReleaseCallBack(
	DRAW_WINDOW* window,
	FLOAT_T x,
	FLOAT_T y,
	FLOAT_T pressure,
	BRUSH_CORE *core,
	void* state
)
{
	// 左クリックならば
	if(((GdkEventButton*)state)->button == 1)
	{
		WATER_COLOR_BRUSH *brush = (WATER_COLOR_BRUSH*)core->brush_data;
		cairo_t *update;
		cairo_surface_t *update_surface;
		FLOAT_T r, alpha;
		// 座標の最大・最小値
		FLOAT_T min_x, min_y, max_x, max_y;
		// X、Y方向の移動量
		FLOAT_T dx, dy;
		// ブラシの傾き用
		FLOAT_T diff_x, diff_y;
		// ブラシの拡大率
		FLOAT_T zoom;
		// ブラシの座標指定用
		cairo_matrix_t matrix;
		// ブラシの移動量
		FLOAT_T d, step;
		// 描画を行う座標
		FLOAT_T draw_x, draw_y;
		// 入り、抜き時の色補正
		FLOAT_T enter_alpha, out_alpha;
		// ピクセルデータをリセットする座標
		int start_x, start_y;
		// 描画する幅、高さ
		int width, height;
		// 作業レイヤーの幅、高さ
		int layer_width = window->work_layer->width;
		int layer_height = window->work_layer->height;
		// 作業レイヤーの一行分のバイト数
		int layer_stride = window->work_layer->stride;
		// 作業レイヤーのピクセル
		uint8 *work_pixel = window->work_layer->pixels;
		// ブラシ位置のピクセル値合計
		unsigned int sum_color0 = 0, sum_color1 = 0, sum_color2 = 0,
			sum_color3 = 1, sum_color4 = 0, sum_color5 = 1;
		// 参照ピクセル
		uint8 *mask;
		uint8 *brush_buffer = window->brush_buffer;
		// 描画の要否判定用
		gboolean skip_draw;
		// αブレンド用
		int rev_alpha;
		uint8 blend_alpha;
		// バッファ更新用
		int clear_start_x, clear_start_y;
		int clear_width, clear_height;
		// 描画する色
		int color[4];
		// 混色具合
		uint8 mix = (uint8)(brush->mix * 2.55);
		// 色延び具合
		uint8 extend = (uint8)(brush->extend * 2.55);
		// 配列のインデックス用
		int ref_point;
		int before_point;
		int i;	// for文用のカウンタ

		while(brush->ref_point > brush->draw_finished)
		{
			ref_point = brush->draw_finished % BRUSH_POINT_BUFFER_SIZE;

			if(brush->finish_length < brush->enter_length)
			{
				enter_alpha = brush->finish_length / brush->enter_length;
				r = brush->enter_size + brush->finish_length * 0.25;
			}
			else
			{
				enter_alpha = 1;
				r = brush->r;
			}
			if(brush->sum_distance < brush->draw_start)
			{
				out_alpha = brush->sum_distance / brush->draw_start;
				r -= (brush->draw_start - brush->sum_distance) * 0.25;
			}
			else
			{
				out_alpha = 1;
			}
			
			if((brush->flags & BRUSH_FLAG_SIZE) != 0)
			{
				r *= brush->points[ref_point][3];
			}

			if(r < 0.5)
			{
				brush->draw_finished++;
				continue;
			}

			zoom = brush->r / r;
			step = r * BRUSH_STEP;
			if(step < 1)
			{
				step = 1;
			}
			alpha = ((brush->flags & BRUSH_FLAG_FLOW) == 0)
				? 1 : brush->points[ref_point][3];
			alpha *= enter_alpha;
			before_point = (ref_point == 0) ? BRUSH_POINT_BUFFER_SIZE - 1 : ref_point - 1;
			d = brush->points[ref_point][0];
			brush->sum_distance -= d;
			if(brush->draw_finished == 0)
			{
				draw_x = brush->points[0][1], draw_y = brush->points[0][2];
			}
			else
			{
				draw_x = brush->points[before_point][1], draw_y = brush->points[before_point][2];
			}
			dx = brush->points[ref_point][1] - draw_x;
			dy = brush->points[ref_point][2] - draw_y;
			diff_x = step * dx / d, diff_y = step * dy / d;

			min_x = brush->points[ref_point][1] - r - 1;
			max_x = brush->points[ref_point][1] + r + 1;
			min_y = brush->points[ref_point][2] - r - 1;
			max_y = brush->points[ref_point][2] + r + 1;
			if(min_x < 0.0)
			{
				min_x = 0.0;
			}
			if(core->min_x > min_x)
			{
				core->min_x = min_x;
			}
			
			if(min_y < 0.0)
			{
				min_y = 0.0;
			}
			if(core->min_y > min_y)
			{
				core->min_y = min_y;
			}
			if(max_x > window->work_layer->width)
			{
				max_x = window->work_layer->width;
			}
			if(core->max_x < max_x)
			{
				core->max_x = max_x;
			}
			if(max_y > window->work_layer->height)
			{
				min_y = window->work_layer->height;
			}
			if(core->max_y < max_y)
			{
				core->max_y = max_y;
			}

			if(window->update.x > min_x)
			{
				window->update.width += window->update.x - (int)min_x;
				window->update.x = (int)min_x;
			}
			if(window->update.width + window->update.x < max_x)
			{
				window->update.width += (int)max_x - window->update.width + window->update.x;
			}
			if(window->update.y > min_y)
			{
				window->update.height += window->update.y - (int)min_y;
				window->update.y = (int)min_y;
			}
			if(window->update.height + window->update.y < max_y)
			{
				window->update.height += (int)max_y - window->update.height + window->update.y;
			}

			dx = d;
			do
			{
				skip_draw = FALSE;

				start_x = (int)(draw_x - r);
				start_y = (int)(draw_y - r);
				width = (int)(draw_x + r);
				height = (int)(draw_y + r);

				if(width < 0 || height < 0)
				{
					skip_draw = TRUE;
				}

				if(start_x < 0)
				{
					start_x = 0;
				}
				else if(start_x > window->work_layer->width)
				{
					skip_draw = TRUE;
				}
				if(start_y < 0)
				{
					start_y = 0;
				}
				else if(start_y > window->work_layer->height)
				{
					skip_draw = TRUE;
				}
				if(width > window->work_layer->width)
				{
					width = window->work_layer->width - start_x;
				}
				else
				{
					width = width - start_x;
				}
				if(height > window->work_layer->height)
				{
					height = window->work_layer->height - start_y;
				}
				else
				{
					height = height - start_y;
				}

				if(skip_draw == FALSE)
				{
					(void)memset(window->mask->pixels, 0, window->width*window->height);

					update_surface = cairo_surface_create_for_rectangle(
						window->alpha_surface, draw_x - r, draw_y - r, r*2+1, r*2+1);
					update = cairo_create(update_surface);

					mask = window->mask->pixels;
					cairo_set_operator(window->alpha_cairo, CAIRO_OPERATOR_OVER);
					if(window->app->textures.active_texture == 0)
					{
						if((window->flags & DRAW_WINDOW_HAS_SELECTION_AREA) == 0)
						{
							if((window->active_layer->flags & LAYER_LOCK_OPACITY) == 0)
							{
								cairo_matrix_init_scale(&matrix, zoom, zoom);
								cairo_pattern_set_matrix(core->brush_pattern, &matrix);
								cairo_set_source(update, core->brush_pattern);
								cairo_paint_with_alpha(update, alpha);
							}
							else
							{
								cairo_matrix_init_scale(&matrix, zoom, zoom);
								cairo_pattern_set_matrix(core->brush_pattern, &matrix);
								cairo_set_source(core->temp_cairo, core->brush_pattern);
								cairo_paint_with_alpha(core->temp_cairo, alpha);
								cairo_matrix_init_translate(&matrix, 0, 0);
								cairo_pattern_set_matrix(core->temp_pattern, &matrix);
								cairo_set_source(update, core->temp_pattern);
								cairo_mask_surface(update,
									window->active_layer->surface_p, - draw_x + r, - draw_y + r);
							}
						}
						else
						{
							if((window->active_layer->flags & LAYER_LOCK_OPACITY) == 0)
							{
								cairo_matrix_init_scale(&matrix, zoom, zoom);
								cairo_pattern_set_matrix(core->brush_pattern, &matrix);
								cairo_set_source(core->temp_cairo, core->brush_pattern);
								cairo_paint_with_alpha(core->temp_cairo, alpha);
								cairo_matrix_init_translate(&matrix, 0, 0);
								cairo_pattern_set_matrix(core->temp_pattern, &matrix);
								cairo_set_source(update, core->temp_pattern);
								cairo_mask_surface(update,
									window->selection->surface_p, - draw_x + r, - draw_y + r);
							}
							else
							{
								cairo_surface_t *temp_surface = cairo_surface_create_for_rectangle(
									window->alpha_temp, draw_x - r, draw_y - r, r*2+1, r*2+1);
								cairo_t *update_temp = cairo_create(temp_surface);

								cairo_matrix_init_scale(&matrix, zoom, zoom);
								cairo_pattern_set_matrix(core->brush_pattern, &matrix);
								cairo_set_source(core->temp_cairo, core->brush_pattern);
								cairo_paint_with_alpha(core->temp_cairo, alpha);
								cairo_matrix_init_translate(&matrix, 0, 0);
								cairo_pattern_set_matrix(core->temp_pattern, &matrix);
								cairo_set_source(update, core->temp_pattern);

								(void)memset(window->temp_layer->pixels, 0,
									window->width*window->height);

								cairo_mask_surface(update,
									window->selection->surface_p, 0, 0);
								cairo_set_source_surface(update_temp,
									update_surface, 0, 0);
								cairo_mask_surface(update_temp,
									window->active_layer->surface_p, - draw_x + r, - draw_y + r);

								mask = window->temp_layer->pixels;

								cairo_surface_destroy(temp_surface);
								cairo_destroy(update_temp);
							}
						}
					}
					else
					{
						cairo_surface_t *temp_surface = cairo_surface_create_for_rectangle(
							window->alpha_temp, draw_x - r, draw_y - r, r*2+1, r*2+1);
						cairo_t *update_temp = cairo_create(temp_surface);

						if((window->flags & DRAW_WINDOW_HAS_SELECTION_AREA) == 0)
						{
							if((window->active_layer->flags & LAYER_LOCK_OPACITY) == 0)
							{
								cairo_matrix_init_scale(&matrix, zoom, zoom);
								cairo_pattern_set_matrix(core->brush_pattern, &matrix);
								cairo_set_source(update, core->brush_pattern);
								cairo_paint_with_alpha(update, alpha);
							}
							else
							{
								cairo_matrix_init_scale(&matrix, zoom, zoom);
								cairo_pattern_set_matrix(core->brush_pattern, &matrix);
								cairo_set_source(core->temp_cairo, core->brush_pattern);
								cairo_paint_with_alpha(core->temp_cairo, alpha);
								cairo_matrix_init_translate(&matrix, 0, 0);
								cairo_pattern_set_matrix(core->temp_pattern, &matrix);
								cairo_set_source(update, core->temp_pattern);
								cairo_mask_surface(update,
									window->active_layer->surface_p, - draw_x + r, - draw_y + r);
							}

							cairo_set_source_surface(update_temp, update_surface, 0, 0);
							cairo_mask_surface(update_temp, window->texture->surface_p, - draw_x + r, - draw_y + r);

							mask = window->temp_layer->pixels;
						}
						else
						{
							if((window->active_layer->flags & LAYER_LOCK_OPACITY) == 0)
							{
								cairo_matrix_init_scale(&matrix, zoom, zoom);
								cairo_pattern_set_matrix(core->brush_pattern, &matrix);
								cairo_set_source(core->temp_cairo, core->brush_pattern);
								cairo_paint_with_alpha(core->temp_cairo, alpha);
								cairo_matrix_init_translate(&matrix, 0, 0);
								cairo_pattern_set_matrix(core->temp_pattern, &matrix);
								cairo_set_source(update, core->temp_pattern);
								cairo_mask_surface(update,
									window->selection->surface_p, - draw_x + r, - draw_y + r);

								cairo_set_source_surface(update_temp, update_surface, 0, 0);
								cairo_mask_surface(update_temp, window->texture->surface_p, - draw_x + r, - draw_y + r);

								mask = window->temp_layer->pixels;
							}
							else
							{
								cairo_matrix_init_scale(&matrix, zoom, zoom);
								cairo_pattern_set_matrix(core->brush_pattern, &matrix);
								cairo_set_source(core->temp_cairo, core->brush_pattern);
								cairo_paint_with_alpha(core->temp_cairo, alpha);
								cairo_matrix_init_translate(&matrix, 0, 0);
								cairo_pattern_set_matrix(core->temp_pattern, &matrix);
								cairo_set_source(update, core->temp_pattern);

								(void)memset(window->temp_layer->pixels, 0,
									window->width*window->height);

								cairo_mask_surface(update,
									window->selection->surface_p, 0, 0);
								cairo_set_source_surface(update_temp,
									update_surface, 0, 0);
								cairo_mask_surface(update_temp,
									window->active_layer->surface_p, - draw_x + r, - draw_y + r);

								cairo_set_operator(update, CAIRO_OPERATOR_SOURCE);
								cairo_set_source_surface(update, temp_surface, 0, 0);
								cairo_mask_surface(update, window->texture->surface_p, - draw_x + r, - draw_y + r);
							}
						}

						cairo_surface_destroy(temp_surface);
						cairo_destroy(update_temp);
					}

					cairo_surface_destroy(update_surface);
					cairo_destroy(update);

					sum_color0 = sum_color1 = sum_color2 = sum_color4 = 0;
					sum_color3 = sum_color5 = 1;

#ifdef _OPENMP
#pragma omp parallel for reduction( +: sum_color0, sum_color1, sum_color2, sum_color3, sum_color4, sum_color5) firstprivate(width, work_pixel, layer_width, layer_stride, start_x, start_y)
#endif
					for(i=0; i<height; i++)
					{
						uint8 *ref_pix = &work_pixel[(i+start_y)*layer_stride+start_x*4];
						uint8 *mask_pix = &mask[(i+start_y)*layer_width+start_x];
						int j;

						for(j=0; j<width; j++, ref_pix+=4, mask_pix++)
						{
							sum_color0 += ((ref_pix[0]+1) * *mask_pix * ref_pix[3]) >> 8;
							sum_color1 += ((ref_pix[1]+1) * *mask_pix * ref_pix[3]) >> 8;
							sum_color2 += ((ref_pix[2]+1) * *mask_pix * ref_pix[3]) >> 8;
							sum_color3 += ((ref_pix[3]+1) * *mask_pix) >> 8;
							sum_color4 += ref_pix[3] * *mask_pix;
							sum_color5 += *mask_pix;
						}
					}

					color[0] = (sum_color0 + sum_color3 / 2) / sum_color3;
					if(color[0] > 0xff)
					{
						color[0] = 0xff;
					}
					color[1] = (sum_color1 + sum_color3 / 2) / sum_color3;
					if(color[1] > 0xff)
					{
						color[1] = 0xff;
					}
					color[2] = (sum_color2 + sum_color3 / 2) / sum_color3;
					if(color[2] > 0xff)
					{
						color[2] = 0xff;
					}
					color[3] = (uint8)(sum_color4 / sum_color5);

					// 描画する色を決定
					rev_alpha = 0xff-mix+1;
					blend_alpha = (uint8)(brush->alpha * 2.55);
#if defined(USE_BGR_COLOR_SPACE) && USE_BGR_COLOR_SPACE != 0
					color[0] = (rev_alpha*(*core->color)[2]+mix*color[0])>>8;
					color[1] = (rev_alpha*(*core->color)[1]+mix*color[1])>>8;
					color[2] = (rev_alpha*(*core->color)[0]+mix*color[2])>>8;
					color[3] = (rev_alpha*blend_alpha+mix*color[3])>>8;
#else
					color[0] = (rev_alpha*(*core->color)[0]+mix*color[0])>>8;
					color[1] = (rev_alpha*(*core->color)[1]+mix*color[1])>>8;
					color[2] = (rev_alpha*(*core->color)[2]+mix*color[2])>>8;
					color[3] = (rev_alpha*blend_alpha+mix*color[3])>>8;
#endif

					if(extend != 0 && ref_point != 0)
					{
						rev_alpha = 0xff-extend+1;
						color[0] = (rev_alpha*color[0]+extend*brush->before_color[0])>>8;
						color[1] = (rev_alpha*color[1]+extend*brush->before_color[1])>>8;
						color[2] = (rev_alpha*color[2]+extend*brush->before_color[2])>>8;
						color[3] = (rev_alpha*color[3]+extend*brush->before_color[3])>>8;
					}

					// 現在の色を記憶
					brush->before_color[0] = color[0];
					brush->before_color[1] = color[1];
					brush->before_color[2] = color[2];
					brush->before_color[3] = color[3];

#define CLEAR_MARGINE 2.5
					//	αブレンド用のバッファを更新
					if(draw_x > brush->last_draw_x)
					{
						clear_start_x = (int)(brush->last_draw_x - brush->r * CLEAR_MARGINE);
						clear_width = (int)(draw_x + brush->r * CLEAR_MARGINE);
					}
					else
					{
						clear_start_x = (int)(draw_x - brush->r * CLEAR_MARGINE);
						clear_width = (int)(brush->last_draw_x + brush->r * CLEAR_MARGINE);
					}

					if(clear_start_x < 0)
					{
						clear_start_x = 0;
					}
					if(clear_width > window->width)
					{
						clear_width = window->width;
					}
					clear_width = clear_width - clear_start_x;

					if(draw_y > brush->last_draw_y)
					{
						clear_start_y = (int)(brush->last_draw_y - brush->r * CLEAR_MARGINE);
						clear_height = (int)(draw_y - brush->r * CLEAR_MARGINE);
					}
					else
					{
						clear_start_y = (int)(draw_y - brush->r * CLEAR_MARGINE);
						clear_height = (int)(brush->last_draw_y + brush->r * CLEAR_MARGINE);
					}

					if(clear_start_y < 0)
					{
						clear_start_y = 0;
					}
					if(clear_height > window->height)
					{
						clear_height = window->height;
					}

					for(i=clear_start_y; i<clear_height; i++)
					{
						(void)memset(&mask[window->width*window->height+i*window->width+clear_start_x],
							0, clear_width);
					}
					for(i=0; i<height; i++)
					{
						(void)memcpy(&mask[window->width*window->height+(i+start_y)*window->width+start_x],
							&window->brush_buffer[(i+start_y)*window->width+start_x], width);
					}
#undef CLEAR_MARGINE

#ifdef _OPENMP
#pragma omp parallel for firstprivate(width, work_pixel, layer_width, layer_height, layer_stride, start_x, start_y, brush_buffer)
#endif
					for(i=0; i<height; i++)
					{
						uint8 *ref_pix = &work_pixel[(i+start_y)*layer_stride+start_x*4];
						uint8 *comp_pix = &brush_buffer[(i+start_y)*layer_width+start_x];
						uint8 *alpha_pix = &mask[(i+start_y)*layer_width+start_x];
						uint8 *memory_pix = &mask[layer_width*layer_height+(i+start_y)*layer_width+start_x];
						uint8 mask_value;
						uint8 blend_alpha;
						int j;

						for(j=0; j<width; j++, ref_pix+=4, comp_pix++, alpha_pix++, memory_pix++)
						{
							mask_value = *alpha_pix;

							if(mask_value > *comp_pix)
							{
								*memory_pix = mask_value;

								blend_alpha /*= dst_value*/ = (mask_value - *comp_pix);
								*comp_pix = mask_value;
								ref_pix[3] = ((blend_alpha+1)*color[3]+(0xff-blend_alpha+1)*ref_pix[3])>>8;
									blend_alpha = MINIMUM(ref_pix[3]*2, 0xff);

								ref_pix[0] = (uint8)MINIMUM(
									(((mask_value+1)*color[0]+(0xff-mask_value+1)*ref_pix[0])>>8), blend_alpha);
								ref_pix[1] = (uint8)MINIMUM(
									(((mask_value+1)*color[1]+(0xff-mask_value+1)*ref_pix[1])>>8), blend_alpha);
								ref_pix[2] = (uint8)MINIMUM(
									(((mask_value+1)*color[2]+(0xff-mask_value+1)*ref_pix[2])>>8), blend_alpha);
							}
						}
					}

					for(i=clear_start_y; i<clear_height; i++)
					{
						(void)memcpy(&window->brush_buffer[i*window->width+clear_start_x],
							&mask[window->width*window->height+i*window->width+clear_start_x], clear_width);
					}
					brush->last_draw_x = draw_x, brush->last_draw_y = draw_y;
				}

				dx -= step;
				if(dx < 1)
				{
					window->flags |= DRAW_WINDOW_UPDATE_PART;

					skip_draw = TRUE;
				}
				else
				{
					skip_draw = FALSE;
					if(dx >= step)
					{
						draw_x += diff_x, draw_y += diff_y;
					}
					else
					{
						draw_x = brush->points[ref_point][1];
						draw_y = brush->points[ref_point][2];
					}
				}
			} while(skip_draw == FALSE);

			brush->finish_length += d;
			brush->travel += d;
			brush->draw_finished++;
			ref_point = brush->draw_finished % BRUSH_POINT_BUFFER_SIZE;
		}	// while(brush->ref_point < brush->draw_finished)

		AddBrushHistory(core, window->active_layer);

		window->update.surface_p = cairo_surface_create_for_rectangle(
			window->active_layer->surface_p, window->update.x, window->update.y,
				window->update.width, window->update.height);
		window->update.cairo_p = cairo_create(window->update.surface_p);
		window->part_layer_blend_functions[window->work_layer->layer_mode](window->work_layer, &window->update);
		cairo_surface_destroy(window->update.surface_p);
		cairo_destroy(window->update.cairo_p);

		(void)memset(window->work_layer->pixels, 0, window->work_layer->stride*window->work_layer->height);

		window->work_layer->layer_mode = LAYER_BLEND_NORMAL;
	}	// 左クリックならば
		// if(((GdkEventButton*)state)->button == 1)
}

static void WaterColorBrushEditSelectionReleaseCallBack(
	DRAW_WINDOW* window,
	FLOAT_T x,
	FLOAT_T y,
	FLOAT_T pressure,
	BRUSH_CORE *core,
	void* state
)
{
	// 左クリックならば
	if(((GdkEventButton*)state)->button == 1)
	{
		WATER_COLOR_BRUSH *brush = (WATER_COLOR_BRUSH*)core->brush_data;
		FLOAT_T r, alpha;
		// ブラシの拡大率
		FLOAT_T zoom;
		// 座標の最大・最小値
		FLOAT_T min_x, min_y, max_x, max_y;
		// X、Y方向の移動量
		FLOAT_T dx, dy;
		// ブラシの傾き用
		FLOAT_T diff_x, diff_y;
		// ブラシの座標指定用
		cairo_matrix_t matrix;
		// ブラシの移動量
		FLOAT_T d, step;
		// 描画を行う座標
		FLOAT_T draw_x, draw_y;
		// 入り、抜き時の色補正
		FLOAT_T enter_alpha, out_alpha;
		// ピクセルデータをリセットする座標
		int start_x, start_y;
		// 描画する幅、高さ
		int width, height;
		// キャンバスの幅
		int canvas_width = window->width;
		// 作業レイヤーのピクセル
		uint8 *work_pixel = window->work_layer->pixels;
		// ブラシ位置のピクセル値合計
		unsigned int sum_color0 = 0, sum_color1 = 0;
		// 参照ピクセル
		uint8 *mask;
		uint8 *brush_buffer = window->brush_buffer;
		int rev_alpha;
		uint8 blend_alpha;
		FLOAT_T inv_alpha;
		// 描画の要否判定用
		gboolean skip_draw;
		// 描画する色
		uint8 color[2];
		// 混色具合
		uint8 mix = (uint8)(brush->mix * 2.55);
		// 色延び具合
		uint8 extend = (uint8)(brush->extend * 2.55);
		// 配列のインデックス用
		int ref_point;
		int before_point;
		int i;	// for文用のカウンタ

		while(brush->ref_point > brush->draw_finished)
		{
			ref_point = brush->draw_finished % BRUSH_POINT_BUFFER_SIZE;

			if(brush->finish_length < brush->enter_length)
			{
				enter_alpha = brush->finish_length / brush->enter_length;
				r = brush->enter_size + brush->finish_length * 0.25;
			}
			else
			{
				enter_alpha = 1;
				r = brush->r;
			}
			if(brush->sum_distance < brush->draw_start)
			{
				out_alpha = brush->sum_distance / brush->draw_start;
				r -= (brush->draw_start - brush->sum_distance) * 0.25;
			}
			else
			{
				out_alpha = 1;
			}

			if(r < 0.5)
			{
				brush->draw_finished++;
				continue;
			}

			d = brush->points[ref_point][0];
			zoom = brush->r / r;
			step = r * BRUSH_STEP;
			if(step < 1)
			{
				step = 1;
			}
			alpha = ((brush->flags & BRUSH_FLAG_FLOW) == 0)
				? 1 : brush->points[ref_point][3];
			alpha *= enter_alpha;
			before_point = (ref_point == 0) ? BRUSH_POINT_BUFFER_SIZE - 1 : ref_point - 1;
			brush->sum_distance -= d;
			if(brush->draw_finished == 0)
			{
				draw_x = brush->points[0][1], draw_y = brush->points[0][2];
			}
			else
			{
				draw_x = brush->points[before_point][1], draw_y = brush->points[before_point][2];
			}
			dx = brush->points[ref_point][1] - draw_x;
			dy = brush->points[ref_point][2] - draw_y;
			diff_x = step * dx / d, diff_y = step * dy / d;

			min_x = brush->points[ref_point][1] - r - 1;
			max_x = brush->points[ref_point][1] + r + 1;
			min_y = brush->points[ref_point][2] - r - 1;
			max_y = brush->points[ref_point][2] + r + 1;
			if(min_x < 0.0)
			{
				min_x = 0.0;
			}
			if(core->min_x > min_x)
			{
				core->min_x = min_x;
			}
			if(min_y < 0.0)
			{
				min_y = 0.0;
			}
			if(core->min_y > min_y)
			{
				core->min_y = min_y;
			}
			if(max_x > window->work_layer->width)
			{
				max_x = window->work_layer->width;
			}
			if(core->max_x < max_x)
			{
				core->max_x = max_x;
			}
			if(max_y > window->work_layer->height)
			{
				min_y = window->work_layer->height;
			}
			if(core->max_y < max_y)
			{
				core->max_y = max_y;
			}

			dx = d;
			do
			{
				skip_draw = FALSE;

				start_x = (int)(draw_x - r);
				start_y = (int)(draw_y - r);
				width = (int)(draw_x + r);
				height = (int)(draw_y + r);

				if(start_x < 0)
				{
					start_x = 0;
				}
				else if(start_x > window->work_layer->width)
				{
					skip_draw = TRUE;
				}
				if(start_y < 0)
				{
					start_y = 0;
				}
				else if(start_y > window->work_layer->height)
				{
					skip_draw = TRUE;
				}
				if(width > window->work_layer->width)
				{
					width = window->work_layer->width - start_x;
				}
				else
				{
					width = width - start_x;
				}
				if(height > window->work_layer->height)
				{
					height = window->work_layer->height - start_y;
				}
				else
				{
					height = height - start_y;
				}

				if(skip_draw == FALSE)
				{
					(void)memset(window->mask->pixels, 0, window->width*window->height);

					mask = window->mask->pixels;
					cairo_set_operator(window->alpha_cairo, CAIRO_OPERATOR_OVER);
					if((window->flags & DRAW_WINDOW_HAS_SELECTION_AREA) == 0)
					{
						if((window->active_layer->flags & LAYER_LOCK_OPACITY) == 0)
						{
							cairo_matrix_init_scale(&matrix, zoom, zoom);
							cairo_matrix_translate(&matrix, - draw_x + r, - draw_y + r);
							cairo_pattern_set_matrix(core->brush_pattern, &matrix);
							cairo_set_source(window->alpha_cairo, core->brush_pattern);
							cairo_paint_with_alpha(window->alpha_cairo, alpha);
						}
						else
						{
							cairo_matrix_init_scale(&matrix, zoom, zoom);
							cairo_pattern_set_matrix(core->brush_pattern, &matrix);
							cairo_set_source(core->temp_cairo, core->brush_pattern);
							cairo_paint_with_alpha(core->temp_cairo, alpha);
							cairo_matrix_init_translate(&matrix, - draw_x + r, - draw_y + r);
							cairo_pattern_set_matrix(core->temp_pattern, &matrix);
							cairo_set_source(window->alpha_cairo, core->temp_pattern);
							cairo_mask_surface(window->alpha_cairo,
								window->active_layer->surface_p, 0, 0);
						}
					}
					else
					{
						if((window->active_layer->flags & LAYER_LOCK_OPACITY) == 0)
						{
							cairo_matrix_init_scale(&matrix, zoom, zoom);
							cairo_pattern_set_matrix(core->brush_pattern, &matrix);
							cairo_set_source(core->temp_cairo, core->brush_pattern);
							cairo_paint_with_alpha(core->temp_cairo, alpha);
							cairo_matrix_init_translate(&matrix, - draw_x + r, - draw_y + r);
							cairo_pattern_set_matrix(core->temp_pattern, &matrix);
							cairo_set_source(window->alpha_cairo, core->temp_pattern);
							cairo_mask_surface(window->alpha_cairo,
								window->selection->surface_p, 0, 0);
						}
						else
						{
							cairo_matrix_init_scale(&matrix, zoom, zoom);
							cairo_pattern_set_matrix(core->brush_pattern, &matrix);
							cairo_set_source(core->temp_cairo, core->brush_pattern);
							cairo_paint_with_alpha(core->temp_cairo, alpha);
							cairo_matrix_init_translate(&matrix, - x + r, - y + r);
							cairo_pattern_set_matrix(core->temp_pattern, &matrix);
							cairo_set_source(window->alpha_cairo, core->temp_pattern);

							(void)memset(window->temp_layer->pixels, 0, window->width*window->height);

							cairo_mask_surface(window->alpha_cairo,
								window->selection->surface_p, 0, 0);
							cairo_set_source_surface(window->alpha_temp_cairo,
								window->alpha_surface, 0, 0);
							cairo_mask_surface(window->alpha_temp_cairo,
								window->active_layer->surface_p, 0, 0);

							mask = window->temp_layer->pixels;
						}
					}

					sum_color0 = sum_color1 = 1;

#ifdef _OPENMP
#pragma omp parallel for reduction( +: sum_color0, sum_color1) firstprivate(width, work_pixel, canvas_width, start_x, start_y)
#endif
					for(i=0; i<height; i++)
					{
						uint8 *ref_pix = &work_pixel[(i+start_y)*canvas_width+start_x];
						uint8 *mask_pix = &mask[(i+start_y)*canvas_width+start_x];
						int j;

						for(j=0; j<width; j++, ref_pix++, mask_pix++)
						{
							sum_color0 += ((ref_pix[0]+1) * *mask_pix) >> 8;
							sum_color1 += *mask_pix;
						}
					}

					color[0] = (uint8)((sum_color0 + (sum_color1 / 255) / 2) / (sum_color1 / 255.0));

					// 描画する色を決定
					rev_alpha = 0xff-mix+1;
					blend_alpha = (uint8)(brush->alpha * 2.55);
					color[0] = (rev_alpha*blend_alpha+mix*color[0])>>8;

					if(extend != 0 && ref_point != 0)
					{
						rev_alpha = 0xff-extend+1;
						color[0] = (rev_alpha*color[0]+extend*brush->before_color[0])>>8;
					}

					// 現在の色を記憶
					brush->before_color[0] = color[0];
					inv_alpha = color[0] * DIV_PIXEL;

#ifdef _OPENMP
#pragma omp parallel for firstprivate(width, work_pixel, canvas_width, start_x, start_y, brush_buffer)
#endif
					for(i=0; i<height; i++)
					{
						uint8 *ref_pix = &work_pixel[(i+start_y)*canvas_width+start_x];
						uint8 *comp_pix = &brush_buffer[(i+start_y)*canvas_width+start_x];
						uint8 *alpha_pix = &mask[(i+start_y)*canvas_width+start_x];
						uint8 mask_value;
						int j;

						for(j=0; j<width; j++, ref_pix++, comp_pix++, alpha_pix++)
						{
							mask_value = *alpha_pix;
							*alpha_pix = (uint8)(*alpha_pix * inv_alpha);

							if(mask_value > 0)
							{
								if(mask_value == 0xff)
								{
									ref_pix[0] = *alpha_pix;
								}
								else
								{
									ref_pix[0] = (mask_value > ref_pix[0]) ? *alpha_pix : ref_pix[0];
								}
							}
						}
					}
					(void)memcpy(window->brush_buffer, mask, window->width*window->height);
				}

				dx -= step;
				if(dx < 1)
				{
					skip_draw = TRUE;
				}
				else
				{
					skip_draw = FALSE;
					if(dx >= step)
					{
						draw_x += diff_x, draw_y += diff_y;
					}
					else
					{
						draw_x = brush->points[before_point][1];
						draw_y = brush->points[before_point][2];
					}
				}
			} while(skip_draw == FALSE);

			brush->finish_length += d;
			brush->travel += d;
			brush->draw_finished++;
			ref_point = brush->draw_finished % BRUSH_POINT_BUFFER_SIZE;
		}	// while(brush->ref_point < brush->draw_finished)

		AddSelectionEditHistory(core, window->selection);

		g_blend_selection_funcs[window->selection->layer_mode](window->work_layer, window->selection);

		(void)memset(window->work_layer->pixels, 0, window->work_layer->stride*window->work_layer->height);

		window->selection->layer_mode = SELECTION_BLEND_NORMAL;
	}	// 左クリックならば
		// if(((GdkEventButton*)state)->button == 1)
}

static void WaterColorBrushDrawCursor(
	DRAW_WINDOW* window,
	FLOAT_T x,
	FLOAT_T y,
	void* data
)
{
	WATER_COLOR_BRUSH* brush = (WATER_COLOR_BRUSH*)data;
	FLOAT_T r = brush->r * window->zoom_rate;
	cairo_set_line_width(window->disp_temp->cairo_p, 1.0);
	cairo_set_source_rgb(window->disp_temp->cairo_p, 1, 1, 1);
	cairo_arc(window->disp_temp->cairo_p, x, y, r, 0, 2*G_PI);
	cairo_stroke(window->disp_temp->cairo_p);

	cairo_rectangle(window->disp_layer->cairo_p, x - r, y - r,
		(r + BRUSH_UPDATE_MARGIN) * 2, (r + BRUSH_UPDATE_MARGIN) * 2);
	cairo_clip(window->disp_layer->cairo_p);
}

static void WaterColorBrushButtonUpdate(DRAW_WINDOW* window, FLOAT_T x, FLOAT_T y, WATER_COLOR_BRUSH* brush)
{
	FLOAT_T r = brush->r * window->zoom_rate + 1;
	gtk_widget_queue_draw_area(window->window, (gint)(x - r - 1),
		(gint)(y - r - 1), (gint)(r * 2) + BRUSH_UPDATE_MARGIN, (gint)(r * 2) + BRUSH_UPDATE_MARGIN);
}

static void WaterColorBrushMotionUpdate(DRAW_WINDOW* window, FLOAT_T x, FLOAT_T y, WATER_COLOR_BRUSH* brush)
{
	FLOAT_T start_x, start_y;
	FLOAT_T width, height;
	FLOAT_T r = brush->r * window->zoom_rate * 1.275 + BRUSH_UPDATE_MARGIN;
	FLOAT_T enter = (brush->enter_length + brush->draw_start) * window->zoom_rate;

	if(window->before_cursor_x < x)
	{
		start_x = window->before_cursor_x - r;
		width = r * 2 + x - window->before_cursor_x;
	}
	else
	{
		start_x = x - r;
		width = r * 2 + window->before_cursor_x - x;
	}

	if(window->before_cursor_y < y)
	{
		start_y = window->before_cursor_y - r;
		height = r * 2 + y - window->before_cursor_y;
	}
	else
	{
		start_y = y - r;
		height = r * 2 + window->before_cursor_y - y;
	}

	start_x -= enter * 4;
	width += enter * 4 * 2 + 2;
	start_y -= enter * 4;
	height += enter * 4 * 2 + 2;

	gtk_widget_queue_draw_area(window->window,
		(gint)start_x, (gint)start_y, (gint)width, (gint)height);
}

static void WaterColorBrushSetScale(GtkAdjustment* slider, WATER_COLOR_BRUSH* brush)
{
	brush->r = gtk_adjustment_get_value(slider) * 0.5;
	BrushCoreSetGrayCirclePattern(brush->core, brush->r, brush->outline_hardness * 0.01,
		brush->blur * 0.01, brush->alpha * 0.01);
}

static void WaterColorBrushSetFlow(GtkAdjustment* slider, WATER_COLOR_BRUSH* brush)
{
	brush->alpha = gtk_adjustment_get_value(slider);
	BrushCoreSetGrayCirclePattern(brush->core, brush->r, brush->outline_hardness * 0.01,
		brush->blur * 0.01, brush->alpha * 0.01);
}

static void WaterColorBrushSetBlur(GtkAdjustment* slider, WATER_COLOR_BRUSH* brush)
{
	brush->blur = gtk_adjustment_get_value(slider);
	BrushCoreSetGrayCirclePattern(brush->core, brush->r, brush->outline_hardness * 0.01,
		brush->blur * 0.01, brush->alpha * 0.01);
}

static void WaterColorBrushSetOutlineHardness(GtkAdjustment* slider, WATER_COLOR_BRUSH* brush)
{
	brush->outline_hardness = gtk_adjustment_get_value(slider);
	BrushCoreSetGrayCirclePattern(brush->core, brush->r, brush->outline_hardness * 0.01,
		brush->blur * 0.01, brush->alpha * 0.01);
}

static void WaterColorBrushSetMix(GtkAdjustment* slider, WATER_COLOR_BRUSH* brush)
{
	brush->mix = gtk_adjustment_get_value(slider);
}

static void WaterColorBrushSetExtend(GtkAdjustment* slider, WATER_COLOR_BRUSH* brush)
{
	brush->extend = gtk_adjustment_get_value(slider);
}

static void WaterColorBrushSetEnterSize(GtkAdjustment* slider, WATER_COLOR_BRUSH* brush)
{
	brush->enter = gtk_adjustment_get_value(slider);
}

static void WaterColorBrushSetOutSize(GtkAdjustment* slider, WATER_COLOR_BRUSH* brush)
{
	brush->out = gtk_adjustment_get_value(slider);
}

static void WaterColorBrushSetPressureSize(GtkWidget* button, WATER_COLOR_BRUSH* brush)
{
	if(gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(button)) == FALSE)
	{
		brush->flags &= ~(BRUSH_FLAG_SIZE);
	}
	else
	{
		brush->flags |= BRUSH_FLAG_SIZE;
	}
}

static void WaterColorBrushSetPressureFlow(GtkWidget* button, WATER_COLOR_BRUSH* brush)
{
	if(gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(button)) == FALSE)
	{
		brush->flags &= ~(BRUSH_FLAG_FLOW);
	}
	else
	{
		brush->flags |= BRUSH_FLAG_FLOW;
	}
}

static GtkWidget* CreateWaterColorBrushDetailUI(APPLICATION* app, BRUSH_CORE* core)
{
#define UI_FONT_SIZE 8.0
	WATER_COLOR_BRUSH *brush = (WATER_COLOR_BRUSH*)core->brush_data;
	GtkWidget *vbox = gtk_vbox_new(FALSE, 0);
	GtkWidget *hbox;
	GtkWidget *brush_scale;
	GtkWidget *check_button;
	GtkWidget *label;
	GtkWidget *base_scale;
	GtkAdjustment *scale_adjustment;
	char mark_up_buff[256];

	brush->core = core;

	{
		const char *mag_str[] = {"x 0.1", "x 1", "x 10"};
		hbox = gtk_hbox_new(FALSE, 0);
		label = gtk_label_new("");
		(void)sprintf(mark_up_buff, "<span font_desc=\"%.2f\">%s : </span>",
			UI_FONT_SIZE * app->gui_scale, app->labels->tool_box.base_scale);
		gtk_label_set_markup(GTK_LABEL(label), mark_up_buff);
		gtk_box_pack_start(GTK_BOX(hbox), label, FALSE, FALSE, 0);
#if GTK_MAJOR_VERSION <= 2
		base_scale = gtk_combo_box_new_text();
		gtk_combo_box_append_text(GTK_COMBO_BOX(base_scale), mag_str[0]);
		gtk_combo_box_append_text(GTK_COMBO_BOX(base_scale), mag_str[1]);
		gtk_combo_box_append_text(GTK_COMBO_BOX(base_scale), mag_str[2]);
#else
		base_scale = gtk_combo_box_text_new();
		gtk_combo_box_text_append_text(GTK_COMBO_BOX_TEXT(base_scale), mag_str[0]);
		gtk_combo_box_text_append_text(GTK_COMBO_BOX_TEXT(base_scale), mag_str[1]);
		gtk_combo_box_text_append_text(GTK_COMBO_BOX_TEXT(base_scale), mag_str[2]);
#endif
		gtk_combo_box_set_active(GTK_COMBO_BOX(base_scale), brush->base_scale);
		gtk_box_pack_start(GTK_BOX(hbox), base_scale, TRUE, TRUE, 0);
		gtk_box_pack_start(GTK_BOX(vbox), hbox, FALSE, FALSE, 0);
	}

	switch(brush->base_scale)
	{
	case 0:
		scale_adjustment =
			GTK_ADJUSTMENT(gtk_adjustment_new(brush->r * 2, 0.1, 10.0, 0.1, 0.1, 0.0));
		break;
	case 1:
		scale_adjustment = GTK_ADJUSTMENT(gtk_adjustment_new(
			brush->r * 2, 1.0, 100.0, 1.0, 1.0, 0.0));
		break;
	default:
		scale_adjustment =
			GTK_ADJUSTMENT(gtk_adjustment_new(brush->r * 2, 5.0, 500.0, 1.0, 1.0, 0.0));
	}

	(void)g_signal_connect(G_OBJECT(scale_adjustment), "value_changed",
		G_CALLBACK(WaterColorBrushSetScale), core->brush_data);
	brush_scale = SpinScaleNew(scale_adjustment, app->labels->tool_box.brush_scale, 1);
	gtk_box_pack_start(GTK_BOX(vbox), brush_scale, FALSE, FALSE, 0);

	g_object_set_data(G_OBJECT(base_scale), "scale", brush_scale);
	(void)g_signal_connect(G_OBJECT(base_scale), "changed", G_CALLBACK(SetBrushBaseScale), &brush->base_scale);

	scale_adjustment = GTK_ADJUSTMENT(gtk_adjustment_new(
		brush->alpha, 0.0, 100.0, 1.0, 1.0, 0.0));
	(void)g_signal_connect(G_OBJECT(scale_adjustment), "value_changed",
		G_CALLBACK(WaterColorBrushSetFlow), core->brush_data);
	brush_scale = SpinScaleNew(scale_adjustment, app->labels->tool_box.flow, 1);
	gtk_box_pack_start(GTK_BOX(vbox), brush_scale, FALSE, FALSE, 0);

	scale_adjustment = GTK_ADJUSTMENT(gtk_adjustment_new(
		brush->outline_hardness, 0.0, 100.0, 1.0, 1.0, 0.0));
	(void)g_signal_connect(G_OBJECT(scale_adjustment), "value_changed",
		G_CALLBACK(WaterColorBrushSetOutlineHardness), core->brush_data);
	brush_scale = SpinScaleNew(scale_adjustment, app->labels->tool_box.outline_hardness, 1);
	gtk_box_pack_start(GTK_BOX(vbox), brush_scale, FALSE, FALSE, 0);

	scale_adjustment = GTK_ADJUSTMENT(gtk_adjustment_new(
		brush->blur, 0.0, 100.0, 1.0, 1.0, 0.0));
	(void)g_signal_connect(G_OBJECT(scale_adjustment), "value_changed",
		G_CALLBACK(WaterColorBrushSetBlur), core->brush_data);
	brush_scale = SpinScaleNew(scale_adjustment, app->labels->tool_box.blur, 1);
	gtk_box_pack_start(GTK_BOX(vbox), brush_scale, FALSE, FALSE, 0);

	scale_adjustment = GTK_ADJUSTMENT(gtk_adjustment_new(
		brush->mix, 0.0, 100.0, 1.0, 1.0, 0.0));
	(void)g_signal_connect(G_OBJECT(scale_adjustment), "value_changed",
		G_CALLBACK(WaterColorBrushSetMix), core->brush_data);
	brush_scale = SpinScaleNew(scale_adjustment, app->labels->tool_box.mix, 1);
	gtk_box_pack_start(GTK_BOX(vbox), brush_scale, FALSE, FALSE, 0);

	scale_adjustment = GTK_ADJUSTMENT(gtk_adjustment_new(
		brush->extend, 0.0, 100.0, 1.0, 1.0, 0.0));
	(void)g_signal_connect(G_OBJECT(scale_adjustment), "value_changed",
		G_CALLBACK(WaterColorBrushSetExtend), core->brush_data);
	brush_scale = SpinScaleNew(scale_adjustment, app->labels->tool_box.color_extend, 1);
	gtk_box_pack_start(GTK_BOX(vbox), brush_scale, FALSE, FALSE, 0);

	scale_adjustment = GTK_ADJUSTMENT(gtk_adjustment_new(
		brush->enter, 0.0, 100.0, 1.0, 1.0, 0.0));
	(void)g_signal_connect(G_OBJECT(scale_adjustment), "value_changed",
		G_CALLBACK(WaterColorBrushSetEnterSize), core->brush_data);
	brush_scale = SpinScaleNew(scale_adjustment, app->labels->tool_box.enter, 1);
	gtk_box_pack_start(GTK_BOX(vbox), brush_scale, FALSE, FALSE, 0);

	scale_adjustment = GTK_ADJUSTMENT(gtk_adjustment_new(
		brush->out, 0.0, 100.0, 1.0, 1.0, 0.0));
	(void)g_signal_connect(G_OBJECT(scale_adjustment), "value_changed",
		G_CALLBACK(WaterColorBrushSetOutSize), core->brush_data);
	brush_scale = SpinScaleNew(scale_adjustment, app->labels->tool_box.out, 1);
	gtk_box_pack_start(GTK_BOX(vbox), brush_scale, FALSE, FALSE, 0);

	hbox = gtk_hbox_new(FALSE, 0);
	label = gtk_label_new("");
	(void)sprintf(mark_up_buff, "<span font_desc=\"%.2f\">%s : </span>",
		UI_FONT_SIZE * app->gui_scale, app->labels->tool_box.pressure);
	gtk_label_set_markup(GTK_LABEL(label), mark_up_buff);
	gtk_box_pack_start(GTK_BOX(hbox), label, FALSE, FALSE, 0);
	check_button = gtk_check_button_new_with_label(app->labels->tool_box.scale);
	(void)g_signal_connect(G_OBJECT(check_button), "toggled",
		G_CALLBACK(WaterColorBrushSetPressureSize), core->brush_data);
	gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(check_button), brush->flags & BRUSH_FLAG_SIZE);
	gtk_box_pack_start(GTK_BOX(hbox), check_button, FALSE, TRUE, 0);
	check_button = gtk_check_button_new_with_label(app->labels->tool_box.flow);
	(void)g_signal_connect(G_OBJECT(check_button), "toggled",
		G_CALLBACK(WaterColorBrushSetPressureFlow), core->brush_data);
	gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(check_button), brush->flags & BRUSH_FLAG_FLOW);
	gtk_box_pack_start(GTK_BOX(hbox), check_button, FALSE, TRUE, 0);
	gtk_box_pack_start(GTK_BOX(vbox), hbox, FALSE, TRUE, 0);

	BrushCoreSetGrayCirclePattern(brush->core, brush->r, brush->outline_hardness * 0.01,
		brush->blur * 0.01, brush->alpha * 0.01);

	return vbox;
#undef UI_FONT_SIZE
}

/*****************************************************
* InitializeStampCore関数                            *
* スタンプの基本情報を初期化                         *
* 引数                                               *
* core	: スタンプ系ツールの基本情報                 *
* mode	: チャンネル数が2の時の合成方法              *
* app	: アプリケーションを管理する構造体のアドレス *
*****************************************************/
static void InitializeStampCore(STAMP_CORE* core, int mode, APPLICATION* app)
{
	// カーソルサーフェース作成用にパターンサーフェースを作成
	cairo_surface_t *surface_p;
	// パターンサーフェースのピクセルデータ
	uint8 *pixels;
	// パターンピクセルデータの一行分のバイト数
	int stride;
	// カーソルの幅
	int cursor_width;
	// 描画する幅
	int draw_width;
	// for文用のカウンタ
	int i;

	// 幅、高さの内、大きい方で半径セット
	if(app->stamps.active_pattern->width > app->stamps.active_pattern->height)
	{
		core->r = app->stamps.active_pattern->width * core->inv_scale;
	}
	else
	{
		core->r = app->stamps.active_pattern->height * core->inv_scale;
	}

	// スタンプのサイズセット
	core->half_width = app->stamps.active_pattern->width * core->inv_scale * 0.5;
	core->half_height = app->stamps.active_pattern->height * core->inv_scale * 0.5;

	// スタンプ間の距離決定
	core->d = core->stamp_distance *
		sqrt(core->half_width*core->half_width + core->half_height*core->half_height);

	if(core->d < 1)
	{
		core->d = 1;
	}

	// 開始回転角を決定
	core->rotate_start = fabs(core->rotate_start);
	if(core->rotate_direction < 0)
	{
		core->rotate_start = - core->rotate_start;
	}
	core->rotate = core->rotate_start;

	// 回転速度を決定
	core->rotate_speed = core->rotate_direction * fabs(core->rotate_speed);

	// スタンプのカーソルを更新
	if(core->cursor_surface != NULL)
	{
		cairo_surface_destroy(core->cursor_surface);
	}
	if(app->stamp_buff_size < app->stamps.pattern_max_byte)
	{
		app->stamp_buff_size = app->stamps.pattern_max_byte;
		app->stamp_shape = (uint8*)MEM_REALLOC_FUNC(app->stamp_shape, app->stamp_buff_size);
	}

	// パターンサーフェースを作成してカーソル作成
	surface_p = CreatePatternSurface(&app->stamps, app->tool_window.color_chooser->rgb,
		app->tool_window.color_chooser->back_rgb, core->pattern_flags, 0, 1);
	if(surface_p != NULL)
	{
		pixels = cairo_image_surface_get_data(surface_p);
		stride = cairo_image_surface_get_stride(surface_p);
		// カーソルの幅決定
		cursor_width = app->stamps.active_pattern->width;
		cursor_width += (4 - (cursor_width % 4)) % 4;
		(void)memset(app->stamps.pattern_pixels_temp, 0, cursor_width * app->stamps.active_pattern->height);

		draw_width = app->stamps.active_pattern->width;
#ifdef _OPENMP
#pragma omp parallel for firstprivate(draw_width, cursor_width, pixels)
#endif
		// αチャンネルをコピー
		for(i=0; i<app->stamps.active_pattern->height; i++)
		{
			int j;
			for(j=0; j<draw_width; j++)
			{
				if(pixels[i*stride+j*4+3] > 0)
				{
					app->stamps.pattern_pixels_temp[i*cursor_width+j] = 0xff;
				}
				else
				{
					app->stamps.pattern_pixels_temp[i*cursor_width+j] = 0;
				}
			}
		}
		// エッジ検出
		LaplacianFilter(app->stamps.pattern_pixels_temp, cursor_width, app->stamps.active_pattern->height,
			cursor_width, app->stamp_shape);
		// エッジ検出したデータでサーフェース作成
		core->cursor_surface = cairo_image_surface_create_for_data(app->stamp_shape,
			CAIRO_FORMAT_A8, cursor_width, app->stamps.active_pattern->height, cursor_width);
		cairo_surface_destroy(surface_p);
	}

	if((app->flags & APPLICATION_INITIALIZED) != 0 && core->app != NULL)
	{
		// ブラシパターンサーフェースを更新
		if(core->brush_core->brush_surface != NULL)
		{
			cairo_surface_destroy(core->brush_core->brush_surface);
		}
		if(core->brush_core->brush_pattern != NULL)
		{
			cairo_pattern_destroy(core->brush_core->brush_pattern);
		}
		core->brush_core->brush_surface = CreatePatternSurface(
			&app->stamps, *core->brush_core->color, app->tool_window.color_chooser->back_rgb, core->pattern_flags, mode, core->flow);
		core->brush_core->brush_pattern = cairo_pattern_create_for_surface(
			core->brush_core->brush_surface);
		cairo_pattern_set_extend(core->brush_core->brush_pattern, CAIRO_EXTEND_NONE);
		core->brush_core->temp_surface = cairo_image_surface_create_for_data(
			core->app->stamps.pattern_pixels_temp, CAIRO_FORMAT_ARGB32,
				core->app->stamps.active_pattern->width, core->app->stamps.active_pattern->height, core->app->stamps.active_pattern->width*4
		);
		core->brush_core->temp_cairo = cairo_create(core->brush_core->temp_surface);
		cairo_set_operator(core->brush_core->temp_cairo, CAIRO_OPERATOR_SOURCE);
		core->brush_core->temp_pattern = cairo_pattern_create_for_surface(core->brush_core->temp_surface);
		cairo_pattern_set_extend(core->brush_core->temp_pattern, CAIRO_EXTEND_NONE);
	}
}

/*****************************************
* StampCoreDrawCursor関数                *
* スタンプ系ツールのカーソルを描画       *
* 引数                                   *
* window	: 描画領域の情報             *
* x			: カーソルのX座標            *
* y			: カーソルのY座標            *
* data		: スタンプ系ツールの基本情報 *
*****************************************/
static void StampCoreDrawCursor(
	DRAW_WINDOW* window,
	FLOAT_T x,
	FLOAT_T y,
	STAMP_CORE* core
)
{
	// カーソルブラシ
	cairo_pattern_t* brush;
	// カーソルの拡大縮小、回転・平行移動用の行列
	cairo_matrix_t matrix;
	// カーソルの平行・回転移動用
	FLOAT_T trans_x, trans_y;
	FLOAT_T cos_x, sin_y;
	FLOAT_T half_width, half_height;
	FLOAT_T rev_zoom = window->rev_zoom;

	// 平行移動する座標を計算
	half_width = core->half_width * window->zoom_rate;
	half_height = core->half_height * window->zoom_rate;
	cos_x = cos(core->rotate), sin_y = sin(core->rotate);
	trans_x = x - (half_width * cos_x + half_height * sin_y);
	trans_y = y + (half_width * sin_y - half_height * cos_x);
	// 拡大縮小率、回転角をセット
	brush = cairo_pattern_create_for_surface(core->cursor_surface);
	cairo_pattern_set_extend(brush, CAIRO_EXTEND_NONE);
	cairo_matrix_init_scale(&matrix, core->scale * rev_zoom, core->scale * rev_zoom);
	cairo_matrix_rotate(&matrix, core->rotate);
	cairo_matrix_translate(&matrix, - trans_x, - trans_y);
	cairo_pattern_set_matrix(brush, &matrix);

	cairo_set_source_rgb(window->disp_temp->cairo_p, 1, 1, 1);
	cairo_mask(window->disp_temp->cairo_p, brush);

	cairo_rectangle(window->disp_layer->cairo_p, (int)(x - half_width - 1),
		(int)(y - half_height - 1), (int)half_width*2+2, (int)half_height*2+2);
	cairo_clip(window->disp_layer->cairo_p);

	cairo_pattern_destroy(brush);
}

/*************************************************************
* LoadStampCoreData関数                                      *
* スタンプの基本情報を読み込む                               *
* 引数                                                       *
* file			: ブラシデータのファイル管理構造体のアドレス *
* section_name	: セクション名                               *
* core			: スタンプ系ツールの基本情報                 *
* mode			: 着色モードを管理する変数のアドレス         *
* app			: アプリケーションを管理する構造体のアドレス *
*************************************************************/
static void LoadStampCoreData(
	INI_FILE_PTR file,
	const char* section_name,
	STAMP_CORE* core,
	uint8* mode,
	APPLICATION* app
)
{
	core->inv_scale = IniFileGetInteger(file, section_name, "SIZE") * 0.01;
	core->scale = 1 / core->inv_scale;
	core->flow = IniFileGetInteger(file, section_name, "FLOW") * 0.01;
	core->stamp_distance = IniFileGetDouble(file, section_name, "DISTANCE");
	core->rotate_start = IniFileGetInteger(file, section_name, "ROTATE_START") * G_PI / 180;
	core->rotate_speed = IniFileGetInteger(file, section_name, "ROTATE_SPEED") * G_PI / 180;
	core->rotate_direction = IniFileGetInteger(file, section_name, "ROTATE_DIRECTION");
	if(core->rotate_direction < 0)
	{
		core->rotate_direction = -1;
	}
	else
	{
		core->rotate_direction = 1;
	}
	core->stamp_id = IniFileGetInteger(file, section_name, "STAMP_ID");
	if(mode != NULL)
	{
		*mode = (uint8)IniFileGetInteger(file, section_name, "MODE");
	}
	if(IniFileGetInteger(file, section_name, "PRESSURE_SIZE") != 0)
	{
		core->flags |= STAMP_PRESSURE_SIZE;
	}
	if(IniFileGetInteger(file, section_name, "PRESSURE_FLOW") != 0)
	{
		core->flags |= STAMP_PRESSURE_FLOW;
	}
	if(IniFileGetInteger(file, section_name, "RANDOM_ROTATE") != 0)
	{
		core->flags |= STAMP_RANDOM_ROTATE;
	}
	if(IniFileGetInteger(file, section_name, "RANDOM_SIZE") != 0)
	{
		core->flags |= STAMP_RANDOM_SIZE;
	}

	InitializeStampCore(core, (mode == NULL) ? STAMP_MODE_SATURATION : (int)(*mode), app);
}

/*************************************************************
* LoadStampCoreDefaultData関数                               *
* スタンプのデフォルト基本情報を読み込む                     *
* 引数                                                       *
* core			: スタンプ系ツールの基本情報                 *
* mode			: 着色モードを管理する変数のアドレス         *
* app			: アプリケーションを管理する構造体のアドレス *
*************************************************************/
static void LoadStampCoreDefaultData(
	STAMP_CORE* core,
	uint8* mode,
	APPLICATION* app
)
{
	core->inv_scale = 1;
	core->scale = 1 / core->inv_scale;
	core->flow = 1;
	core->stamp_distance = 1;
	// core->rotate_start = 0;
	// core->rotate_speed = 0;
	core->rotate_direction = 1;
	/*
	if(core->rotate_direction < 0)
	{
		core->rotate_direction = -1;
	}
	else
	{
		core->rotate_direction = 1;
	}
	*/
	// core->stamp_id = 0;
	/*
	if(mode != NULL)
	{
		*mode = (uint8)IniFileGetInteger(file, section_name, "MODE");
	}
	*/
	/*
	if(IniFileGetInteger(file, section_name, "PRESSURE_SIZE") != 0)
	{
		core->flags |= STAMP_PRESSURE_SIZE;
	}
	if(IniFileGetInteger(file, section_name, "PRESSURE_FLOW") != 0)
	{
		core->flags |= STAMP_PRESSURE_FLOW;
	}
	if(IniFileGetInteger(file, section_name, "RANDOM_ROTATE") != 0)
	{
		core->flags |= STAMP_RANDOM_ROTATE;
	}
	if(IniFileGetInteger(file, section_name, "RANDOM_SIZE") != 0)
	{
		core->flags |= STAMP_RANDOM_SIZE;
	}
	*/

	InitializeStampCore(core, (mode == NULL) ? STAMP_MODE_SATURATION : (int)(*mode), app);
}

static void StampCoreChangeScale(GtkAdjustment* slider, STAMP_CORE* core)
{
	int mode = (core->mode != NULL) ? (int)(*core->mode) : 0;
	core->inv_scale = gtk_adjustment_get_value(slider) * 0.01;
	core->scale = 1 / core->inv_scale;
	InitializeStampCore(core, mode, (APPLICATION*)g_object_get_data(G_OBJECT(slider), "application"));
}

static void StampCoreChangeFlow(GtkAdjustment* slider, STAMP_CORE* core)
{
	int mode = (core->mode != NULL) ? (int)(*core->mode) : 0;
	core->flow = gtk_adjustment_get_value(slider) * 0.01;
	InitializeStampCore(core, mode, (APPLICATION*)g_object_get_data(G_OBJECT(slider), "application"));
}

static void StampCoreChangeDistance(GtkAdjustment* slider, STAMP_CORE* core)
{
	int mode = (core->mode != NULL) ? (int)(*core->mode) : 0;
	core->stamp_distance = gtk_adjustment_get_value(slider);
	InitializeStampCore(core, mode, (APPLICATION*)g_object_get_data(G_OBJECT(slider), "application"));
}

static void StampCoreChangeRotateStart(GtkAdjustment* slider, STAMP_CORE* core)
{
	int mode = (core->mode != NULL) ? (int)(*core->mode) : 0;
	core->rotate_start = gtk_adjustment_get_value(slider) * G_PI / 180;
	InitializeStampCore(core, mode, (APPLICATION*)g_object_get_data(G_OBJECT(slider), "application"));
}

static void StampCoreChangeRotateSpeed(GtkAdjustment* slider, STAMP_CORE* core)
{
	int mode = (core->mode != NULL) ? (int)(*core->mode) : 0;
	core->rotate_speed = gtk_adjustment_get_value(slider) * G_PI / 180;
	InitializeStampCore(core, mode, (APPLICATION*)g_object_get_data(G_OBJECT(slider), "application"));
}

static void StampCoreChangeRotateDirection(GtkWidget* widget, STAMP_CORE* core)
{
	int mode = (core->mode != NULL) ? (int)(*core->mode) : 0;
	if(gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(widget)) != FALSE)
	{
		core->rotate_direction = GPOINTER_TO_INT(g_object_get_data(G_OBJECT(widget), "direction"));
	}
	InitializeStampCore(core, mode, (APPLICATION*)g_object_get_data(G_OBJECT(widget), "application"));
}

static void StampCoreSetFlags(GtkWidget* widget, STAMP_CORE* core)
{
	unsigned int flag = GPOINTER_TO_UINT(g_object_get_data(G_OBJECT(widget), "flag-id"));
	if(gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(widget)) == FALSE)
	{
		core->flags &= ~(1 << flag);
	}
	else
	{
		core->flags |= (1 << flag);
	}
}

static void StampCoreSetPatternFlags(GtkWidget* widget, STAMP_CORE* core)
{
	int mode = (core->mode != NULL) ? (int)(*core->mode) : 0;
	unsigned int flag = GPOINTER_TO_UINT(g_object_get_data(G_OBJECT(widget), "flag-id"));
	if(gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(widget)) == FALSE)
	{
		core->pattern_flags &= ~(1 << flag);
	}
	else
	{
		core->pattern_flags |= (1 << flag);
	}

	InitializeStampCore(core, mode, (APPLICATION*)g_object_get_data(G_OBJECT(widget), "application"));
}

static void StampCoreSetFlag(GtkWidget* widget, STAMP_CORE* core)
{
	int mode = (core->mode != NULL) ? (int)(*core->mode) : 0;
	unsigned int flag = GPOINTER_TO_UINT(g_object_get_data(G_OBJECT(widget), "flag-value"));
	if(gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(widget)) == FALSE)
	{
		core->flags &= ~(flag);
	}
	else
	{
		core->flags |= flag;
	}

	InitializeStampCore(core, mode, (APPLICATION*)g_object_get_data(G_OBJECT(widget), "application"));
}

static void StampCoreSetMode(GtkWidget* widget, uint8* mode)
{
	STAMP_CORE *core = g_object_get_data(G_OBJECT(widget), "stamp_core");
	*mode = (uint8)GPOINTER_TO_UINT(g_object_get_data(G_OBJECT(widget), "mode"));
	InitializeStampCore(core, (int)(*mode), (APPLICATION*)g_object_get_data(G_OBJECT(widget), "application"));
}

/***************************************************************
* StampSelectButtonClicked関数                                 *
* スタンプ選択用のボタンがクリックされたときのコールバック関数 *
* 引数                                                         *
* button	: ボタンウィジェット                               *
* stamp		: スタンプ系ツールの基本情報                       *
***************************************************************/
static void StampSelectButtonClicked(GtkWidget* button, STAMP_CORE* core)
{
	// パターンIDをウィジェットに登録されたデータから取得
	int stamp_id = GPOINTER_TO_INT(g_object_get_data(G_OBJECT(button), "stamp-id"));
	// ボタンID調整用
	int button_add = (core->app->stamps.has_clip_board_pattern == FALSE) ? 0 : -1;
	// 着色モード
	int mode = (core->mode != NULL) ? (int)(*core->mode) : 0;
	// for文用のカウンタ
	int i;

	// 使用パターンと押されたボタンが一致していたらボタンをアクティブにして終了
	if(stamp_id == core->stamp_id)
	{
		if(gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(button)) == FALSE)
		{
			gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(button), TRUE);
		}
		return;
	}
	else if(gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(button)) == FALSE)
	{	// 使用パターンと不一致でボタンが非アクティブなら終了
		return;
	}

	// 使用パターンを設定
	core->stamp_id = stamp_id;
	if(core->app->stamps.has_clip_board_pattern != FALSE && core->stamp_id == 0)
	{
		core->app->stamps.active_pattern =
			&core->app->stamps.clip_board;
	}
	else
	{
		core->app->stamps.active_pattern =
			&core->app->stamps.patterns[stamp_id + button_add];
	}

	InitializeStampCore(core, mode, core->app);

	// アクティブなパターンがチャンネル数2以外ならば合成モードは無効
	if(core->mode_select[0] != NULL)
	{
		gtk_widget_set_sensitive(core->mode_select[0], core->app->stamps.active_pattern->channel == 2);
		gtk_widget_set_sensitive(core->mode_select[1], core->app->stamps.active_pattern->channel == 2);
		gtk_widget_set_sensitive(core->mode_select[2], core->app->stamps.active_pattern->channel == 2);
	}

	// 他のボタンを非アクティブにする
	for(i=0; i<core->num_button; i++)
	{
		if(i == core->stamp_id)
		{
			if(gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(core->buttons[i])) == FALSE)
			{
				gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(core->buttons[i]), TRUE);
			}
		}
		else
		{
			if(gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(core->buttons[i])) != FALSE)
			{
				gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(core->buttons[i]), FALSE);
			}
		}
	}
}

// パターン選択用テーブルの幅
#define STAMP_SELECT_TABLE_WIDTH 4

/*******************************************
* CreateStampSelectTable関数               *
* スタンプ選択用のボタンテーブルを作成する *
* 引数                                     *
* core	: スタンプ系ツールの基本情報       *
* 返り値                                   *
*	作成したボタンテーブルのウィジェット   *
*******************************************/
static GtkWidget* CreateStampSelectTable(STAMP_CORE* core)
{
// ボタンに表示するアイコンのサイズ
#define ICON_SIZE 32
	// 返り値
	GtkWidget *table;
	// ボタンに登録するイメージウィジェット
	GtkWidget *image;
	// テーブルの高さ
	int height;
	// ボタンのイメージ作成用ピクセルバッファ
	GdkPixbuf *pixbuf, *scaled_buf;
	// チャンネル数が1のときに使用するピクセルデータ
	uint8 *pixels;
	// BGR→RGB変換用
	uint8 *swap_pixels;
	// イメージの幅、高さ
	int image_width, image_height;
	// イメージの一行分のバイト数
	int image_stride;
	// イメージのピクセル
	uint8 *image_pixel;
	// イメージの拡大率
	FLOAT_T zoom;
	// ボタンID調整用
	int button_add = 0;
	// テーブルの座標
	int x = 0, y = 0;
	// for文用のカウンタ
	int i = 0, j;

	// ボタン配列作成
	core->buttons = (GtkWidget**)MEM_ALLOC_FUNC(
		sizeof(*core->buttons)*(core->app->stamps.num_pattern+1));
	core->num_button = core->app->stamps.num_pattern;

	// テーブルの高さを決定して作成
	height = core->num_button / STAMP_SELECT_TABLE_WIDTH;
	if((core->num_button+1) % STAMP_SELECT_TABLE_WIDTH != 0)
	{
		height++;
	}
	table = gtk_table_new(height, STAMP_SELECT_TABLE_WIDTH, TRUE);

	// クリップボードのパターンがあるならば
	if(core->app->stamps.has_clip_board_pattern != FALSE)
	{
		PATTERN* pattern = &core->app->stamps.clip_board;

		pixbuf = gdk_pixbuf_new_from_data(pattern->pixels,
			GDK_COLORSPACE_RGB, TRUE, 8, pattern->width, pattern->height,
			pattern->stride, NULL, NULL
		);

		// 拡大率を計算
		if(pattern->width > pattern->height)
		{
			zoom = ICON_SIZE / (FLOAT_T)pattern->width;
		}
		else
		{
			zoom = ICON_SIZE / (FLOAT_T)pattern->height;
		}

		// ピクセルバッファを拡大縮小してイメージウィジェット作成
		image = gtk_image_new_from_pixbuf(
			gdk_pixbuf_scale_simple(pixbuf, (int)(pattern->width*zoom),
			(int)(pattern->height*zoom), GDK_INTERP_BILINEAR)
		);

		// ボタン作成
		core->buttons[i] = gtk_toggle_button_new();
		// 現在の使用パターンと一致していたらアクティブに
		if(i == core->stamp_id + button_add)
		{
			gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(core->buttons[i]), TRUE);
		}

		// コールバック関数とデータをセット
		(void)g_signal_connect(G_OBJECT(core->buttons[i]), "toggled", G_CALLBACK(StampSelectButtonClicked), core);
		g_object_set_data(G_OBJECT(core->buttons[i]), "stamp-id", GINT_TO_POINTER(i));

		// テーブルにボタン追加
		gtk_table_attach(GTK_TABLE(table), core->buttons[i], x, x+1, y, y+1, GTK_SHRINK, GTK_SHRINK, 0, 0);

		// イメージウィジェットをボタンに登録
		gtk_container_add(GTK_CONTAINER(core->buttons[i]), image);

		g_object_unref(pixbuf);
		core->num_button++;
		button_add = -1;
		i++, x++;
	}

	// ボタンを作成してテーブルに入れる
	for( ; i<core->num_button; i++, x++)
	{
		// ボタンに入れるパターン
		PATTERN* pattern = &core->app->stamps.patterns[i+button_add];

		// 一行分埋まったら次の行へ
		if(x == STAMP_SELECT_TABLE_WIDTH)
		{
			x = 0;
			y++;
		}

		pixels = NULL;
		// グレースケールならRGBにする
		if(pattern->channel == 1)
		{
			pixels = (uint8*)MEM_ALLOC_FUNC(pattern->stride*pattern->height*3);

#ifdef _OPENMP
#pragma omp parallel for firstprivate(pixels)
#endif
			for(j=0; j<pattern->stride*pattern->height; j++)
			{
				uint8 pixel_value = 0xff - pattern->pixels[j];
				pixels[j*3] = pixel_value;
				pixels[j*3+1] = pixel_value;
				pixels[j*3+2] = pixel_value;
			}
			pixbuf = gdk_pixbuf_new_from_data(
				pixels, GDK_COLORSPACE_RGB, FALSE, 8,
				pattern->width, pattern->height, pattern->stride*3, NULL, NULL
			);
		}
		else if(pattern->channel == 2)
		{
			pixels = (uint8*)MEM_ALLOC_FUNC(pattern->width*pattern->height*4);

			image_width = pattern->width;
			image_stride = pattern->stride;
			image_pixel = pattern->pixels;
#ifdef _OPENMP
#pragma omp parallel for firstprivate(image_width, image_stride, pixels, image_pixel)
#endif
			for(j=0; j<pattern->height; j++)
			{
				uint8 pixel_value;
				int k;

				for(k=0; k<image_width; k++)
				{
					pixel_value = image_pixel[j*image_stride+k*2];
					pixels[j*image_width*4+k*4] = pixel_value;
					pixels[j*image_width*4+k*4+1] = pixel_value;
					pixels[j*image_width*4+k*4+2] = pixel_value;
					pixels[j*image_width*4+k*4+3] = image_pixel[j*pattern->stride+k*2+1];
				}
			}
			pixbuf = gdk_pixbuf_new_from_data(
				pixels, GDK_COLORSPACE_RGB, TRUE, 8,
				pattern->width, pattern->height, pattern->width*4, NULL, NULL
			);
		}
		else
		{
			// パターンのピクセルデータからピクセルバッファ作成
			pixbuf = gdk_pixbuf_new_from_data(pattern->pixels, GDK_COLORSPACE_RGB,
				pattern->channel == 4, 8, pattern->width, pattern->height, pattern->width*pattern->channel,
				NULL, NULL
			);
		}

		// 拡大率を計算
		if(pattern->width > pattern->height)
		{
			zoom = ICON_SIZE / (FLOAT_T)pattern->width;
		}
		else
		{
			zoom = ICON_SIZE / (FLOAT_T)pattern->height;
		}

		scaled_buf = gdk_pixbuf_scale_simple(pixbuf, (int)(pattern->width*zoom),
			(int)(pattern->height*zoom), GDK_INTERP_BILINEAR);
		swap_pixels = gdk_pixbuf_get_pixels(scaled_buf);
		if(swap_pixels != NULL)
		{
			int channel;
			image_width = gdk_pixbuf_get_width(scaled_buf);
			image_height = gdk_pixbuf_get_height(scaled_buf);

			if(gdk_pixbuf_get_has_alpha(scaled_buf) == FALSE)
			{
				channel = 3;
			}
			else
			{
				channel = 4;
			}

#ifdef _OPENMP
#pragma omp parallel for
#endif
			for(j=0; j<image_width*image_height; j++)
			{
				uint8 r = swap_pixels[j*channel];
				swap_pixels[j*channel] = swap_pixels[j*channel+2];
				swap_pixels[j*channel+2] = r;
			}
		}
		// ピクセルバッファを拡大縮小してイメージウィジェット作成
		image = gtk_image_new_from_pixbuf(scaled_buf);

		// ボタン作成
		core->buttons[i] = gtk_toggle_button_new();
		// 現在の使用パターンと一致していたらアクティブに
		if(i == core->stamp_id + button_add)
		{
			gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(core->buttons[i]), TRUE);
		}

		// コールバック関数とデータをセット
		(void)g_signal_connect(G_OBJECT(core->buttons[i]), "toggled", G_CALLBACK(StampSelectButtonClicked), core);
		g_object_set_data(G_OBJECT(core->buttons[i]), "stamp-id", GINT_TO_POINTER(i));

		// テーブルにボタン追加
		gtk_table_attach(GTK_TABLE(table), core->buttons[i], x, x+1, y, y+1, GTK_SHRINK, GTK_SHRINK, 0, 0);

		// イメージウィジェットをボタンに登録
		gtk_container_add(GTK_CONTAINER(core->buttons[i]), image);

		g_object_unref(pixbuf);
		g_object_unref(scaled_buf);
		MEM_FREE_FUNC(pixels);
	}

	return table;
}

static void OnStampDetailUIDestroy(GtkWidget* widget, STAMP_CORE* core)
{
	MEM_FREE_FUNC(core->buttons);
}

/*****************************************************
* CreateStampCoreDetailUI関数                        *
* スタンプの基本情報を設定するUIを作成               *
* 引数                                               *
* core	: スタンプ系ツールの基本情報                 *
* app	: アプリケーションを管理する構造体のアドレス *
* box	: UIウィジェットを入れるパッキングボックス   *
*****************************************************/
static void CreateStampCoreDetailUI(
	STAMP_CORE* core,
	uint8* mode,
	APPLICATION* app,
	GtkWidget* box
)
{
#define UI_FONT_SIZE 8.0
	// ラベル、スライダ
	GtkWidget* label, *scale;
	// スクロールドウィンドウ
	GtkWidget* scrolled_window;
	// ウィジェット整列用のテーブル
	GtkWidget* table;
	// 回転方向、モード設定用のラジオボタン
	GtkWidget* radio_buttons[PATTERN_MODE_NUM];
	// 筆圧使用設定のチェックボックス
	GtkWidget* check_button;
	// スライダに使用するアジャスタ
	GtkAdjustment* scale_adjustment;
	// ラベルのフォント変更用のマークアップバッファ
	char mark_up_buff[256];
	// 初期着色モード
	int first_mode = (mode != NULL) ? (int)(*mode) : 0;

	// アプリケーション管理の構造体へのポインタをセット
	core->app = app;

	// クリップボードのパターンを更新
	UpdateClipBoardPattern(&app->stamps);

	// 拡大縮小率設定用のウィジェット
	scale_adjustment = GTK_ADJUSTMENT(gtk_adjustment_new(
		(1 / core->scale) * 100, 10, 300, 0.1, 0.1, 0));
	scale = SpinScaleNew(scale_adjustment,
		app->labels->tool_box.brush_scale, 1);
	(void)g_signal_connect(G_OBJECT(scale_adjustment), "value_changed",
		G_CALLBACK(StampCoreChangeScale), core);
	g_object_set_data(G_OBJECT(scale_adjustment), "application", app);
	gtk_box_pack_start(GTK_BOX(box), scale, FALSE, FALSE, 0);

	// 濃度変更用ウィジェット
	scale_adjustment = GTK_ADJUSTMENT(gtk_adjustment_new(
		core->flow * 100, 0, 100, 0.1, 0.1, 0));
	scale = SpinScaleNew(scale_adjustment,
		app->labels->tool_box.flow, 1);
	g_object_set_data(G_OBJECT(scale_adjustment), "application", app);
	(void)g_signal_connect(G_OBJECT(scale_adjustment), "value_changed",
		G_CALLBACK(StampCoreChangeFlow), core);
	table = gtk_table_new(1, 3, TRUE);
	gtk_table_attach_defaults(GTK_TABLE(table), scale, 0, 3, 0, 1);
	gtk_box_pack_start(GTK_BOX(box), table, FALSE, TRUE, 0);

	// 間隔変更用ウィジェット
	scale_adjustment = GTK_ADJUSTMENT(gtk_adjustment_new(
		core->stamp_distance, 0.1, 3, 0.1, 0.1, 0));
	scale = SpinScaleNew(scale_adjustment,
		app->labels->tool_box.distance, 1);
	(void)g_signal_connect(G_OBJECT(scale_adjustment), "value_changed",
		G_CALLBACK(StampCoreChangeDistance), core);
	g_object_set_data(G_OBJECT(scale_adjustment), "application", app);
	gtk_box_pack_start(GTK_BOX(box), scale, FALSE, FALSE, 0);

	// 開始回転角変更用ウィジェット
	scale_adjustment = GTK_ADJUSTMENT(gtk_adjustment_new(
		fabs(core->rotate_start) * 180 / G_PI, 0, 360, 0.1, 0.1, 0));
	scale = SpinScaleNew(scale_adjustment,
		app->labels->tool_box.rotate_start, 1);
	g_object_set_data(G_OBJECT(scale_adjustment), "application", app);
	(void)g_signal_connect(G_OBJECT(scale_adjustment), "value_changed",
		G_CALLBACK(StampCoreChangeRotateStart), core);
	gtk_box_pack_start(GTK_BOX(box), scale, FALSE, FALSE, 0);

	// 回転速度変更用ウィジェット
	scale_adjustment = GTK_ADJUSTMENT(gtk_adjustment_new(
		fabs(core->rotate_speed) * 180 / G_PI, 0, 360, 0.1, 0.1, 0));
	scale = SpinScaleNew(scale_adjustment,
		app->labels->tool_box.rotate_speed, 1);
	(void)g_signal_connect(G_OBJECT(scale_adjustment), "value_changed",
		G_CALLBACK(StampCoreChangeRotateSpeed), core);
	g_object_set_data(G_OBJECT(scale_adjustment), "application", app);
	gtk_box_pack_start(GTK_BOX(box), scale, FALSE, FALSE, 0);

	// 回転方向変更用ウィジェット
	radio_buttons[0] = gtk_radio_button_new_with_label(NULL, app->labels->tool_box.clockwise);
	radio_buttons[1] = gtk_radio_button_new_with_label(
		gtk_radio_button_get_group(GTK_RADIO_BUTTON(radio_buttons[0])),
		app->labels->tool_box.counter_clockwise
	);

	if(core->rotate_direction < 0)
	{
		gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(radio_buttons[0]), TRUE);
	}
	else
	{
		gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(radio_buttons[1]), TRUE);
	}

	g_object_set_data(G_OBJECT(radio_buttons[0]), "direction", GINT_TO_POINTER(-1));
	g_object_set_data(G_OBJECT(radio_buttons[0]), "application", app);
	(void)g_signal_connect(G_OBJECT(radio_buttons[0]), "toggled", G_CALLBACK(StampCoreChangeRotateDirection), core);
	g_object_set_data(G_OBJECT(radio_buttons[1]), "direction", GINT_TO_POINTER(1));
	g_object_set_data(G_OBJECT(radio_buttons[1]), "application", app);
	(void)g_signal_connect(G_OBJECT(radio_buttons[1]), "toggled", G_CALLBACK(StampCoreChangeRotateDirection), core);
	table = gtk_hbox_new(FALSE, 0);
	gtk_box_pack_start(GTK_BOX(table), radio_buttons[0], FALSE, TRUE, 0);
	gtk_box_pack_start(GTK_BOX(table), radio_buttons[1], FALSE, TRUE, 0);
	gtk_box_pack_start(GTK_BOX(box), table, FALSE, TRUE, 0);

	// 着色モード変更用ウィジェット
	if(mode != NULL)
	{
		core->mode_select[0] = radio_buttons[0] = gtk_radio_button_new_with_label(NULL, app->labels->tool_box.saturation);
		core->mode_select[1] = radio_buttons[1] = gtk_radio_button_new_with_label(
			gtk_radio_button_get_group(GTK_RADIO_BUTTON(radio_buttons[0])),
			app->labels->tool_box.brightness
		);
		core->mode_select[2] = radio_buttons[2] = gtk_radio_button_new_with_label(
			gtk_radio_button_get_group(GTK_RADIO_BUTTON(radio_buttons[0])),
			app->labels->tool_box.gradation_reverse
		);
		gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(radio_buttons[*mode]), TRUE);
		g_object_set_data(G_OBJECT(radio_buttons[0]), "mode", GINT_TO_POINTER(0));
		g_object_set_data(G_OBJECT(radio_buttons[0]), "application", app);
		g_object_set_data(G_OBJECT(radio_buttons[0]), "stamp_core", core);
		(void)g_signal_connect(G_OBJECT(radio_buttons[0]), "toggled", G_CALLBACK(StampCoreSetMode), mode);
		g_object_set_data(G_OBJECT(radio_buttons[1]), "mode", GINT_TO_POINTER(1));
		g_object_set_data(G_OBJECT(radio_buttons[1]), "application", app);
		g_object_set_data(G_OBJECT(radio_buttons[1]), "stamp_core", core);
		(void)g_signal_connect(G_OBJECT(radio_buttons[1]), "toggled", G_CALLBACK(StampCoreSetMode), mode);
		g_object_set_data(G_OBJECT(radio_buttons[2]), "mode", GINT_TO_POINTER(2));
		g_object_set_data(G_OBJECT(radio_buttons[2]), "application", app);
		g_object_set_data(G_OBJECT(radio_buttons[2]), "stamp_core", core);
		(void)g_signal_connect(G_OBJECT(radio_buttons[2]), "toggled", G_CALLBACK(StampCoreSetMode), mode);
		table = gtk_hbox_new(FALSE, 0);
		gtk_box_pack_start(GTK_BOX(table), radio_buttons[0], FALSE, TRUE, 0);
		gtk_box_pack_start(GTK_BOX(table), radio_buttons[1], FALSE, TRUE, 0);
		gtk_box_pack_start(GTK_BOX(box), table, FALSE, TRUE, 0);
		gtk_box_pack_start(GTK_BOX(box), radio_buttons[2], FALSE, TRUE, 0);
	}

	// 左右反転、上下反転選択用チェックボックス
	table = gtk_hbox_new(FALSE, 0);
	label = gtk_label_new("");
	(void)sprintf(mark_up_buff, "<span font_desc=\"%.2f\">%s : </span>",
		UI_FONT_SIZE * app->gui_scale, app->labels->tool_box.reverse);
	gtk_label_set_markup(GTK_LABEL(label), mark_up_buff);
	gtk_box_pack_start(GTK_BOX(table), label, FALSE, FALSE, 0);
	check_button = gtk_check_button_new_with_label(app->labels->tool_box.reverse_horizontally);
	g_object_set_data(G_OBJECT(check_button), "flag-id", GINT_TO_POINTER(0));
	g_object_set_data(G_OBJECT(check_button), "application", app);
	gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(check_button),
		core->pattern_flags & PATTERN_FLIP_HORIZONTALLY);
	(void)g_signal_connect(G_OBJECT(check_button), "toggled", G_CALLBACK(StampCoreSetPatternFlags), core);
	gtk_box_pack_start(GTK_BOX(table), check_button, FALSE, TRUE, 0);
	check_button = gtk_check_button_new_with_label(app->labels->tool_box.reverse_vertically);
	g_object_set_data(G_OBJECT(check_button), "flag-id", GINT_TO_POINTER(1));
	g_object_set_data(G_OBJECT(check_button), "application", app);
	gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(check_button),
		core->pattern_flags & PATTERN_FLIP_VERTICALLY);
	(void)g_signal_connect(G_OBJECT(check_button), "toggled", G_CALLBACK(StampCoreSetPatternFlags), core);
	gtk_box_pack_start(GTK_BOX(table), check_button, FALSE, TRUE, 0);
	gtk_box_pack_start(GTK_BOX(box), table, FALSE, TRUE, 0);

	// 筆圧使用設定変更用ウィジェット
	table = gtk_hbox_new(FALSE, 0);
	label = gtk_label_new("");
	(void)sprintf(mark_up_buff, "<span font_desc=\"%.2f\">%s : </span>",
		UI_FONT_SIZE * app->gui_scale, app->labels->tool_box.pressure);
	gtk_label_set_markup(GTK_LABEL(label), mark_up_buff);
	gtk_box_pack_start(GTK_BOX(table), label, FALSE, FALSE, 0);
	check_button = gtk_check_button_new_with_label(app->labels->tool_box.scale);
	g_object_set_data(G_OBJECT(check_button), "flag-id", GINT_TO_POINTER(0));
	gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(check_button), core->flags & BRUSH_FLAG_SIZE);
	(void)g_signal_connect(G_OBJECT(check_button), "toggled", G_CALLBACK(StampCoreSetFlags), core);
	gtk_box_pack_start(GTK_BOX(table), check_button, FALSE, TRUE, 0);
	check_button = gtk_check_button_new_with_label(app->labels->tool_box.flow);
	g_object_set_data(G_OBJECT(check_button), "flag-id", GINT_TO_POINTER(1));
	gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(check_button), core->flags & BRUSH_FLAG_FLOW);
	(void)g_signal_connect(G_OBJECT(check_button), "toggled", G_CALLBACK(StampCoreSetFlags), core);
	gtk_box_pack_start(GTK_BOX(table), check_button, FALSE, TRUE, 0);
	gtk_box_pack_start(GTK_BOX(box), table, FALSE, FALSE, 0);
	check_button = gtk_check_button_new_with_label(app->labels->tool_box.random_size);
	g_object_set_data(G_OBJECT(check_button), "flag-value", GUINT_TO_POINTER(STAMP_RANDOM_SIZE));
	g_object_set_data(G_OBJECT(check_button), "application", app);
	gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(check_button), core->flags & STAMP_RANDOM_SIZE);
	(void)g_signal_connect(G_OBJECT(check_button), "toggled", G_CALLBACK(StampCoreSetFlag), core);
	gtk_box_pack_start(GTK_BOX(box), check_button, FALSE, TRUE, 0);
	// ランダムに回転
	check_button = gtk_check_button_new_with_label(app->labels->tool_box.random_rotate);
	gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(check_button), (core->flags & STAMP_RANDOM_ROTATE) != 0);
	g_object_set_data(G_OBJECT(check_button), "flag-value", GUINT_TO_POINTER(STAMP_RANDOM_ROTATE));
	g_object_set_data(G_OBJECT(check_button), "application", app);
	(void)g_signal_connect(G_OBJECT(check_button), "toggled", G_CALLBACK(StampCoreSetFlag), core);
	gtk_box_pack_start(GTK_BOX(box), check_button, FALSE, TRUE, 0);

	// 詳細設定のUIが閉じられるときにボタン配列を開放する
	(void)g_signal_connect(G_OBJECT(box), "destroy", G_CALLBACK(OnStampDetailUIDestroy), core);

	// スタンプ選択テーブルを作成してスクロールドウィンドウに入れる
	table = gtk_hbox_new(FALSE, 0);
	scrolled_window = gtk_scrolled_window_new(NULL, NULL);
	gtk_widget_set_size_request(table,
		ICON_SIZE*STAMP_SELECT_TABLE_WIDTH+4, ICON_SIZE*4+4);
	gtk_scrolled_window_add_with_viewport(GTK_SCROLLED_WINDOW(scrolled_window),
		CreateStampSelectTable(core));
	gtk_scrolled_window_set_policy(GTK_SCROLLED_WINDOW(scrolled_window),
		GTK_POLICY_NEVER, GTK_POLICY_AUTOMATIC);
	gtk_box_pack_start(GTK_BOX(table), scrolled_window, FALSE, FALSE, 0);
	gtk_box_pack_start(GTK_BOX(box), table, FALSE, TRUE, 0);

	// クリップボードのスタンプがアクティブならばセット
	if(app->stamps.has_clip_board_pattern != FALSE)
	{
		if(core->stamp_id == 0)
		{
			app->stamps.active_pattern =
				&app->stamps.clip_board;
		}
		else
		{
			app->stamps.active_pattern =
				&app->stamps.patterns[core->stamp_id-1];
		}
	}

	// アクティブなパターンがチャンネル数2以外ならば着色モードは無効
	if(mode != NULL)
	{
		gtk_widget_set_sensitive(core->mode_select[0], app->stamps.active_pattern->channel == 2);
		gtk_widget_set_sensitive(core->mode_select[1], app->stamps.active_pattern->channel == 2);
		gtk_widget_set_sensitive(core->mode_select[2], app->stamps.active_pattern->channel == 2);
	}

	core->mode = mode;

	InitializeStampCore(core, first_mode, app);
#undef UI_FONT_SIZE
#undef ICON_SIZE
}

/*************************************************************
* StampToolButtonPressCallBack関数                           *
* スタンプツールでマウスクリックされたときのコールバック関数 *
* 引数                                                       *
* window	: 描画領域の情報                                 *
* x			: マウスのX座標                                  *
* y			: マウスのY座標                                  *
* pressure	: 筆圧                                           *
* core		: ツールの基本情報                               *
* state		: マウスの状態                                   *
*************************************************************/
static void StampToolButtonPressCallBack(
	DRAW_WINDOW* window,
	FLOAT_T x,
	FLOAT_T y,
	FLOAT_T pressure,
	BRUSH_CORE *core,
	void* state
)
{
	// 左クリックなら
	if(((GdkEventButton*)state)->button == 1)
	{
		// スタンプツールの詳細データへキャスト
		STAMP* stamp = (STAMP*)core->brush_data;
		// スタンプ用のブラシ
		cairo_pattern_t* brush;
		// 拡大縮小、回転用の行列
		cairo_matrix_t matrix;
		// スタンプの半径、濃度
		FLOAT_T r, alpha;
		// スタンプする座標の最大最小
		FLOAT_T min_x, min_y, max_x, max_y;
		// スタンプの拡大縮小率
		FLOAT_T zoom;
		// スタンプの描画座標計算用
		FLOAT_T cos_x, sin_y, trans_x, trans_y;
		FLOAT_T half_width, half_height;

		// 回転角を初期化
			// ランダム回転のON/OFFで処理を切り替え
		if((stamp->core.flags & STAMP_RANDOM_ROTATE) == 0)
		{	// ランダム回転OFF
			stamp->core.rotate = stamp->core.rotate_start;
		}
		else
		{	// ランダム回転ON
			stamp->core.rotate = (rand() / (FLOAT_T)RAND_MAX) * (2*G_PI);
		}

		// 不透明度保護の有無で合成モード変更
		if((window->active_layer->flags & LAYER_LOCK_OPACITY) == 0)
		{
			window->work_layer->layer_mode = LAYER_BLEND_NORMAL;
		}
		else
		{
			window->work_layer->layer_mode = LAYER_BLEND_ATOP;
		}

		// スタンプの半径計算
		if((stamp->core.flags & BRUSH_FLAG_SIZE) == 0)
		{
			r = stamp->core.r, zoom = stamp->core.scale;
			half_width = stamp->core.half_width;
			half_height = stamp->core.half_height;
		}
		else
		{
			r =  stamp->core.r * pressure, zoom = stamp->core.scale * (1 / pressure);
			half_width = stamp->core.half_width * pressure;
			half_height = stamp->core.half_height * pressure;
		}

		// ランダムサイズがONなら乱数でサイズ変更
		if((stamp->core.flags & STAMP_RANDOM_SIZE) != 0)
		{
			FLOAT_T rate = rand() / (FLOAT_T)RAND_MAX;
			r *= rate;
			half_width *= rate;
			half_height *= rate;
		}

		// スタンプの濃度計算
		alpha = ((stamp->core.flags & BRUSH_FLAG_FLOW) == 0) ?
			stamp->core.flow : stamp->core.flow * pressure;

		// 前回のスタンプサーフェースを削除して新たに作成
		if(stamp->core.brush_surface != NULL)
		{
			cairo_surface_destroy(stamp->core.brush_surface);
		}
		stamp->core.brush_surface = CreatePatternSurface(
			&window->app->stamps, *core->color, window->app->tool_window.color_chooser->back_rgb,
				stamp->core.pattern_flags, stamp->mode, alpha);

		// 最大最小の座標計算
		min_x = x - r, min_y = y - r;
		max_x = x + r, max_y = y + r;

		// 現在の座標を記憶
		stamp->core.before_x = x, stamp->core.before_y = y;

		// 描画領域からはみ出ていたら補正
		if(min_x < 0.0)
		{
			min_x = 0.0;
		}
		if(min_y < 0.0)
		{
			min_y = 0.0;
		}
		if(max_x > window->work_layer->width)
		{
			max_x = window->work_layer->width;
		}
		if(max_y > window->work_layer->height)
		{
			max_y = window->work_layer->height;
		}

		core->min_x = min_x, core->min_y = min_y;
		core->max_x = max_x, core->max_y = max_y;

		// 平行移動する座標を計算
		cos_x = cos(stamp->core.rotate), sin_y = sin(stamp->core.rotate);
		trans_x = x - (half_width * cos_x + half_height * sin_y);
		trans_y = y + (half_width * sin_y - half_height * cos_x);
		// 拡大縮小率、回転角をセット
		cairo_set_operator(window->work_layer->cairo_p, CAIRO_OPERATOR_OVER);
		brush = cairo_pattern_create_for_surface(stamp->core.brush_surface);
		cairo_pattern_set_extend(brush, CAIRO_EXTEND_NONE);
		cairo_matrix_init_scale(&matrix, zoom, zoom);
		cairo_matrix_rotate(&matrix, stamp->core.rotate);
		cairo_matrix_translate(&matrix,  - trans_x, - trans_y);

		// 移動用の行列をブラシにセット
		cairo_pattern_set_matrix(brush, &matrix);
		// 作成したブラシを作業レイヤーにセット
		cairo_set_source(window->work_layer->cairo_p, brush);

		// 選択範囲の有無で塗り潰し方法変更
		if((window->flags & DRAW_WINDOW_HAS_SELECTION_AREA) == 0)
		{	// 選択範囲無し
			cairo_paint(window->work_layer->cairo_p);
		}
		else
		{	// 選択範囲有
			cairo_mask_surface(window->work_layer->cairo_p, window->selection->surface_p,
				0, 0);
		}

		// ブラシ削除
		cairo_pattern_destroy(brush);

		// 回転角を更新
		stamp->core.rotate += stamp->core.rotate_speed;
	}
}

#define StampToolEditSelectionPressCallBack StampToolButtonPressCallBack

/*************************************************************
* StampToolMotionCallBack関数                                *
* スタンプツールでマウスドラッグされたときのコールバック関数 *
* 引数                                                       *
* window	: 描画領域の情報                                 *
* x			: マウスのX座標                                  *
* y			: マウスのY座標                                  *
* pressure	: 筆圧                                           *
* core		: ツールの基本情報                               *
* state		: マウスの状態                                   *
*************************************************************/
static void StampToolMotionCallBack(
	DRAW_WINDOW* window,
	FLOAT_T x,
	FLOAT_T y,
	FLOAT_T pressure,
	BRUSH_CORE *core,
	void* state
)
{
	// マウスの左ボタンが押されていたら
	if(((*(GdkModifierType*)state) & GDK_BUTTON1_MASK) != 0)
	{	// スタンプツールの詳細データにキャスト
		STAMP* stamp = (STAMP*)core->brush_data;
		// 前回処理からの距離
		FLOAT_T d;
		// 描画座標計算用
		FLOAT_T dx, dy, cos_x, sin_y;
		FLOAT_T half_width, half_height, zoom;

		// 前回からの距離計算
		dx = x - stamp->core.before_x, dy = y - stamp->core.before_y;
		d = sqrt(dx*dx + dy*dy);

		if(d >= stamp->core.d)
		{	// 距離が一定以上なら
				// スタンプの半径、濃度、前回からの角度
			FLOAT_T r, alpha, arg;
			FLOAT_T min_x, min_y, max_x, max_y;
			int32 clear_x, clear_width, clear_y, clear_height;
			FLOAT_T draw_x = x, draw_y = y;
			// スタンプの拡大縮小、回転、平行移動用の行列
			cairo_matrix_t matrix;
			// スタンプの移動位置計算用
			FLOAT_T trans_x, trans_y;
			FLOAT_T stamp_cos_x, stamp_sin_y;
			// スタンプブラシ
			cairo_pattern_t* brush;
			// 作業レイヤーの一行分のバイト数
			int layer_stride = window->work_layer->stride;
			// 作業レイヤーのピクセル
			uint8 *work_pixel = window->work_layer->pixels;
			// 一時保存レイヤーのピクセル
			uint8 *temp_pixel = window->temp_layer->pixels;
			// for文用のカウンタ
			int i;

			// ランダム回転がONなら角度変更
			if((stamp->core.flags & STAMP_RANDOM_ROTATE) != 0)
			{
				stamp->core.rotate = (rand() / (FLOAT_T)RAND_MAX) * (2*G_PI);
			}

			arg = atan2(dy, dx);
			cos_x = cos(arg), sin_y = sin(arg);

			// スタンプの半径計算
			if((stamp->core.flags & BRUSH_FLAG_SIZE) == 0)
			{
				r = stamp->core.r, zoom = stamp->core.scale;
				half_width = stamp->core.half_width;
				half_height = stamp->core.half_height;
			}
			else
			{
				r =  stamp->core.r * pressure, zoom = stamp->core.scale * (1 / pressure);
				half_width = stamp->core.half_width * pressure;
				half_height = stamp->core.half_height * pressure;
			}

			// ランダムサイズがONならサイズ変更
			if((stamp->core.flags & STAMP_RANDOM_SIZE) != 0)
			{
				FLOAT_T rate = rand() / (FLOAT_T)RAND_MAX;
				r *= rate;
				half_width *= rate;
				half_height *= rate;
			}

			// スタンプの濃度計算
			alpha = ((stamp->core.flags & BRUSH_FLAG_FLOW) == 0) ?
				stamp->core.flow : stamp->core.flow * pressure;

			// 現在の座標を記憶
			stamp->core.before_x = x, stamp->core.before_y = y;

			// 最大最小の座標を更新
			min_x = x - r*2, min_y = y - r*2;
			max_x = x + r*2, max_y = y + r*2;

			if(min_x < 0.0)
			{
				min_x = 0.0;
			}
			if(min_y < 0.0)
			{
				min_y = 0.0;
			}
			if(max_x > window->work_layer->width)
			{
				max_x = window->work_layer->width;
			}
			if(max_y > window->work_layer->height)
			{
				max_y = window->work_layer->height;
			}

			if(core->min_x > min_x)
			{
				core->min_x = min_x;
			}
			if(core->min_y > min_y)
			{
				core->min_y = min_y;
			}
			if(core->max_x < max_x)
			{
				core->max_x = max_x;
			}
			if(core->max_y < max_y)
			{
				core->max_y = max_y;
			}

			cairo_set_operator(window->temp_layer->cairo_p, CAIRO_OPERATOR_OVER);
			dx = d;
			do
			{
				clear_x = (int32)(draw_x - r - 1);
				clear_width = (int32)(draw_x + r + 1);
				clear_y = (int32)(draw_y - r - 1);
				clear_height = (int32)(draw_y + r + 1);

				if(clear_x < 0)
				{
					clear_x = 0;
				}
				else if(clear_x >= window->width)
				{
					goto skip_draw;
				}
				if(clear_y < 0)
				{
					clear_y = 0;
				}
				if(clear_height >= window->height)
				{
					clear_height = window->height;
				}
				clear_width = clear_width - clear_x;
				clear_height = clear_height - clear_y;

				if(clear_width <= 0 || clear_height <= 0)
				{
					goto skip_draw;
				}

				for(i=0; i<clear_height; i++)
				{
					(void)memset(&window->temp_layer->pixels[(i+clear_y)*window->work_layer->stride+clear_x*window->work_layer->channel],
						0x0, clear_width*window->work_layer->channel);
				}

				// 平行移動する座標を計算
				stamp_cos_x = cos(stamp->core.rotate), stamp_sin_y = sin(stamp->core.rotate);
				trans_x = x - (half_width * stamp_cos_x + half_height * stamp_sin_y);
				trans_y = y + (half_width * stamp_sin_y - half_height * stamp_cos_x);
				// 拡大縮小率、回転角をセット
				cairo_set_operator(window->temp_layer->cairo_p, CAIRO_OPERATOR_OVER);
				brush = cairo_pattern_create_for_surface(stamp->core.brush_surface);
				cairo_pattern_set_extend(brush, CAIRO_EXTEND_NONE);
				cairo_matrix_init_scale(&matrix, zoom, zoom);
				cairo_matrix_rotate(&matrix, stamp->core.rotate);
				cairo_matrix_translate(&matrix,  - trans_x, - trans_y);

				// 移動用の行列をブラシにセット
				cairo_pattern_set_matrix(brush, &matrix);
				cairo_set_source(window->temp_layer->cairo_p, brush);

				// 選択範囲の有無で処理切り替え
				if((window->flags & DRAW_WINDOW_HAS_SELECTION_AREA) == 0)
				{	// 選択範囲無し
					cairo_paint(window->temp_layer->cairo_p);
				}
				else
				{	// 選択範囲有り
					cairo_mask_surface(window->temp_layer->cairo_p, window->selection->surface_p, 0, 0);
				}

#ifdef _OPENMP
#pragma omp parallel for firstprivate(clear_width, work_pixel, temp_pixel, layer_stride, clear_x, clear_y)
#endif
				// 現在の作業レイヤーに対して、より濃度が大きい方を採用する
				for(i=0; i<clear_height; i++)
				{
					int j, k;
					for(j=0; j<clear_width; j++)
					{
						if(temp_pixel[(clear_y+i)*layer_stride+(clear_x+j)*4+3]
							> work_pixel[(clear_y+i)*layer_stride+(clear_x+j)*4+3])
						{
							for(k=0; k<4; k++)
							{
								work_pixel[(clear_y+i)*layer_stride+(clear_x+j)*4+k] =
									(uint32)(((int)temp_pixel[(clear_y+i)*layer_stride+(clear_x+j)*4+k]
									- (int)work_pixel[(clear_y+i)*layer_stride+(clear_x+j)*4+k])
										* temp_pixel[(clear_y+i)*layer_stride+(clear_x+j)*4+3] >> 8)
										+ work_pixel[(clear_y+i)*layer_stride+(clear_x+j)*4+k];
							}
						}
					}
				}

				cairo_pattern_destroy(brush);

skip_draw:
				dx -= stamp->core.d;
				draw_x -= cos_x*stamp->core.d, draw_y -= sin_y*stamp->core.d;
				stamp->core.rotate += stamp->core.rotate_speed;
			} while(dx >= stamp->core.d);
		}
	}
}

#define StampToolEditSelectionMotionCallBack StampToolMotionCallBack

static void StampToolReleaseCallBack(
	DRAW_WINDOW* window,
	FLOAT_T x,
	FLOAT_T y,
	FLOAT_T pressure,
	BRUSH_CORE *core,
	void* state
)
{
	if(((GdkEventButton*)state)->button == 1)
	{
		STAMP* stamp = (STAMP*)core->brush_data;
		stamp->core.rotate = stamp->core.rotate_start;

		AddBrushHistory(core, window->active_layer);

		window->layer_blend_functions[window->work_layer->layer_mode](window->work_layer, window->active_layer);

		(void)memset(window->work_layer->pixels, 0, window->work_layer->stride*window->work_layer->height);

		window->work_layer->layer_mode = LAYER_BLEND_NORMAL;
	}
}

static void StampToolEditSelectionReleaseCallBack(
	DRAW_WINDOW* window,
	FLOAT_T x,
	FLOAT_T y,
	FLOAT_T pressure,
	BRUSH_CORE *core,
	void* state
)
{
	if(((GdkEventButton*)state)->button == 1)
	{
		STAMP* stamp = (STAMP*)core->brush_data;
		stamp->core.rotate = stamp->core.rotate_start;

		AddSelectionEditHistory(core, window->selection);

		g_blend_selection_funcs[window->selection->layer_mode](window->work_layer, window->selection);

		(void)memset(window->work_layer->pixels, 0, window->work_layer->stride*window->work_layer->height);

		window->work_layer->layer_mode = LAYER_BLEND_NORMAL;
		window->selection->layer_mode = SELECTION_BLEND_NORMAL;
	}
}

/*****************************************
* StampDrawCursor関数                    *
* スタンプツールのカーソルを描画する     *
* 引数                                   *
* window	: 描画領域の情報             *
* x			: マウスのX座標              *
* y			: マウスのY座標              *
* data		: スタンプツールの詳細データ *
*****************************************/
static void StampToolDrawCursor(
	DRAW_WINDOW* window,
	FLOAT_T x,
	FLOAT_T y,
	void* data
)
{
	StampCoreDrawCursor(window, x, y, &((STAMP*)data)->core);
}

static void StampToolButtonUpdate(DRAW_WINDOW* window, FLOAT_T x, FLOAT_T y, STAMP* stamp)
{
	FLOAT_T r;

	if(stamp->core.half_width > stamp->core.half_height)
	{
		r = stamp->core.half_width * 2 * window->zoom_rate + 1;
	}
	else
	{
		r = stamp->core.half_height * 2 * window->zoom_rate + 1;
	}

	gtk_widget_queue_draw_area(window->window, (gint)(x - r - 1),
		(gint)(y - r - 1), (gint)(r * 2 + 3), (gint)(r * 2 + 3));
}

static void StampToolMotionUpdate(DRAW_WINDOW* window, FLOAT_T x, FLOAT_T y, STAMP* stamp)
{
	FLOAT_T start_x, start_y;
	FLOAT_T width, height;
	FLOAT_T r;

	if(stamp->core.half_width > stamp->core.half_height)
	{
		r = stamp->core.half_width * 2 * window->zoom_rate + 1;
	}
	else
	{
		r = stamp->core.half_height * 2 * window->zoom_rate + 1;
	}

	if(window->before_cursor_x < x)
	{
		start_x = window->before_cursor_x - r;
		width = r * 2 + x - window->before_cursor_x;
	}
	else
	{
		start_x = x - r;
		width = r * 2 + window->before_cursor_x - x;
	}

	if(window->before_cursor_y < y)
	{
		start_y = window->before_cursor_y - r;
		height = r * 2 + y - window->before_cursor_y;
	}
	else
	{
		start_y = y - r;
		height = r * 2 + window->before_cursor_y - y;
	}

	gtk_widget_queue_draw_area(window->window,
		(gint)start_x, (gint)start_y, (gint)width + 2, (gint)height + 2);
}

/*****************************************************
* CreateStampToolDetailUI関数                        *
* スタンプツールの詳細設定UIを作成する               *
* 引数                                               *
* app	: アプリケーションを管理する構造体のアドレス *
* data	: スタンプツールの詳細データ                 *
* 返り値                                             *
*	詳細設定UIウィジェット                           *
*****************************************************/
static GtkWidget* CreateStampToolDetailUI(APPLICATION* app, BRUSH_CORE* core)
{
	STAMP* stamp = (STAMP*)core->brush_data;
	GtkWidget* vbox = gtk_vbox_new(FALSE, 2);

	CreateStampCoreDetailUI(&stamp->core, &stamp->mode, app, vbox);

	return vbox;
}

static void ImageBrushPressCallBack(
	DRAW_WINDOW* window,
	FLOAT_T x,
	FLOAT_T y,
	FLOAT_T pressure,
	BRUSH_CORE *core,
	void* state
)
{
	// 左クリックなら
	if(((GdkEventButton*)state)->button == 1)
	{
		// ブラシの詳細情報にキャスト
		IMAGE_BRUSH *brush = (IMAGE_BRUSH*)core->brush_data;
		// ブラシの半径
		FLOAT_T r;
		// 座標の最大値・最小値
		FLOAT_T min_x, min_y, max_x, max_y;

		window->work_layer->layer_mode = brush->blend_mode;

		r = ((brush->core.flags & STAMP_PRESSURE_SIZE) == 0) ?
			brush->core.r : brush->core.r * pressure;

		if((brush->core.flags & STAMP_RANDOM_SIZE) != 0)
		{
			r *= rand() / (FLOAT_T)RAND_MAX;
		}

		brush->stamp_distance = 0;
		brush->core.before_x = x, brush->core.before_y = y;
		brush->points[0][1] = x, brush->points[0][2] = y;
		brush->points[0][3] = pressure;
		brush->sum_distance = brush->travel = brush->finish_length = 0;
		brush->remain_distance = brush->core.d * brush->core.d;
		brush->draw_start = r * brush->out * 0.01 * 4;
		brush->enter_length = r * brush->enter * 0.01 * 4;
		brush->enter_size = (1 - brush->enter * 0.01);
		brush->num_point = 0;
		brush->draw_finished = 0;
		brush->ref_point = 1;

		min_x = x - r, max_x = x + r;
		min_y = y - r, max_y = y + r;

		if(min_x < 0.0)
		{
			min_x = 0.0;
		}
		if(min_y < 0.0)
		{
			min_y = 0.0;
		}
		if(max_x > window->work_layer->width)
		{
			max_x = window->work_layer->width;
		}
		if(max_y > window->work_layer->height)
		{
			max_y = window->work_layer->height;
		}

		core->min_x = min_x, core->min_y = min_y;
		core->max_x = max_x, core->max_y = max_y;

		window->update.x = (int)min_x, window->update.y = (int)min_y;
		window->update.width = (int)max_x - window->update.x;
		window->update.height = (int)max_y - window->update.y;

		window->flags |= DRAW_WINDOW_UPDATE_PART;
	}	// 左クリックなら
		// if(((GdkEventButton*)state)->button == 1)
}

#define ImageBrushEditSelectionPress ImageBrushPressCallBack

static void ImageBrushMotionCallBack(
	DRAW_WINDOW* window,
	FLOAT_T x,
	FLOAT_T y,
	FLOAT_T pressure,
	BRUSH_CORE *core,
	void* state
)
{
	// マウスの左ボタンが押されていたら
	if(((*(GdkModifierType*)state) & GDK_BUTTON1_MASK) != 0)
	{
		// ブラシの詳細情報にキャスト
		IMAGE_BRUSH *brush = (IMAGE_BRUSH*)core->brush_data;
		FLOAT_T distance;
		int index = brush->ref_point % BRUSH_POINT_BUFFER_SIZE;
		// X、Y方向の移動量
		FLOAT_T dx, dy;
		dx = x-brush->core.before_x;
		dy = y-brush->core.before_y;
		distance = dx*dx + dy*dy;
		brush->stamp_distance += distance;
		brush->remain_distance -= distance;

		if(brush->remain_distance <= 0)
		{
			FLOAT_T update_x, update_y, update_r;

			distance = sqrt(distance);
			brush->core.before_x = x, brush->core.before_y = y;
			brush->sum_distance += distance;
			brush->travel += distance;
			brush->points[index][0] = distance;
			brush->points[index][1] = x, brush->points[index][2] = y;
			brush->points[index][3] = pressure;
			brush->ref_point++;

			if(brush->sum_distance >= brush->draw_start
				&& brush->sum_distance >= brush->enter_length)
			{
				// 更新範囲のイメージ情報
				cairo_t *update;
				cairo_surface_t *update_surface;
				// 入りの色補正用
				FLOAT_T enter_alpha;
				// ブラシの半径と不透明度
				FLOAT_T r, alpha;
				// 座標の最大・最小値
				FLOAT_T min_x, min_y, max_x, max_y;
				// ブラシの傾き用
				FLOAT_T diff_x, diff_y;
				// ブラシの移動量
				FLOAT_T d;
				// 描画を行う座標
				FLOAT_T draw_x = brush->core.before_x, draw_y = brush->core.before_y;
				// 画像に対しての拡大・回転処理用の行列データ
				cairo_matrix_t matrix, reset_matrix;
				// 画像の拡大率
				FLOAT_T zoom;
				// 移動量計算用
				FLOAT_T cos_x, sin_y, trans_x, trans_y;
				// 画像の幅・高さの半分
				FLOAT_T half_width, half_height;
				// ピクセルデータをリセットする座標
				int start_x, start_y;
				// 描画する幅、高さ、一行分のバイト数
				int width, height, stride;
				// 作業レイヤーの一行分のバイト数
				int layer_stride = window->work_layer->stride;
				// 作業レイヤーのピクセル
				uint8 *work_pixel = window->work_layer->pixels;
				// 参照ピクセル
				uint8 *mask;
				// 配列のインデックス用
				int ref_point = brush->draw_finished % BRUSH_POINT_BUFFER_SIZE;
				int before_point;
				int i;	// for文用のカウンタ

				cairo_matrix_init_scale(&reset_matrix, 1, 1);

				while(brush->sum_distance > brush->draw_start
					&& brush->draw_finished < brush->ref_point-1
					&& brush->remain_distance <= 0)
				{
					if(brush->finish_length < brush->enter_length)
					{
						enter_alpha = brush->finish_length / brush->enter_length;
						r = brush->enter_size + brush->finish_length * 0.25;
					}
					else
					{
						enter_alpha = 1, r = 1;
					}
					if((brush->core.flags & STAMP_PRESSURE_SIZE) != 0)
					{
						r *= brush->points[ref_point][3];
					}
					if((brush->core.flags & STAMP_RANDOM_SIZE) != 0)
					{
						r *= 1 - (brush->size_range * (rand() / (FLOAT_T)RAND_MAX));
					}

					if(r < MIN_BRUSH_STEP)
					{
						r = MIN_BRUSH_STEP;
					}

					half_width = brush->core.half_width * r;
					half_height = brush->core.half_height * r;
					zoom = (1/r) * brush->core.scale;
					r *= brush->core.r;

					alpha = ((brush->core.flags & BRUSH_FLAG_FLOW) == 0)
						? 1 : brush->points[ref_point][3];
					alpha *= enter_alpha;

					before_point = (ref_point == 0) ? BRUSH_POINT_BUFFER_SIZE - 1 : ref_point - 1;
					d = brush->points[ref_point][0];
					brush->sum_distance -= d;
					if(brush->draw_finished == 0)
					{
						draw_x = brush->points[0][1], draw_y = brush->points[0][2];
					}
					else
					{
						draw_x = brush->points[before_point][1];
						draw_y = brush->points[before_point][2];
					}
					dx = brush->points[ref_point][1] - draw_x;
					dy = brush->points[ref_point][2] - draw_y;
					if((brush->core.flags & STAMP_RANDOM_ROTATE) != 0)
					{
						brush->core.rotate = brush->core.rotate_start +
							(rand() / (FLOAT_T)RAND_MAX) * brush->core.rotate_direction * brush->rotate_range;
						if((brush->core.flags & BRUSH_FLAG_ROTATE) != 0)
						{
							brush->core.rotate += brush->core.rotate_direction * atan2(dy, dx);
						}
					}
					else if((brush->core.flags & BRUSH_FLAG_ROTATE) != 0)
					{
						brush->core.rotate = brush->core.rotate_start + brush->core.rotate_direction * atan2(dy, dx);
					}
					else
					{
						brush->core.rotate = brush->core.rotate_start;
					}
					cos_x = cos(brush->core.rotate), sin_y = sin(brush->core.rotate);
					diff_x = brush->core.d * dx/d, diff_y = brush->core.d * dy/d;

					min_x = brush->points[ref_point][1] - r - 1;
					max_x = brush->points[ref_point][1] + r + 1;
					min_y = brush->points[ref_point][2] - r - 1;
					max_y = brush->points[ref_point][2] + r + 1;

					if(min_x < 0.0)
					{
						min_x = 0.0;
					}
					if(core->min_x > min_x)
					{
						core->min_x = min_x;
					}
					if(min_y < 0.0)
					{
						min_y = 0.0;
					}
					if(core->min_y > min_y)
					{
						core->min_y = min_y;
					}
					if(max_x > window->work_layer->width)
					{
						max_x = window->work_layer->width;
					}
					if(core->max_x < max_x)
					{
						core->max_x = max_x;
					}
					if(max_y > window->work_layer->height)
					{
						min_y = window->work_layer->height;
					}
					if(core->max_y < max_y)
					{
						core->max_y = max_y;
					}

					if(window->update.x > min_x)
					{
						window->update.width += window->update.x - (int)min_x;
						window->update.x = (int)min_x;
					}
					if(window->update.width + window->update.x < max_x)
					{
						window->update.width += (int)max_x - window->update.width + window->update.x;
					}
					if(window->update.y > min_y)
					{
						window->update.height += window->update.y - (int)min_y;
						window->update.y = (int)min_y;
					}
					if(window->update.height + window->update.y < max_y)
					{
						window->update.height += (int)max_y - window->update.height + window->update.y;
					}

					if(brush->stamp_distance >= brush->core.d)
					{
						dx = d;
						do
						{
							start_x = (int)(draw_x - r);
							start_y = (int)(draw_y - r);
							width = (int)(draw_x + r);
							height = (int)(draw_y + r);

							if(start_x < 0)
							{
								start_x = 0;
							}
							else if(start_x > window->work_layer->width)
							{
								goto skip_draw;
							}
							if(start_y < 0)
							{
								start_y = 0;
							}
							else if(start_y > window->work_layer->height)
							{
								goto skip_draw;
							}
							if(width > window->work_layer->width)
							{
								width = window->work_layer->width - start_x;
							}
							else
							{
								width = width - start_x;
							}
							if(height > window->work_layer->height)
							{
								height = window->work_layer->height - start_y;
							}
							else
							{
								height = height - start_y;
							}

							if(width < 0 || height < 0)
							{
								goto skip_draw;
							}

							stride = width*4;

							update_surface = cairo_surface_create_for_rectangle(
								window->mask_temp->surface_p, draw_x - r, draw_y - r, r*2+1, r*2+1);
							update = cairo_create(update_surface);

							for(i=0; i<height; i++)
							{
								(void)memset(&window->mask_temp->pixels[(i+start_y)*window->mask_temp->stride+start_x*4],
									0, stride);
							}

							trans_x = r - (half_width * cos_x + half_height * sin_y);
							trans_y = r + (half_width * sin_y - half_height * cos_x);

							// 行列データに拡大・縮小、回転角をセット
							cairo_set_operator(window->mask_temp->cairo_p, CAIRO_OPERATOR_OVER);
							cairo_matrix_init_scale(&matrix, zoom, zoom);
							cairo_matrix_rotate(&matrix, brush->core.rotate);
							cairo_matrix_translate(&matrix, - trans_x, - trans_y);

							mask = window->mask_temp->pixels;
							if((window->flags & DRAW_WINDOW_HAS_SELECTION_AREA) == 0)
							{
								if((window->active_layer->flags & LAYER_LOCK_OPACITY) == 0)
								{
									cairo_set_source(update, core->brush_pattern);
									cairo_pattern_set_matrix(core->brush_pattern, &matrix);
									cairo_paint_with_alpha(update, alpha);
								}
								else
								{
									cairo_pattern_set_matrix(core->brush_pattern, &reset_matrix);
									cairo_set_source(core->temp_cairo, core->brush_pattern);
									cairo_paint_with_alpha(core->temp_cairo, alpha);
									cairo_set_source(update, core->temp_pattern);
									cairo_pattern_set_matrix(core->temp_pattern, &matrix);
									cairo_mask_surface(update,
										window->active_layer->surface_p, - draw_x + r, - draw_y + r);
								}
							}
							else
							{
								if((window->active_layer->flags & LAYER_LOCK_OPACITY) == 0)
								{
									cairo_pattern_set_matrix(core->brush_pattern, &reset_matrix);
									cairo_set_source(core->temp_cairo, core->brush_pattern);
									cairo_paint_with_alpha(core->temp_cairo, alpha);
									cairo_set_source(update, core->temp_pattern);
									cairo_pattern_set_matrix(core->temp_pattern, &matrix);
									cairo_mask_surface(update,
										window->selection->surface_p, - draw_x + r, - draw_y + r);
								}
								else
								{
									cairo_surface_t *temp_surface = cairo_surface_create_for_rectangle(
										window->temp_layer->surface_p, draw_x-r, draw_y-r, r*2+1, r*2+1
									);
									cairo_t *update_temp = cairo_create(temp_surface);

									for(i=0; i<height; i++)
									{
										(void)memset(&window->temp_layer->pixels[
											(i+start_y)*window->temp_layer->stride+start_x*4],
											0, stride
										);
									}

									cairo_pattern_set_matrix(core->brush_pattern, &reset_matrix);
									cairo_set_source(core->temp_cairo, core->brush_pattern);
									cairo_paint_with_alpha(core->temp_cairo, alpha);
									cairo_set_source(update, core->temp_pattern);
									cairo_mask_surface(update,
										window->selection->surface_p, - draw_x + r, - draw_y + r);
									cairo_set_source_surface(update_temp,
										update_surface, 0, 0);
									cairo_mask_surface(update_temp,
										window->active_layer->surface_p, - draw_x + r, - draw_y + r);

									mask = window->temp_layer->pixels;

									cairo_surface_destroy(temp_surface);
									cairo_destroy(update_temp);
								}
							}

							// テクスチャを適用
							if(window->app->textures.active_texture != 0)
							{
								cairo_surface_t *temp_surface = cairo_surface_create_for_rectangle(
									window->temp_layer->surface_p, draw_x - r, draw_y - r, r*2+1, r*2+1);
								cairo_t *update_temp = cairo_create(temp_surface);

								if(mask == window->mask_temp->pixels)
								{
									for(i=0; i<height; i++)
									{
										(void)memset(&window->temp_layer->pixels[
											(i+start_y)*window->temp_layer->stride+start_x*4],
											0, stride
										);
									}
									cairo_set_source_surface(update_temp,
										update_surface, 0, 0);
									cairo_mask_surface(update_temp, window->texture->surface_p, - draw_x + r, - draw_y + r);
									mask = window->temp_layer->pixels;
								}
								else
								{
									for(i=0; i<height; i++)
									{
										(void)memset(&window->mask_temp->pixels[
											(i+start_y)*window->mask_temp->stride+start_x*4],
											0, stride
										);
									}
									cairo_set_source_surface(update,
										temp_surface, 0, 0);
									cairo_mask_surface(update, window->texture->surface_p, - draw_x + r, - draw_y + r);
									mask = window->mask_temp->pixels;
								}

								cairo_surface_destroy(temp_surface);
								cairo_destroy(update_temp);
							}

							cairo_surface_destroy(update_surface);
							cairo_destroy(update);

#ifdef _OPENMP
#pragma omp parallel for firstprivate(work_pixel, width, start_x, start_y, layer_stride, mask)
#endif
							for(i=0; i<height; i++)
							{
								uint8 *ref_pix = &work_pixel[
									(start_y+i)*layer_stride+start_x*4];
								uint8 *mask_pix = &mask[(start_y+i)*layer_stride
									+start_x*4];
								int j;

								for(j=0; j<width; j++, ref_pix+=4, mask_pix+=4)
								{
									if(ref_pix[3] < mask_pix[3])
									{
										ref_pix[0] = (uint8)((uint32)(((int)mask_pix[0]-(int)ref_pix[0])
											* mask_pix[3] >> 8) + ref_pix[0]);
										ref_pix[1] = (uint8)((uint32)(((int)mask_pix[1]-(int)ref_pix[1])
											* mask_pix[3] >> 8) + ref_pix[1]);
										ref_pix[2] = (uint8)((uint32)(((int)mask_pix[2]-(int)ref_pix[2])
											* mask_pix[3] >> 8) + ref_pix[2]);
										ref_pix[3] = (uint8)((uint32)(((int)mask_pix[3]-(int)ref_pix[3])
											* mask_pix[3] >> 8) + ref_pix[3]);
									}
								}
							}

							update_r = r * window->zoom_rate;
							update_x = ((draw_x-window->width/2)*window->cos_value + (draw_y-window->height/2)*window->sin_value) * window->zoom_rate
								+ window->rev_add_cursor_x;
							update_y = (- (draw_x-window->width/2)*window->sin_value + (draw_y-window->height/2)*window->cos_value) * window->zoom_rate
								+ window->rev_add_cursor_y;
							gtk_widget_queue_draw_area(window->window, (gint)(update_x-update_r), (gint)(update_y-update_r),
								(gint)(update_r * 2 + BRUSH_UPDATE_MARGIN), (gint)(update_r * 2 + BRUSH_UPDATE_MARGIN));
skip_draw:
							dx -= brush->core.d;
							brush->remain_distance += brush->core.d * brush->core.d;
							brush->stamp_distance -= brush->core.d;
							if(brush->remain_distance > 0)
							{
								break;
							}
							else
							{
								draw_x += diff_x, draw_y += diff_y;
							}
						} while(1);
					}

					brush->finish_length += d;
					brush->travel += d;
					brush->draw_finished++;
					ref_point = brush->draw_finished % BRUSH_POINT_BUFFER_SIZE;
				}	// while(brush->sum_distance > brush->draw_start
						// && brush->draw_finished < brush->ref_point)
			}	// if(brush->sum_distance >= brush->draw_start
					// && brush->sum_distance >= brush->enter_length)
		}	// if(distance >= 1.0)

		window->flags |= DRAW_WINDOW_UPDATE_PART;
	}	// マウスの左ボタンが押されていたら
		// if(((*(GdkModifierType*)state) & GDK_BUTTON1_MASK) != 0)
}

#define ImageBrushEditSelectionMotion ImageBrushMotionCallBack

static void ImageBrushReleaseCallBack(
	DRAW_WINDOW* window,
	FLOAT_T x,
	FLOAT_T y,
	FLOAT_T pressure,
	BRUSH_CORE *core,
	void* state
)
{
	// マウスの左ボタンなら
	if(((GdkEventButton*)state)->button == 1)
	{
		// ブラシの詳細情報にキャスト
		IMAGE_BRUSH *brush = (IMAGE_BRUSH*)core->brush_data;
		// 更新範囲のイメージ情報
		cairo_t *update;
		cairo_surface_t *update_surface;
		// ブラシの半径と不透明度
		FLOAT_T r, alpha;
		// 座標の最大・最小値
		FLOAT_T min_x, min_y, max_x, max_y;
		// X、Y方向の移動量
		FLOAT_T dx, dy;
		// ブラシの傾き用
		FLOAT_T diff_x, diff_y;
		// ブラシの移動量
		FLOAT_T d;
		// 描画を行う座標
		FLOAT_T draw_x, draw_y;
		// 画面更新を行う座標、範囲
		FLOAT_T update_x, update_y, update_r;
		// 入り、抜き時の色補正
		FLOAT_T enter_alpha, out_alpha;
		// ピクセルデータをリセットする座標
		int start_x, start_y;
		// 描画する幅、高さ、一行分のバイト数
		int width, height, stride;
		// 画像に対しての拡大・回転処理用の行列データ
		cairo_matrix_t matrix, reset_matrix;
		// 画像の拡大率
		FLOAT_T zoom;
		// 移動量計算用
		FLOAT_T cos_x, sin_y, trans_x, trans_y;
		// 画像の幅・高さの半分
		FLOAT_T half_width, half_height;
		// 作業レイヤーの一行分のバイト数
		int layer_stride = window->work_layer->stride;
		// 作業レイヤーのピクセル
		uint8 *work_pixel = window->work_layer->pixels;
		// 参照ピクセル
		uint8 *mask;
		// 配列のインデックス用
		int ref_point;
		int before_point;
		int i;	// for文用のカウンタ

		ref_point = brush->ref_point % BRUSH_POINT_BUFFER_SIZE;
		brush->points[ref_point][1] = x, brush->points[ref_point][2] = y;
		brush->ref_point++;

		while(brush->ref_point > brush->draw_finished)
		{
			ref_point = brush->draw_finished % BRUSH_POINT_BUFFER_SIZE;

			if(brush->finish_length < brush->enter_length)
			{
				enter_alpha = brush->finish_length / brush->enter_length;
				r = brush->enter_size + brush->finish_length * 0.25;
			}
			else
			{
				enter_alpha = 1;
				r = 1;
			}

			if((brush->core.flags & STAMP_PRESSURE_SIZE) != 0)
			{
				r *= brush->points[ref_point][3];
			}
			if((brush->core.flags & STAMP_RANDOM_SIZE) != 0)
			{
				r *= 1 - (brush->size_range * (rand() / (FLOAT_T)RAND_MAX));
			}
			if(r < MIN_BRUSH_STEP)
			{
				r = MIN_BRUSH_STEP;
			}

			if((brush->core.flags & STAMP_RANDOM_ROTATE) != 0)
			{
				brush->core.rotate = (rand() / (FLOAT_T)RAND_MAX) * (2*G_PI);
			}

			half_width = brush->core.half_width * r;
			half_height = brush->core.half_height * r;
			zoom = (1/r) * brush->core.scale;
			r *= brush->core.r;

			if(brush->sum_distance < brush->draw_start)
			{
				out_alpha = brush->sum_distance / brush->draw_start;
				r -= (brush->draw_start - brush->sum_distance) * 0.25;
			}
			else
			{
				out_alpha = 1;
			}

			if(r < 0.0)
			{
				brush->draw_finished++;
				continue;
			}

			alpha = ((brush->core.flags & BRUSH_FLAG_FLOW) == 0)
				? 1 : brush->points[ref_point][3];
			alpha *= enter_alpha;

			before_point = (ref_point == 0) ? BRUSH_POINT_BUFFER_SIZE - 1 : ref_point - 1;
			d = brush->points[ref_point][0];
			brush->sum_distance -= d;
			if(brush->draw_finished == 0)
			{
				draw_x = brush->points[0][1], draw_y = brush->points[0][2];
			}
			else
			{
				draw_x = brush->points[before_point][1];
				draw_y = brush->points[before_point][2];
			}
			dx = brush->points[ref_point][1] - draw_x;
			dy = brush->points[ref_point][2] - draw_y;

			if((brush->core.flags & STAMP_RANDOM_ROTATE) != 0)
			{
				brush->core.rotate = brush->core.rotate_start +
					(rand() / (FLOAT_T)RAND_MAX) * brush->core.rotate_direction * brush->rotate_range;
				if((brush->core.flags & BRUSH_FLAG_ROTATE) != 0)
				{
					brush->core.rotate += brush->core.rotate_direction * atan2(dy, dx);
				}
			}
			else if((brush->core.flags & BRUSH_FLAG_ROTATE) != 0)
			{
				brush->core.rotate = brush->core.rotate_start + brush->core.rotate_direction * atan2(dy, dx);
			}
			else
			{
				brush->core.rotate = brush->core.rotate_start;
			}
			cos_x = cos(brush->core.rotate), sin_y = sin(brush->core.rotate);
			diff_x = dx/d, diff_y = dy/d;

			min_x = brush->points[ref_point][1] - r - 1;
			max_x = brush->points[ref_point][1] + r + 1;
			min_y = brush->points[ref_point][2] - r - 1;
			max_y = brush->points[ref_point][2] + r + 1;

			if(min_x < 0.0)
			{
				min_x = 0.0;
			}
			if(core->min_x > min_x)
			{
				core->min_x = min_x;
			}
			if(min_y < 0.0)
			{
				min_y = 0.0;
			}
			if(core->min_y > min_y)
			{
				core->min_y = min_y;
			}
			if(max_x > window->work_layer->width)
			{
				max_x = window->work_layer->width;
			}
			if(core->max_x < max_x)
			{
				core->max_x = max_x;
			}
			if(max_y > window->work_layer->height)
			{
				min_y = window->work_layer->height;
			}
			if(core->max_y < max_y)
			{
				core->max_y = max_y;
			}

			if(window->update.x > min_x)
			{
				window->update.width += window->update.x - (int)min_x;
				window->update.x = (int)min_x;
			}
			if(window->update.width + window->update.x < max_x)
			{
				window->update.width += (int)max_x - window->update.width + window->update.x;
			}
			if(window->update.y > min_y)
			{
				window->update.height += window->update.y - (int)min_y;
				window->update.y = (int)min_y;
			}
			if(window->update.height + window->update.y < max_y)
			{
				window->update.height += (int)max_y - window->update.height + window->update.y;
			}

			if(brush->stamp_distance > brush->core.d || brush->draw_finished == 0)
			{
				dx = d;
				do
				{
					start_x = (int)(draw_x - r);
					start_y = (int)(draw_y - r);
					width = (int)(draw_x + r);
					height = (int)(draw_y + r);

					if(start_x < 0)
					{
						start_x = 0;
					}
					else if(start_x > window->work_layer->width)
					{
						goto skip_draw;
					}
					if(start_y < 0)
					{
						start_y = 0;
					}
					else if(start_y > window->work_layer->height)
					{
						goto skip_draw;
					}
					if(width > window->work_layer->width)
					{
						width = window->work_layer->width - start_x;
					}
					else
					{
						width = width - start_x;
					}
					if(height > window->work_layer->height)
					{
						height = window->work_layer->height - start_y;
					}
					else
					{
						height = height - start_y;
					}

					if(width < 0 || height < 0)
					{
						goto skip_draw;
					}

					stride = width*4;

					update_surface = cairo_surface_create_for_rectangle(
						window->mask_temp->surface_p, draw_x - r, draw_y - r, r*2+1, r*2+1);
					update = cairo_create(update_surface);

					for(i=0; i<height; i++)
					{
						(void)memset(&window->mask_temp->pixels[(i+start_y)*window->mask_temp->stride+start_x*4],
							0, stride);
					}

					trans_x = r - (half_width * cos_x + half_height * sin_y);
					trans_y = r + (half_width * sin_y - half_height * cos_x);

					// 行列データに拡大・縮小、回転角をセット
					cairo_set_operator(window->mask_temp->cairo_p, CAIRO_OPERATOR_OVER);
					cairo_matrix_init_scale(&matrix, zoom, zoom);
					cairo_matrix_rotate(&matrix, brush->core.rotate);
					cairo_matrix_translate(&matrix, - trans_x, - trans_y);

					mask = window->mask_temp->pixels;
					if((window->flags & DRAW_WINDOW_HAS_SELECTION_AREA) == 0)
					{
						if((window->active_layer->flags & LAYER_LOCK_OPACITY) == 0)
						{
							cairo_set_source(update, core->brush_pattern);
							cairo_pattern_set_matrix(core->brush_pattern, &matrix);
							cairo_paint_with_alpha(update, alpha);
						}
						else
						{
							cairo_pattern_set_matrix(core->brush_pattern, &reset_matrix);
							cairo_set_source(core->temp_cairo, core->brush_pattern);
							cairo_paint_with_alpha(core->temp_cairo, alpha);
							cairo_set_source(update, core->temp_pattern);
							cairo_pattern_set_matrix(core->temp_pattern, &matrix);
							cairo_mask_surface(update,
								window->active_layer->surface_p, - draw_x + r, - draw_y + r);
						}
					}
					else
					{
						if((window->active_layer->flags & LAYER_LOCK_OPACITY) == 0)
						{
							cairo_pattern_set_matrix(core->brush_pattern, &reset_matrix);
							cairo_set_source(core->temp_cairo, core->brush_pattern);
							cairo_paint_with_alpha(core->temp_cairo, alpha);
							cairo_set_source(update, core->temp_pattern);
							cairo_pattern_set_matrix(core->temp_pattern, &matrix);
							cairo_mask_surface(update,
								window->selection->surface_p, - draw_x + r, - draw_y + r);
						}
						else
						{
							cairo_surface_t *temp_surface = cairo_surface_create_for_rectangle(
								window->temp_layer->surface_p, draw_x-r, draw_y-r, r*2+1, r*2+1
							);
							cairo_t *update_temp = cairo_create(temp_surface);

							for(i=0; i<height; i++)
							{
								(void)memset(&window->temp_layer->pixels[
									(i+start_y)*window->temp_layer->stride+start_x*4],
									0, stride
								);
							}

							cairo_pattern_set_matrix(core->brush_pattern, &reset_matrix);
							cairo_set_source(core->temp_cairo, core->brush_pattern);
							cairo_paint_with_alpha(core->temp_cairo, alpha);
							cairo_set_source(update, core->temp_pattern);
							cairo_mask_surface(update,
								window->selection->surface_p, - draw_x + r, - draw_y + r);
							cairo_set_source_surface(update_temp,
								update_surface, 0, 0);
							cairo_mask_surface(update_temp,
								window->active_layer->surface_p, - draw_x + r, - draw_y + r);

							mask = window->temp_layer->pixels;

							cairo_surface_destroy(temp_surface);
							cairo_destroy(update_temp);
						}
					}

					// テクスチャを適用
					if(window->app->textures.active_texture != 0)
					{
						cairo_surface_t *temp_surface = cairo_surface_create_for_rectangle(
							window->temp_layer->surface_p, draw_x - r, draw_y - r, r*2+1, r*2+1);
						cairo_t *update_temp = cairo_create(temp_surface);

						if(mask == window->mask_temp->pixels)
						{
							for(i=0; i<height; i++)
							{
								(void)memset(&window->temp_layer->pixels[
									(i+start_y)*window->temp_layer->stride+start_x*4],
									0, stride
								);
							}
							cairo_set_source_surface(update_temp,
								update_surface, 0, 0);
							cairo_mask_surface(update_temp, window->texture->surface_p, - draw_x + r, - draw_y + r);
							mask = window->temp_layer->pixels;
						}
						else
						{
							for(i=0; i<height; i++)
							{
								(void)memset(&window->mask_temp->pixels[
									(i+start_y)*window->mask_temp->stride+start_x*4],
									0, stride
								);
							}
							cairo_set_source_surface(update,
								temp_surface, 0, 0);
							cairo_mask_surface(update, window->texture->surface_p, - draw_x + r, - draw_y + r);
							mask = window->mask_temp->pixels;
						}

						cairo_surface_destroy(temp_surface);
						cairo_destroy(update_temp);
					}

					cairo_surface_destroy(update_surface);
					cairo_destroy(update);

#ifdef _OPENMP
#pragma omp parallel for firstprivate(work_pixel, layer_stride, start_x, start_y, width, mask)
#endif
					for(i=0; i<height; i++)
					{
						uint8 *ref_pix = &work_pixel[
							(start_y+i)*layer_stride+start_x*4];
						uint8 *mask_pix = &mask[(start_y+i)*layer_stride
							+start_x*4];
						int j;

						for(j=0; j<width; j++, ref_pix+=4, mask_pix+=4)
						{
							if(ref_pix[3] < mask_pix[3])
							{
								ref_pix[0] = (uint8)((uint32)(((int)mask_pix[0]-(int)ref_pix[0])
									* mask_pix[3] >> 8) + ref_pix[0]);
								ref_pix[1] = (uint8)((uint32)(((int)mask_pix[1]-(int)ref_pix[1])
									* mask_pix[3] >> 8) + ref_pix[1]);
								ref_pix[2] = (uint8)((uint32)(((int)mask_pix[2]-(int)ref_pix[2])
									* mask_pix[3] >> 8) + ref_pix[2]);
								ref_pix[3] = (uint8)((uint32)(((int)mask_pix[3]-(int)ref_pix[3])
									* mask_pix[3] >> 8) + ref_pix[3]);
							}
						}
					}

					update_r = r * window->zoom_rate;
					update_x = ((draw_x-window->width/2)*window->cos_value + (draw_y-window->height/2)*window->sin_value) * window->zoom_rate
						+ window->rev_add_cursor_x;
					update_y = (- (draw_x-window->width/2)*window->sin_value + (draw_y-window->height/2)*window->cos_value) * window->zoom_rate
						+ window->rev_add_cursor_y;
					gtk_widget_queue_draw_area(window->window, (gint)(update_x-update_r), (gint)(update_y-update_r),
						(gint)(update_r * 2 + BRUSH_UPDATE_MARGIN), (gint)(update_r * 2 + BRUSH_UPDATE_MARGIN));
skip_draw:
					dx -= brush->core.d;
					brush->stamp_distance -= brush->core.d;
					if(dx < brush->core.d)
					{
						break;
					}
					else
					{
						draw_x += diff_x, draw_y += diff_y;
					}
				} while(1);
			}

			brush->finish_length += d;
			brush->travel += d;
			brush->draw_finished++;
			ref_point = brush->draw_finished % BRUSH_POINT_BUFFER_SIZE;
		}	// while(brush->ref_point > brush->draw_finished)

		AddBrushHistory(core, window->active_layer);

		window->update.surface_p = cairo_surface_create_for_rectangle(
			window->active_layer->surface_p, window->update.x, window->update.y,
				window->update.width, window->update.height);
		window->update.cairo_p = cairo_create(window->update.surface_p);
		window->part_layer_blend_functions[window->work_layer->layer_mode](window->work_layer, &window->update);
		cairo_destroy(window->update.cairo_p);
		cairo_surface_destroy(window->update.surface_p);

		(void)memset(window->work_layer->pixels, 0, window->work_layer->stride*window->work_layer->height);

		window->work_layer->layer_mode = LAYER_BLEND_NORMAL;

		brush->core.rotate = brush->core.rotate_start;

		window->flags |= DRAW_WINDOW_UPDATE_PART;
	}	// マウスの左ボタンなら
		// if(((GdkEventButton*)state)->button == 1)
}

static void ImageBrushEditSelectionRelease(
	DRAW_WINDOW* window,
	FLOAT_T x,
	FLOAT_T y,
	FLOAT_T pressure,
	BRUSH_CORE *core,
	void* state
)
{
	// マウスの左ボタンなら
	if(((GdkEventButton*)state)->button == 1)
	{
		// ブラシの詳細情報にキャスト
		IMAGE_BRUSH *brush = (IMAGE_BRUSH*)core->brush_data;
		// ブラシの半径と不透明度
		FLOAT_T r, alpha;
		// 座標の最大・最小値
		FLOAT_T min_x, min_y, max_x, max_y;
		// X、Y方向の移動量
		FLOAT_T dx, dy;
		// ブラシの傾き用
		FLOAT_T diff_x, diff_y;
		// ブラシの移動量
		FLOAT_T d;
		// 描画を行う座標
		FLOAT_T draw_x, draw_y;
		// 入り、抜き時の色補正
		FLOAT_T enter_alpha, out_alpha;
		// ピクセルデータをリセットする座標
		int start_x, start_y;
		// 描画する幅、高さ、一行分のバイト数
		int width, height, stride;
		// 画像に対しての拡大・回転処理用の行列データ
		cairo_matrix_t matrix, reset_matrix;
		// 画像の拡大率
		FLOAT_T zoom;
		// 移動量計算用
		FLOAT_T cos_x, sin_y, trans_x, trans_y;
		// 画像の幅・高さの半分
		FLOAT_T half_width, half_height;
		// 作業レイヤーの一行分のバイト数
		int layer_stride = window->work_layer->stride;
		// 作業レイヤーのピクセル
		uint8 *work_pixel = window->work_layer->pixels;
		// 参照ピクセル
		uint8 *mask;
		// 配列のインデックス用
		int ref_point;
		int before_point;
		int i;	// for文用のカウンタ

		ref_point = brush->ref_point % BRUSH_POINT_BUFFER_SIZE;
		brush->points[ref_point][1] = x, brush->points[ref_point][2] = y;
		brush->ref_point++;

		while(brush->ref_point > brush->draw_finished)
		{
			ref_point = brush->draw_finished % BRUSH_POINT_BUFFER_SIZE;

			if(brush->finish_length < brush->enter_length)
			{
				enter_alpha = brush->finish_length / brush->enter_length;
				r = brush->enter_size + brush->finish_length * 0.25;
			}
			else
			{
				enter_alpha = 1;
				r = 1;
			}

			if((brush->core.flags & STAMP_PRESSURE_SIZE) != 0)
			{
				r *= brush->points[ref_point][3];
			}
			if((brush->core.flags & STAMP_RANDOM_SIZE) != 0)
			{
				r *= 1 - (brush->size_range * (rand() / (FLOAT_T)RAND_MAX));
			}
			if(r < MIN_BRUSH_STEP)
			{
				r = MIN_BRUSH_STEP;
			}

			if((brush->core.flags & STAMP_RANDOM_ROTATE) != 0)
			{
				brush->core.rotate = (rand() / (FLOAT_T)RAND_MAX) * (2*G_PI);
			}

			half_width = brush->core.half_width * r;
			half_height = brush->core.half_height * r;
			zoom = (1/r) * brush->core.scale;
			r *= brush->core.r;

			if(brush->sum_distance < brush->draw_start)
			{
				out_alpha = brush->sum_distance / brush->draw_start;
				r -= (brush->draw_start - brush->sum_distance) * 0.25;
			}
			else
			{
				out_alpha = 1;
			}

			if(r < 0.0)
			{
				brush->draw_finished++;
				continue;
			}

			alpha = ((brush->core.flags & BRUSH_FLAG_FLOW) == 0)
				? brush->core.flow : brush->core.flow * brush->points[ref_point][3];
			alpha *= enter_alpha;

			if(brush->core.brush_surface != NULL)
			{
				cairo_surface_destroy(brush->core.brush_surface);
			}
			brush->core.brush_surface = CreatePatternSurface(
				&window->app->stamps, *core->color, *core->back_color, brush->core.pattern_flags, brush->mode, alpha);

			before_point = (ref_point == 0) ? BRUSH_POINT_BUFFER_SIZE - 1 : ref_point - 1;
			d = brush->points[ref_point][0];
			brush->sum_distance -= d;
			if(brush->draw_finished == 0)
			{
				draw_x = brush->points[0][1], draw_y = brush->points[0][2];
			}
			else
			{
				draw_x = brush->points[before_point][1];
				draw_y = brush->points[before_point][2];
			}
			dx = brush->points[ref_point][1] - draw_x;
			dy = brush->points[ref_point][2] - draw_y;

			if((brush->core.flags & STAMP_RANDOM_ROTATE) != 0)
			{
				brush->core.rotate = brush->core.rotate_start +
					(rand() / (FLOAT_T)RAND_MAX) * brush->core.rotate_direction * brush->rotate_range;
				if((brush->core.flags & BRUSH_FLAG_ROTATE) != 0)
				{
					brush->core.rotate += brush->core.rotate_direction * atan2(dy, dx);
				}
			}
			else if((brush->core.flags & BRUSH_FLAG_ROTATE) != 0)
			{
				brush->core.rotate = brush->core.rotate_start + brush->core.rotate_direction * atan2(dy, dx);
			}
			else
			{
				brush->core.rotate = brush->core.rotate_start;
			}

			cos_x = cos(brush->core.rotate), sin_y = sin(brush->core.rotate);
			diff_x = dx/d, diff_y = dy/d;

			min_x = brush->points[ref_point][1] - r - 1;
			max_x = brush->points[ref_point][1] + r + 1;
			min_y = brush->points[ref_point][2] - r - 1;
			max_y = brush->points[ref_point][2] + r + 1;

			if(min_x < 0.0)
			{
				min_x = 0.0;
			}
			if(core->min_x > min_x)
			{
				core->min_x = min_x;
			}
			if(min_y < 0.0)
			{
				min_y = 0.0;
			}
			if(core->min_y > min_y)
			{
				core->min_y = min_y;
			}
			if(max_x > window->work_layer->width)
			{
				max_x = window->work_layer->width;
			}
			if(core->max_x < max_x)
			{
				core->max_x = max_x;
			}
			if(max_y > window->work_layer->height)
			{
				min_y = window->work_layer->height;
			}
			if(core->max_y < max_y)
			{
				core->max_y = max_y;
			}

			if(brush->stamp_distance > brush->core.d)
			{
				dx = d;
				do
				{
					start_x = (int)(draw_x - r);
					start_y = (int)(draw_y - r);
					width = (int)(draw_x + r);
					height = (int)(draw_y + r);

					if(start_x < 0)
					{
						start_x = 0;
					}
					else if(start_x > window->work_layer->width)
					{
						goto skip_draw;
					}
					if(start_y < 0)
					{
						start_y = 0;
					}
					else if(start_y > window->work_layer->height)
					{
						goto skip_draw;
					}
					if(width > window->work_layer->width)
					{
						width = window->work_layer->width - start_x;
					}
					else
					{
						width = width - start_x;
					}
					if(height > window->work_layer->height)
					{
						height = window->work_layer->height - start_y;
					}
					else
					{
						height = height - start_y;
					}

					if(width < 0 || height < 0)
					{
						goto skip_draw;
					}
					stride = width*4;

					for(i=0; i<height; i++)
					{
						(void)memset(&window->mask_temp->pixels[(i+start_y)*window->mask_temp->stride+start_x*4],
							0, stride);
					}

					trans_x = draw_x - (half_width * cos_x + half_height * sin_y);
					trans_y = draw_y + (half_width * sin_y - half_height * cos_x);
					// 行列データに拡大・縮小、回転角をセット
					cairo_set_operator(window->mask_temp->cairo_p, CAIRO_OPERATOR_OVER);
					cairo_matrix_init_scale(&matrix, zoom, zoom);
					cairo_matrix_rotate(&matrix, brush->core.rotate);
					cairo_matrix_translate(&matrix, - trans_x, - trans_y);

					mask = window->mask_temp->pixels;
					if((window->flags & DRAW_WINDOW_HAS_SELECTION_AREA) == 0)
					{
						if((window->active_layer->flags & LAYER_LOCK_OPACITY) == 0)
						{
							cairo_set_source(window->mask_temp->cairo_p, core->brush_pattern);
							cairo_pattern_set_matrix(core->brush_pattern, &matrix);
							cairo_paint_with_alpha(window->mask_temp->cairo_p, alpha);
						}
						else
						{
							cairo_pattern_set_matrix(core->brush_pattern, &reset_matrix);
							cairo_set_source(core->temp_cairo, core->brush_pattern);
							cairo_paint_with_alpha(core->temp_cairo, alpha);
							cairo_set_source(window->mask_temp->cairo_p, core->temp_pattern);
							cairo_pattern_set_matrix(core->temp_pattern, &matrix);
							cairo_mask_surface(window->mask_temp->cairo_p,
								window->active_layer->surface_p, 0, 0);
						}
					}
					else
					{
						if((window->active_layer->flags & LAYER_LOCK_OPACITY) == 0)
						{
							cairo_pattern_set_matrix(core->brush_pattern, &reset_matrix);
							cairo_set_source(core->temp_cairo, core->brush_pattern);
							cairo_paint_with_alpha(core->temp_cairo, alpha);
							cairo_set_source(window->mask_temp->cairo_p, core->temp_pattern);
							cairo_pattern_set_matrix(core->temp_pattern, &matrix);
							cairo_mask_surface(window->mask_temp->cairo_p,
								window->selection->surface_p, 0, 0);
						}
						else
						{
							for(i=0; i<height; i++)
							{
								(void)memset(&window->temp_layer->pixels[
									(i+start_y)*window->temp_layer->stride+start_x*4],
									0, stride
								);
							}

							cairo_pattern_set_matrix(core->brush_pattern, &reset_matrix);
							cairo_set_source(core->temp_cairo, core->brush_pattern);
							cairo_paint_with_alpha(core->temp_cairo, alpha);
							cairo_set_source(window->mask_temp->cairo_p, core->temp_pattern);
							cairo_mask_surface(window->mask_temp->cairo_p,
								window->selection->surface_p, 0, 0);
							cairo_set_source_surface(window->temp_layer->cairo_p,
								window->mask_temp->surface_p, 0, 0);
							cairo_mask_surface(window->temp_layer->cairo_p,
								window->active_layer->surface_p, 0, 0);

							mask = window->temp_layer->pixels;
						}
					}

					// テクスチャを適用
					if(window->app->textures.active_texture != 0)
					{
						if(mask == window->mask_temp->pixels)
						{
							for(i=0; i<height; i++)
							{
								(void)memset(&window->temp_layer->pixels[
									(i+start_y)*window->temp_layer->stride+start_x*4],
									0, stride
								);
							}
							cairo_set_source_surface(window->temp_layer->cairo_p,
								window->mask_temp->surface_p, 0, 0);
							cairo_mask_surface(window->temp_layer->cairo_p, window->texture->surface_p, 0, 0);
							mask = window->temp_layer->pixels;
						}
						else
						{
							for(i=0; i<height; i++)
							{
								(void)memset(&window->mask_temp->pixels[
									(i+start_y)*window->mask_temp->stride+start_x*4],
									0, stride
								);
							}
							cairo_set_source_surface(window->mask_temp->cairo_p,
								window->temp_layer->surface_p, 0, 0);
							cairo_mask_surface(window->mask_temp->cairo_p, window->texture->surface_p, 0, 0);
							mask = window->mask_temp->pixels;
						}
					}

#ifdef _OPENMP
#pragma omp parallel for firstprivate(work_pixel, layer_stride, start_x, start_y, width, mask)
#endif
					for(i=0; i<height; i++)
					{
						uint8 *ref_pix = &work_pixel[
							(start_y+i)*layer_stride+start_x*4];
						uint8 *mask_pix = &mask[(start_y+i)*layer_stride
							+start_x*4];
						int j;

						for(j=0; j<width; j++, ref_pix+=4, mask_pix+=4)
						{
							if(ref_pix[3] < mask_pix[3])
							{
								ref_pix[0] = (uint8)((uint32)(((int)mask_pix[0]-(int)ref_pix[0])
									* mask_pix[3] >> 8) + ref_pix[0]);
								ref_pix[1] = (uint8)((uint32)(((int)mask_pix[1]-(int)ref_pix[1])
									* mask_pix[3] >> 8) + ref_pix[1]);
								ref_pix[2] = (uint8)((uint32)(((int)mask_pix[2]-(int)ref_pix[2])
									* mask_pix[3] >> 8) + ref_pix[2]);
								ref_pix[3] = (uint8)((uint32)(((int)mask_pix[3]-(int)ref_pix[3])
									* mask_pix[3] >> 8) + ref_pix[3]);
							}
						}
					}
skip_draw:
					dx -= brush->core.d;
					brush->stamp_distance -= brush->core.d;
					if(dx < brush->core.d)
					{
						break;
					}
					else
					{
						draw_x += diff_x, draw_y += diff_y;
					}
				} while(1);
			}

			brush->finish_length += d;
			brush->travel += d;
			brush->draw_finished++;
			ref_point = brush->draw_finished % BRUSH_POINT_BUFFER_SIZE;
		}	// while(brush->ref_point > brush->draw_finished)

		AddSelectionEditHistory(core, window->selection);

		g_blend_selection_funcs[window->selection->layer_mode](window->work_layer, window->selection);

		(void)memset(window->work_layer->pixels, 0, window->work_layer->stride*window->work_layer->height);

		window->work_layer->layer_mode = LAYER_BLEND_NORMAL;

		brush->core.rotate = brush->core.rotate_start;
	}	// マウスの左ボタンなら
		// if(((GdkEventButton*)state)->button == 1)
}

static void ImageBrushDrawCursor(
	DRAW_WINDOW* window,
	FLOAT_T x,
	FLOAT_T y,
	void* data
)
{
	StampCoreDrawCursor(window, x, y, &((IMAGE_BRUSH*)data)->core);
}

static void ImageBrushButtonUpdate(DRAW_WINDOW* window, FLOAT_T x, FLOAT_T y, IMAGE_BRUSH* brush)
{
	FLOAT_T r;

	if(brush->core.half_width > brush->core.half_height)
	{
		r = brush->core.half_width * 2 * window->zoom_rate + 1;
	}
	else
	{
		r = brush->core.half_height * 2 * window->zoom_rate + 1;
	}

	gtk_widget_queue_draw_area(window->window, (gint)(x - r - 1),
		(gint)(y - r - 1), (gint)(r * 2) + 2, (gint)(r * 2) + 2);
}

static void ImageBrushMotionUpdate(DRAW_WINDOW* window, FLOAT_T x, FLOAT_T y, IMAGE_BRUSH* brush)
{
	FLOAT_T start_x, start_y;
	FLOAT_T width, height;
	FLOAT_T r;
	FLOAT_T enter = (brush->enter_length + brush->draw_start) * window->zoom_rate;

	if(brush->core.half_width > brush->core.half_height)
	{
		r = brush->core.half_width * 2 * window->zoom_rate + 1;
	}
	else
	{
		r = brush->core.half_height * 2 * window->zoom_rate + 1;
	}

	if(window->before_cursor_x < x)
	{
		start_x = window->before_cursor_x - r;
		width = r * 2 + x - window->before_cursor_x;
	}
	else
	{
		start_x = x - r;
		width = r * 2 + window->before_cursor_x - x;
	}

	if(window->before_cursor_y < y)
	{
		start_y = window->before_cursor_y - r;
		height = r * 2 + y - window->before_cursor_y;
	}
	else
	{
		start_y = y - r;
		height = r * 2 + window->before_cursor_y - y;
	}

	start_x -= enter * 4;
	width += enter * 4 * 2 + 2;
	start_y -= enter * 4;
	height += enter * 4 * 2 + 2;

	gtk_widget_queue_draw_area(window->window,
		(gint)start_x, (gint)start_y, (gint)width, (gint)height);
}

static void ImageBrushChangeColor(const uint8 color[3], void* data)
{
	IMAGE_BRUSH *brush = (IMAGE_BRUSH*)data;
	InitializeStampCore(&brush->core, brush->mode, brush->core.app);
}

static void ImageBrushSetEnter(GtkAdjustment* slider, IMAGE_BRUSH* brush)
{
	brush->enter = gtk_adjustment_get_value(slider);
}

static void ImageBrushSetOut(GtkAdjustment* slider, IMAGE_BRUSH* brush)
{
	brush->out = gtk_adjustment_get_value(slider);
}

static void ImageBrushSetBlendMode(GtkComboBox* combo, IMAGE_BRUSH* brush)
{
	brush->blend_mode = (uint16)gtk_combo_box_get_active(combo);
}

static void ImageBrushSetRotate2Direction(GtkWidget* button, IMAGE_BRUSH* brush)
{
	if(gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(button)) == FALSE)
	{
		brush->core.flags &= ~(BRUSH_FLAG_ROTATE);
	}
	else
	{
		brush->core.flags |= BRUSH_FLAG_ROTATE;
	}
}

static void ImageBrushSetRotateDirection(GtkWidget* button, IMAGE_BRUSH* brush)
{
	if(gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(button)) != FALSE)
	{
		brush->core.rotate_direction = GPOINTER_TO_INT(g_object_get_data(
			G_OBJECT(button), "rotate_direction"));
	}
}

static void ImageBrushSetSizeRange(GtkAdjustment* slider, IMAGE_BRUSH* brush)
{
	brush->size_range = gtk_adjustment_get_value(slider) * 0.01;
}

static void ImageBrushSetRotateRange(GtkAdjustment* slider, IMAGE_BRUSH* brush)
{
	brush->random_rotate_range = (int16)gtk_adjustment_get_value(slider);
	brush->rotate_range = brush->random_rotate_range * G_PI / 180;
}

static GtkWidget* CreateImageBrushDetailUI(APPLICATION* app, BRUSH_CORE* brush_core)
{
#define UI_FONT_SIZE 8.0
#define ICON_SIZE 32
	IMAGE_BRUSH *brush = (IMAGE_BRUSH*)brush_core->brush_data;
	STAMP_CORE *core = &brush->core;
	GtkWidget *vbox = gtk_vbox_new(FALSE, 0);
	// ラベル、スライダ
	GtkWidget* label, *scale;
	// スクロールドウィンドウ
	GtkWidget* scrolled_window;
	// ウィジェット整列用のテーブル
	GtkWidget* table;
	// 回転方向、モード設定用のラジオボタン
	GtkWidget* radio_buttons[PATTERN_MODE_NUM];
	// 筆圧使用設定のチェックボックス
	GtkWidget* check_button;
	// 合成モード選択用のコンボボックス
	GtkWidget* combo;
	// スライダに使用するアジャスタ
	GtkAdjustment* scale_adjustment;
	// ラベルのフォント変更用のマークアップバッファ
	char mark_up_buff[256];
	int i;	// for文用のカウンタ

	// アプリケーション管理の構造体へのポインタをセット
	core->app = app;

	// クリップボードのパターンを更新
	UpdateClipBoardPattern(&app->stamps);

	// 拡大縮小率設定用のウィジェット
	scale_adjustment = GTK_ADJUSTMENT(gtk_adjustment_new(
		(1 / core->scale) * 100, 10, 300, 0.1, 0.1, 0));
	scale = SpinScaleNew(scale_adjustment,
		app->labels->tool_box.brush_scale, 1);
	(void)g_signal_connect(G_OBJECT(scale_adjustment), "value_changed",
		G_CALLBACK(StampCoreChangeScale), core);
	g_object_set_data(G_OBJECT(scale_adjustment), "application", app);
	gtk_box_pack_start(GTK_BOX(vbox), scale, FALSE, FALSE, 0);

	// 濃度変更用ウィジェット
	scale_adjustment = GTK_ADJUSTMENT(gtk_adjustment_new(
		core->flow * 100, 0, 100, 0.1, 0.1, 0));
	scale = SpinScaleNew(scale_adjustment,
		app->labels->tool_box.flow, 1);
	g_object_set_data(G_OBJECT(scale_adjustment), "application", app);
	(void)g_signal_connect(G_OBJECT(scale_adjustment), "value_changed",
		G_CALLBACK(StampCoreChangeFlow), core);
	table = gtk_table_new(1, 3, TRUE);
	gtk_table_attach_defaults(GTK_TABLE(table), scale, 0, 3, 0, 1);
	gtk_box_pack_start(GTK_BOX(vbox), table, FALSE, TRUE, 0);

	// 開始回転角変更用ウィジェット
	scale_adjustment = GTK_ADJUSTMENT(gtk_adjustment_new(
		fabs(core->rotate_start) * 180 / G_PI, 0, 360, 0.1, 0.1, 0));
	scale = SpinScaleNew(scale_adjustment,
		app->labels->tool_box.rotate_start, 1);
	g_object_set_data(G_OBJECT(scale_adjustment), "application", app);
	(void)g_signal_connect(G_OBJECT(scale_adjustment), "value_changed",
		G_CALLBACK(StampCoreChangeRotateStart), core);
	gtk_box_pack_start(GTK_BOX(vbox), scale, FALSE, FALSE, 0);

	// 間隔変更用ウィジェット
	scale_adjustment = GTK_ADJUSTMENT(gtk_adjustment_new(
		core->stamp_distance, 0.1, 3, 0.1, 0.1, 0));
	scale = SpinScaleNew(scale_adjustment,
		app->labels->tool_box.distance, 1);
	(void)g_signal_connect(G_OBJECT(scale_adjustment), "value_changed",
		G_CALLBACK(StampCoreChangeDistance), core);
	g_object_set_data(G_OBJECT(scale_adjustment), "application", app);
	gtk_box_pack_start(GTK_BOX(vbox), scale, FALSE, FALSE, 0);

	core->mode = &brush->mode;
	core->mode_select[0] = radio_buttons[0] =
		gtk_radio_button_new_with_label(NULL, app->labels->tool_box.saturation);
	core->mode_select[1] = radio_buttons[1] = gtk_radio_button_new_with_label(
		gtk_radio_button_get_group(GTK_RADIO_BUTTON(radio_buttons[0])),
		app->labels->tool_box.brightness
	);
	core->mode_select[2] = radio_buttons[2] = gtk_radio_button_new_with_label(
		gtk_radio_button_get_group(GTK_RADIO_BUTTON(radio_buttons[0])),
		app->labels->tool_box.gradation_reverse
	);
	gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(radio_buttons[brush->mode]), TRUE);
	g_object_set_data(G_OBJECT(radio_buttons[0]), "mode", GINT_TO_POINTER(0));
	g_object_set_data(G_OBJECT(radio_buttons[0]), "application", app);
	g_object_set_data(G_OBJECT(radio_buttons[0]), "stamp_core", core);
	(void)g_signal_connect(G_OBJECT(radio_buttons[0]), "toggled", G_CALLBACK(StampCoreSetMode), &brush->mode);
	g_object_set_data(G_OBJECT(radio_buttons[1]), "mode", GINT_TO_POINTER(1));
	g_object_set_data(G_OBJECT(radio_buttons[1]), "application", app);
	g_object_set_data(G_OBJECT(radio_buttons[1]), "stamp_core", core);
	(void)g_signal_connect(G_OBJECT(radio_buttons[1]), "toggled", G_CALLBACK(StampCoreSetMode), &brush->mode);
	g_object_set_data(G_OBJECT(radio_buttons[2]), "mode", GINT_TO_POINTER(2));
	g_object_set_data(G_OBJECT(radio_buttons[2]), "application", app);
	g_object_set_data(G_OBJECT(radio_buttons[2]), "stamp_core", core);
	(void)g_signal_connect(G_OBJECT(radio_buttons[2]), "toggled", G_CALLBACK(StampCoreSetMode), &brush->mode);
	table = gtk_hbox_new(FALSE, 0);
	gtk_box_pack_start(GTK_BOX(table), radio_buttons[0], FALSE, TRUE, 0);
	gtk_box_pack_start(GTK_BOX(table), radio_buttons[1], FALSE, TRUE, 0);
	gtk_box_pack_start(GTK_BOX(vbox), table, FALSE, TRUE, 0);
	gtk_box_pack_start(GTK_BOX(vbox), radio_buttons[2], FALSE, TRUE, 0);

	// 左右反転、上下反転選択用チェックボックス
	table = gtk_hbox_new(FALSE, 0);
	label = gtk_label_new("");
	(void)sprintf(mark_up_buff, "<span font_desc=\"%.2f\">%s : </span>",
		UI_FONT_SIZE * app->gui_scale, app->labels->tool_box.reverse);
	gtk_label_set_markup(GTK_LABEL(label), mark_up_buff);
	gtk_box_pack_start(GTK_BOX(table), label, FALSE, FALSE, 0);
	check_button = gtk_check_button_new_with_label(app->labels->tool_box.reverse_horizontally);
	g_object_set_data(G_OBJECT(check_button), "flag-id", GINT_TO_POINTER(0));
	g_object_set_data(G_OBJECT(check_button), "application", app);
	gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(check_button),
		core->pattern_flags & PATTERN_FLIP_HORIZONTALLY);
	(void)g_signal_connect(G_OBJECT(check_button), "toggled", G_CALLBACK(StampCoreSetPatternFlags), core);
	gtk_box_pack_start(GTK_BOX(table), check_button, FALSE, TRUE, 0);
	check_button = gtk_check_button_new_with_label(app->labels->tool_box.reverse_vertically);
	g_object_set_data(G_OBJECT(check_button), "flag-id", GINT_TO_POINTER(1));
	g_object_set_data(G_OBJECT(check_button), "application", app);
	gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(check_button),
		core->pattern_flags & PATTERN_FLIP_VERTICALLY);
	(void)g_signal_connect(G_OBJECT(check_button), "toggled", G_CALLBACK(StampCoreSetPatternFlags), core);
	gtk_box_pack_start(GTK_BOX(table), check_button, FALSE, TRUE, 0);
	gtk_box_pack_start(GTK_BOX(vbox), table, FALSE, TRUE, 0);

	// 回転方向変更用ウィジェット
	radio_buttons[0] = gtk_radio_button_new_with_label(NULL, app->labels->tool_box.clockwise);
	radio_buttons[1] = gtk_radio_button_new_with_label(
		gtk_radio_button_get_group(GTK_RADIO_BUTTON(radio_buttons[0])),
		app->labels->tool_box.counter_clockwise
	);

	if(core->rotate_direction < 0)
	{
		gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(radio_buttons[0]), TRUE);
	}
	else
	{
		gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(radio_buttons[1]), TRUE);
	}

	table = gtk_hbox_new(FALSE, 0);
	g_object_set_data(G_OBJECT(radio_buttons[0]), "rotate_direction", GINT_TO_POINTER(1));
	g_object_set_data(G_OBJECT(radio_buttons[1]), "rotate_direction", GINT_TO_POINTER(-1));
	(void)g_signal_connect(G_OBJECT(radio_buttons[0]), "toggled",
		G_CALLBACK(ImageBrushSetRotateDirection), brush);
	(void)g_signal_connect(G_OBJECT(radio_buttons[1]), "toggled",
		G_CALLBACK(ImageBrushSetRotateDirection), brush);
	gtk_box_pack_start(GTK_BOX(table), radio_buttons[0], FALSE, TRUE, 0);
	gtk_box_pack_start(GTK_BOX(table), radio_buttons[1], FALSE, TRUE, 0);
	gtk_box_pack_start(GTK_BOX(vbox), table, FALSE, TRUE, 0);
	// 詳細設定のUIが閉じられるときにボタン配列を開放する
	(void)g_signal_connect(G_OBJECT(vbox), "destroy", G_CALLBACK(OnStampDetailUIDestroy), core);

	// スタンプ選択テーブルを作成してスクロールドウィンドウに入れる
	table = gtk_hbox_new(FALSE, 0);
	scrolled_window = gtk_scrolled_window_new(NULL, NULL);
	gtk_widget_set_size_request(table,
		ICON_SIZE*STAMP_SELECT_TABLE_WIDTH+4, ICON_SIZE*4+4);
	gtk_scrolled_window_add_with_viewport(GTK_SCROLLED_WINDOW(scrolled_window),
		CreateStampSelectTable(core));
	gtk_scrolled_window_set_policy(GTK_SCROLLED_WINDOW(scrolled_window),
		GTK_POLICY_NEVER, GTK_POLICY_AUTOMATIC);
	gtk_box_pack_start(GTK_BOX(table), scrolled_window, FALSE, FALSE, 0);
	gtk_box_pack_start(GTK_BOX(vbox), table, FALSE, TRUE, 0);

	// クリップボードのスタンプがアクティブならばセット
	if(app->stamps.has_clip_board_pattern != FALSE)
	{
		if(core->stamp_id == 0)
		{
			app->stamps.active_pattern =
				&app->stamps.clip_board;
		}
		else
		{
			app->stamps.active_pattern =
				&app->stamps.patterns[core->stamp_id-1];
		}
	}

	// アクティブなパターンがチャンネル数2以外ならば着色モードは無効
	gtk_widget_set_sensitive(core->mode_select[0], app->stamps.active_pattern->channel == 2);
	gtk_widget_set_sensitive(core->mode_select[1], app->stamps.active_pattern->channel == 2);
	gtk_widget_set_sensitive(core->mode_select[2], app->stamps.active_pattern->channel == 2);

	InitializeStampCore(core, (int)brush->mode, app);

	table = gtk_hbox_new(FALSE, 0);
	label = gtk_label_new("");
#if GTK_MAJOR_VERSION <= 2
	combo = gtk_combo_box_new_text();
#else
	combo = gtk_combo_box_text_new();
#endif
	(void)sprintf(mark_up_buff, "<span font_desc=\"%.2f\">%s : </span>",
		UI_FONT_SIZE * app->gui_scale, app->labels->layer_window.blend_mode);
	gtk_label_set_markup(GTK_LABEL(label), mark_up_buff);
	gtk_box_pack_start(GTK_BOX(table), label, FALSE, FALSE, 0);
	for(i=0; i<LAYER_BLEND_SLELECTABLE_NUM; i++)
	{
#if GTK_MAJOR_VERSION <= 2
		gtk_combo_box_append_text(GTK_COMBO_BOX(combo), app->labels->layer_window.blend_modes[i]);
#else
		gtk_combo_box_text_append_text(GTK_COMBO_BOX_TEXT(combo), app->labels->layer_window.blend_modes[i]);
#endif
	}
	gtk_combo_box_set_active(GTK_COMBO_BOX(combo), brush->blend_mode);
	(void)g_signal_connect(G_OBJECT(combo), "changed",
		G_CALLBACK(ImageBrushSetBlendMode), brush);
	gtk_box_pack_start(GTK_BOX(table), combo, FALSE, TRUE, 0);
	gtk_box_pack_start(GTK_BOX(vbox), table, FALSE, TRUE, 0);

	scale_adjustment = GTK_ADJUSTMENT(gtk_adjustment_new(brush->enter, 0, 100, 1, 1, 0));
	scale = SpinScaleNew(scale_adjustment,
		app->labels->tool_box.enter, 1);
	(void)g_signal_connect(G_OBJECT(scale_adjustment), "value_changed",
		G_CALLBACK(ImageBrushSetEnter), core);
	gtk_box_pack_start(GTK_BOX(vbox), scale, FALSE, FALSE, 0);

	scale_adjustment = GTK_ADJUSTMENT(gtk_adjustment_new(brush->out, 0, 100, 1, 1, 0));
	scale = SpinScaleNew(scale_adjustment,
		app->labels->tool_box.out, 1);
	(void)g_signal_connect(G_OBJECT(scale_adjustment), "value_changed",
		G_CALLBACK(ImageBrushSetOut), core);
	gtk_box_pack_start(GTK_BOX(vbox), scale, FALSE, FALSE, 0);

	// 筆圧使用設定変更用ウィジェット
	table = gtk_hbox_new(FALSE, 0);
	label = gtk_label_new("");
	(void)sprintf(mark_up_buff, "<span font_desc=\"%.2f\">%s : </span>",
		UI_FONT_SIZE * app->gui_scale, app->labels->tool_box.pressure);
	gtk_label_set_markup(GTK_LABEL(label), mark_up_buff);
	gtk_box_pack_start(GTK_BOX(table), label, FALSE, FALSE, 0);
	check_button = gtk_check_button_new_with_label(app->labels->tool_box.scale);
	g_object_set_data(G_OBJECT(check_button), "flag-id", GINT_TO_POINTER(0));
	gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(check_button), core->flags & BRUSH_FLAG_SIZE);
	(void)g_signal_connect(G_OBJECT(check_button), "toggled", G_CALLBACK(StampCoreSetFlags), core);
	gtk_box_pack_start(GTK_BOX(table), check_button, FALSE, TRUE, 0);
	check_button = gtk_check_button_new_with_label(app->labels->tool_box.flow);
	g_object_set_data(G_OBJECT(check_button), "flag-id", GINT_TO_POINTER(1));
	gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(check_button), core->flags & BRUSH_FLAG_FLOW);
	(void)g_signal_connect(G_OBJECT(check_button), "toggled", G_CALLBACK(StampCoreSetFlags), core);
	gtk_box_pack_start(GTK_BOX(table), check_button, FALSE, TRUE, 0);
	gtk_box_pack_start(GTK_BOX(vbox), table, FALSE, FALSE, 0);
	check_button = gtk_check_button_new_with_label(app->labels->tool_box.random_size);
	g_object_set_data(G_OBJECT(check_button), "flag-value", GUINT_TO_POINTER(STAMP_RANDOM_SIZE));
	g_object_set_data(G_OBJECT(check_button), "application", app);
	gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(check_button), core->flags & STAMP_RANDOM_SIZE);
	(void)g_signal_connect(G_OBJECT(check_button), "toggled", G_CALLBACK(StampCoreSetFlag), core);
	gtk_box_pack_start(GTK_BOX(vbox), check_button, FALSE, TRUE, 0);

	// ブラシの移動方向へ回転
	check_button = gtk_check_button_new_with_label(app->labels->tool_box.rotate_to_brush_direction);
	gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(check_button),
		brush->core.flags & BRUSH_FLAG_ROTATE);
	(void)g_signal_connect(G_OBJECT(check_button), "toggled",
		G_CALLBACK(ImageBrushSetRotate2Direction), brush);
	gtk_box_pack_start(GTK_BOX(vbox), check_button, FALSE, FALSE, 0);

	// ランダムに回転
	check_button = gtk_check_button_new_with_label(app->labels->tool_box.random_rotate);
	gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(check_button), (core->flags & STAMP_RANDOM_ROTATE) != 0);
	g_object_set_data(G_OBJECT(check_button), "flag-value", GUINT_TO_POINTER(STAMP_RANDOM_ROTATE));
	g_object_set_data(G_OBJECT(check_button), "application", app);
	(void)g_signal_connect(G_OBJECT(check_button), "toggled", G_CALLBACK(StampCoreSetFlag), core);
	gtk_box_pack_start(GTK_BOX(vbox), check_button, FALSE, TRUE, 0);

	// ランダムサイズの変化幅
	scale_adjustment = GTK_ADJUSTMENT(gtk_adjustment_new(brush->size_range * 100, 0, 100, 1, 1, 0));
	scale = SpinScaleNew(scale_adjustment, app->labels->tool_box.size_range, 1);
	(void)g_signal_connect(G_OBJECT(scale_adjustment), "value_changed",
		G_CALLBACK(ImageBrushSetSizeRange), brush);
	gtk_box_pack_start(GTK_BOX(vbox), scale, FALSE, FALSE, 0);

	// ランダム回転の変化幅
	brush->rotate_range = brush->random_rotate_range * G_PI / 180;
	scale_adjustment = GTK_ADJUSTMENT(gtk_adjustment_new(brush->random_rotate_range, 0, 360, 1, 1, 0));
	scale = SpinScaleNew(scale_adjustment, app->labels->tool_box.rotate_range, 0);
	(void)g_signal_connect(G_OBJECT(scale_adjustment), "value_changed",
		G_CALLBACK(ImageBrushSetRotateRange), brush);
	gtk_box_pack_start(GTK_BOX(vbox), scale, FALSE, FALSE, 0);

#undef UI_FONT_SIZE
#undef ICON_SIZE

	return vbox;
}

static void BlendImageBrushButtonPressCallBack(
	DRAW_WINDOW* window,
	FLOAT_T x,
	FLOAT_T y,
	FLOAT_T pressure,
	BRUSH_CORE *core,
	void* state
)
{
	// 左クリックなら
	if(((GdkEventButton*)state)->button == 1)
	{
		// ブラシの詳細情報にキャスト
		BLEND_IMAGE_BRUSH *brush = (BLEND_IMAGE_BRUSH*)core->brush_data;
		// ブラシの半径
		FLOAT_T r;
		// 座標の最大値・最小値
		FLOAT_T min_x, min_y, max_x, max_y;

		window->work_layer->layer_mode = LAYER_BLEND_NORMAL;

		if(brush->target == BLEND_BRUSH_TARGET_UNDER_LAYER && window->active_layer->prev != NULL)
		{
			(void)memcpy(window->brush_buffer, window->active_layer->prev->pixels, window->pixel_buf_size);
		}
		else
		{
			(void)memcpy(window->brush_buffer, window->mixed_layer->pixels, window->pixel_buf_size);
		}

		r = ((brush->core.flags & STAMP_PRESSURE_SIZE) == 0) ?
			brush->core.r : brush->core.r * pressure;

		if((brush->core.flags & STAMP_RANDOM_SIZE) != 0)
		{
			r *= rand() / (FLOAT_T)RAND_MAX;
		}

		brush->stamp_distance = 0;
		brush->core.before_x = x, brush->core.before_y = y;
		brush->points[0][1] = x, brush->points[0][2] = y;
		brush->points[0][3] = pressure;
		brush->sum_distance = brush->travel = brush->finish_length = 0;
		brush->remain_distance = brush->core.d * brush->core.d;
		brush->draw_start = r * brush->out * 0.01 * 4;
		brush->enter_length = r * brush->enter * 0.01 * 4;
		brush->enter_size = (1 - brush->enter * 0.01);
		brush->num_point = 0;
		brush->draw_finished = 0;
		brush->ref_point = 1;

		min_x = x - r, max_x = x + r;
		min_y = y - r, max_y = y + r;

		if(min_x < 0.0)
		{
			min_x = 0.0;
		}
		if(min_y < 0.0)
		{
			min_y = 0.0;
		}
		if(max_x > window->work_layer->width)
		{
			max_x = window->work_layer->width;
		}
		if(max_y > window->work_layer->height)
		{
			max_y = window->work_layer->height;
		}

		core->min_x = min_x, core->min_y = min_y;
		core->max_x = max_x, core->max_y = max_y;

		window->update.x = (int)min_x, window->update.y = (int)min_y;
		window->update.width = (int)max_x - window->update.x;
		window->update.height = (int)max_y - window->update.y;

		window->flags |= DRAW_WINDOW_UPDATE_PART;
	}	// 左クリックなら
		// if(((GdkEventButton*)state)->button == 1)
}

#define BlendImageBrushEditSelectionPress BlendImageBrushButtonPressCallBack

static void BlendImageBrushMotionCallBack(
	DRAW_WINDOW* window,
	FLOAT_T x,
	FLOAT_T y,
	FLOAT_T pressure,
	BRUSH_CORE *core,
	void* state
)
{
	// マウスの左ボタンが押されていたら
	if(((*(GdkModifierType*)state) & GDK_BUTTON1_MASK) != 0)
	{
		// ブラシの詳細情報にキャスト
		BLEND_IMAGE_BRUSH *brush = (BLEND_IMAGE_BRUSH*)core->brush_data;
		FLOAT_T distance;
		int index = brush->ref_point % BRUSH_POINT_BUFFER_SIZE;
		// X、Y方向の移動量
		FLOAT_T dx, dy;
		dx = x-brush->core.before_x;
		dy = y-brush->core.before_y;
		distance = dx*dx + dy*dy;
		brush->stamp_distance += distance;
		brush->remain_distance -= distance;

		if(brush->remain_distance <= 0)
		{
			FLOAT_T update_x, update_y, update_r;

			distance = sqrt(distance);
			brush->core.before_x = x, brush->core.before_y = y;
			brush->sum_distance += distance;
			brush->travel += distance;
			brush->points[index][0] = distance;
			brush->points[index][1] = x, brush->points[index][2] = y;
			brush->points[index][3] = pressure;
			brush->ref_point++;

			if(brush->sum_distance >= brush->draw_start
				&& brush->sum_distance >= brush->enter_length)
			{
				// 更新範囲のイメージ情報
				cairo_t *update;
				cairo_surface_t *update_surface;
				// 入りの色補正用
				FLOAT_T enter_alpha;
				// ブラシの半径と不透明度
				FLOAT_T r, alpha;
				// 座標の最大・最小値
				FLOAT_T min_x, min_y, max_x, max_y;
				// ブラシの傾き用
				FLOAT_T diff_x, diff_y;
				// ブラシの移動量
				FLOAT_T d;
				// 描画を行う座標
				FLOAT_T draw_x = brush->core.before_x, draw_y = brush->core.before_y;
				// 画像に対しての拡大・回転処理用の行列データ
				cairo_matrix_t matrix, reset_matrix;
				// 一時合成用
				cairo_surface_t *draw_surface;
				// 画像の拡大率
				FLOAT_T zoom;
				// 移動量計算用
				FLOAT_T cos_x, sin_y, trans_x, trans_y;
				// 画像の幅・高さの半分
				FLOAT_T half_width, half_height;
				// ピクセルデータをリセットする座標
				int start_x, start_y;
				// 描画する幅、高さ、一行分のバイト数
				int width, height, stride;
				// 作業レイヤーの一行分のバイト数
				int layer_stride = window->work_layer->stride;
				// 作業レイヤーのピクセル
				uint8 *work_pixel = window->work_layer->pixels;
				// 参照ピクセル
				uint8 *mask;
				uint8 *mask_pixel = window->mask->pixels;
				// 配列のインデックス用
				int ref_point = brush->draw_finished % BRUSH_POINT_BUFFER_SIZE;
				int before_point;
				int i;	// for文用のカウンタ

				cairo_matrix_init_scale(&reset_matrix, 1, 1);

				while(brush->sum_distance > brush->draw_start
					&& brush->draw_finished < brush->ref_point-1
					&& brush->remain_distance <= 0)
				{
					if(brush->finish_length < brush->enter_length)
					{
						enter_alpha = brush->finish_length / brush->enter_length;
						r = brush->enter_size + brush->finish_length * 0.25;
					}
					else
					{
						enter_alpha = 1, r = 1;
					}
					if((brush->core.flags & STAMP_PRESSURE_SIZE) != 0)
					{
						r *= brush->points[ref_point][3];
					}
					if((brush->core.flags & STAMP_RANDOM_SIZE) != 0)
					{
						r *= 1 - (brush->size_range * (rand() / (FLOAT_T)RAND_MAX));
					}

					if(r < MIN_BRUSH_STEP)
					{
						r = MIN_BRUSH_STEP;
					}

					half_width = brush->core.half_width * r;
					half_height = brush->core.half_height * r;
					zoom = (1/r) * brush->core.scale;
					r *= brush->core.r;

					alpha = ((brush->core.flags & BRUSH_FLAG_FLOW) == 0)
						? 1 : brush->points[ref_point][3];
					alpha *= enter_alpha;

					before_point = (ref_point == 0) ? BRUSH_POINT_BUFFER_SIZE - 1 : ref_point - 1;
					d = brush->points[ref_point][0];
					brush->sum_distance -= d;
					if(brush->draw_finished == 0)
					{
						draw_x = brush->points[0][1], draw_y = brush->points[0][2];
					}
					else
					{
						draw_x = brush->points[before_point][1];
						draw_y = brush->points[before_point][2];
					}
					dx = brush->points[ref_point][1] - draw_x;
					dy = brush->points[ref_point][2] - draw_y;
					if((brush->core.flags & STAMP_RANDOM_ROTATE) != 0)
					{
						brush->core.rotate = brush->core.rotate_start +
							(rand() / (FLOAT_T)RAND_MAX) * brush->core.rotate_direction * brush->rotate_range;
						if((brush->core.flags & BRUSH_FLAG_ROTATE) != 0)
						{
							brush->core.rotate += brush->core.rotate_direction * atan2(dy, dx);
						}
					}
					else if((brush->core.flags & BRUSH_FLAG_ROTATE) != 0)
					{
						brush->core.rotate = brush->core.rotate_start + brush->core.rotate_direction * atan2(dy, dx);
					}
					else
					{
						brush->core.rotate = brush->core.rotate_start;
					}
					cos_x = cos(brush->core.rotate), sin_y = sin(brush->core.rotate);
					diff_x = brush->core.d * dx/d, diff_y = brush->core.d * dy/d;

					min_x = brush->points[ref_point][1] - r - 1;
					max_x = brush->points[ref_point][1] + r + 1;
					min_y = brush->points[ref_point][2] - r - 1;
					max_y = brush->points[ref_point][2] + r + 1;

					if(min_x < 0.0)
					{
						min_x = 0.0;
					}
					if(core->min_x > min_x)
					{
						core->min_x = min_x;
					}
					if(min_y < 0.0)
					{
						min_y = 0.0;
					}
					if(core->min_y > min_y)
					{
						core->min_y = min_y;
					}
					if(max_x > window->work_layer->width)
					{
						max_x = window->work_layer->width;
					}
					if(core->max_x < max_x)
					{
						core->max_x = max_x;
					}
					if(max_y > window->work_layer->height)
					{
						min_y = window->work_layer->height;
					}
					if(core->max_y < max_y)
					{
						core->max_y = max_y;
					}

					if(window->update.x > min_x)
					{
						window->update.width += window->update.x - (int)min_x;
						window->update.x = (int)min_x;
					}
					if(window->update.width + window->update.x < max_x)
					{
						window->update.width += (int)max_x - window->update.width + window->update.x;
					}
					if(window->update.y > min_y)
					{
						window->update.height += window->update.y - (int)min_y;
						window->update.y = (int)min_y;
					}
					if(window->update.height + window->update.y < max_y)
					{
						window->update.height += (int)max_y - window->update.height + window->update.y;
					}

					if(brush->stamp_distance >= brush->core.d)
					{
						dx = d;
						do
						{
							start_x = (int)(draw_x - r);
							start_y = (int)(draw_y - r);
							width = (int)(draw_x + r);
							height = (int)(draw_y + r);

							if(start_x < 0)
							{
								start_x = 0;
							}
							else if(start_x > window->work_layer->width)
							{
								goto skip_draw;
							}
							if(start_y < 0)
							{
								start_y = 0;
							}
							else if(start_y > window->work_layer->height)
							{
								goto skip_draw;
							}
							if(width > window->work_layer->width)
							{
								width = window->work_layer->width - start_x;
							}
							else
							{
								width = width - start_x;
							}
							if(height > window->work_layer->height)
							{
								height = window->work_layer->height - start_y;
							}
							else
							{
								height = height - start_y;
							}

							if(width < 0 || height < 0)
							{
								goto skip_draw;
							}

							stride = width*4;

							update_surface = cairo_surface_create_for_rectangle(
								window->mask_temp->surface_p, draw_x - r, draw_y - r, r*2+1, r*2+1);
							update = cairo_create(update_surface);

							for(i=0; i<height; i++)
							{
								(void)memset(&window->mask_temp->pixels[(i+start_y)*window->mask_temp->stride+start_x*4],
									0, stride);
							}

							trans_x = r - (half_width * cos_x + half_height * sin_y);
							trans_y = r + (half_width * sin_y - half_height * cos_x);

							// 行列データに拡大・縮小、回転角をセット
							cairo_set_operator(window->mask_temp->cairo_p, CAIRO_OPERATOR_OVER);
							cairo_matrix_init_scale(&matrix, zoom, zoom);
							cairo_matrix_rotate(&matrix, brush->core.rotate);
							cairo_matrix_translate(&matrix, - trans_x, - trans_y);

							mask = window->mask_temp->pixels;
							if((window->flags & DRAW_WINDOW_HAS_SELECTION_AREA) == 0)
							{
								if((window->active_layer->flags & LAYER_LOCK_OPACITY) == 0)
								{
									cairo_set_source(update, core->brush_pattern);
									cairo_pattern_set_matrix(core->brush_pattern, &matrix);
									cairo_paint_with_alpha(update, alpha);
								}
								else
								{
									cairo_pattern_set_matrix(core->brush_pattern, &reset_matrix);
									cairo_set_source(core->temp_cairo, core->brush_pattern);
									cairo_paint_with_alpha(core->temp_cairo, alpha);
									cairo_set_source(update, core->temp_pattern);
									cairo_pattern_set_matrix(core->temp_pattern, &matrix);
									cairo_mask_surface(update,
										window->active_layer->surface_p, - draw_x + r, - draw_y + r);
								}
							}
							else
							{
								if((window->active_layer->flags & LAYER_LOCK_OPACITY) == 0)
								{
									cairo_pattern_set_matrix(core->brush_pattern, &reset_matrix);
									cairo_set_source(core->temp_cairo, core->brush_pattern);
									cairo_paint_with_alpha(core->temp_cairo, alpha);
									cairo_set_source(update, core->temp_pattern);
									cairo_pattern_set_matrix(core->temp_pattern, &matrix);
									cairo_mask_surface(update,
										window->selection->surface_p, - draw_x + r, - draw_y + r);
								}
								else
								{
									cairo_surface_t *temp_surface = cairo_surface_create_for_rectangle(
										window->temp_layer->surface_p, draw_x-r, draw_y-r, r*2+1, r*2+1
									);
									cairo_t *update_temp = cairo_create(temp_surface);

									for(i=0; i<height; i++)
									{
										(void)memset(&window->temp_layer->pixels[
											(i+start_y)*window->temp_layer->stride+start_x*4],
											0, stride
										);
									}

									cairo_pattern_set_matrix(core->brush_pattern, &reset_matrix);
									cairo_set_source(core->temp_cairo, core->brush_pattern);
									cairo_paint_with_alpha(core->temp_cairo, alpha);
									cairo_set_source(update, core->temp_pattern);
									cairo_mask_surface(update,
										window->selection->surface_p, - draw_x + r, - draw_y + r);
									cairo_set_source_surface(update_temp,
										update_surface, 0, 0);
									cairo_mask_surface(update_temp,
										window->active_layer->surface_p, - draw_x + r, - draw_y + r);

									mask = window->temp_layer->pixels;

									cairo_surface_destroy(temp_surface);
									cairo_destroy(update_temp);
								}
							}

							// テクスチャを適用
							if(window->app->textures.active_texture != 0)
							{
								cairo_surface_t *temp_surface = cairo_surface_create_for_rectangle(
									window->temp_layer->surface_p, draw_x - r, draw_y - r, r*2+1, r*2+1);
								cairo_t *update_temp = cairo_create(temp_surface);

								if(mask == window->mask_temp->pixels)
								{
									for(i=0; i<height; i++)
									{
										(void)memset(&window->temp_layer->pixels[
											(i+start_y)*window->temp_layer->stride+start_x*4],
											0, stride
										);
									}
									cairo_set_source_surface(update_temp,
										update_surface, 0, 0);
									cairo_mask_surface(update_temp, window->texture->surface_p, - draw_x + r, - draw_y + r);
									mask = window->temp_layer->pixels;
								}
								else
								{
									for(i=0; i<height; i++)
									{
										(void)memset(&window->mask_temp->pixels[
											(i+start_y)*window->mask_temp->stride+start_x*4],
											0, stride
										);
									}
									cairo_set_source_surface(update,
										temp_surface, 0, 0);
									cairo_mask_surface(update, window->texture->surface_p, - draw_x + r, - draw_y + r);
									mask = window->mask_temp->pixels;
								}

								cairo_surface_destroy(temp_surface);
								cairo_destroy(update_temp);
							}

							cairo_surface_destroy(update_surface);
							cairo_destroy(update);

							if(mask == window->mask_temp->pixels)
							{
								update_surface = cairo_surface_create_for_rectangle(
									window->mask_temp->surface_p, start_x, start_y, width, height);
							}
							else
							{
								update_surface = cairo_surface_create_for_rectangle(
									window->temp_layer->surface_p, start_x, start_y, width, height);
							}
							draw_surface = cairo_image_surface_create_for_data(window->mask->pixels,
								CAIRO_FORMAT_ARGB32, width, height, stride);
							for(i=0; i<height; i++)
							{
								(void)memcpy(&window->mask->pixels[i*stride],
									&window->brush_buffer[(start_y+i)*window->stride+start_x*4], stride);
							}

							update = cairo_create(draw_surface);
							cairo_set_operator(update, window->app->layer_blend_operators[brush->blend_mode]);
							cairo_set_source_surface(update, update_surface, 0, 0);
							cairo_paint(update);

							cairo_destroy(update);
							cairo_surface_destroy(draw_surface);
							cairo_surface_destroy(update_surface);

#ifdef _OPENMP
#pragma omp parallel for firstprivate(work_pixel, layer_stride, start_x, start_y, width, mask, mask_pixel, stride)
#endif
							for(i=0; i<height; i++)
							{
								uint8 *ref_pix = &work_pixel[
									(start_y+i)*layer_stride+start_x*4];
								uint8 *mask_pix = &mask_pixel[i*stride];
								uint8 *alpha_pix = &mask[(start_y+i)*layer_stride
									+start_x*4+3];
								uint8 draw_value;
								int j;

								for(j=0; j<width; j++, ref_pix+=4, mask_pix+=4, alpha_pix+=4)
								{
									if(ref_pix[3] < *alpha_pix)
									{
										draw_value = (uint8)((uint32)(((int)mask_pix[0]) * *alpha_pix >> 8));
										if(draw_value > ref_pix[0])
										{
											ref_pix[0] = (uint8)((uint32)(((int)draw_value-(int)ref_pix[0])
												* *alpha_pix >> 8) + ref_pix[0]);
										}
										draw_value = (uint8)((uint32)(((int)mask_pix[1]) * *alpha_pix >> 8));
										if(draw_value > ref_pix[1])
										{
											ref_pix[1] = (uint8)((uint32)(((int)draw_value-(int)ref_pix[1])
												* *alpha_pix >> 8) + ref_pix[1]);
										}
										draw_value = (uint8)((uint32)(((int)mask_pix[2]) * *alpha_pix >> 8));
										if(draw_value > ref_pix[2])
										{
											ref_pix[2] = (uint8)((uint32)(((int)draw_value-(int)ref_pix[2])
												* *alpha_pix >> 8) + ref_pix[2]);
										}
										ref_pix[3] = (uint8)((uint32)(((int)*alpha_pix-(int)ref_pix[3])
											* *alpha_pix >> 8) + ref_pix[3]);
									}
								}
							}

							update_r = r * window->zoom_rate;
							update_x = ((draw_x-window->width/2)*window->cos_value + (draw_y-window->height/2)*window->sin_value) * window->zoom_rate
								+ window->rev_add_cursor_x;
							update_y = (- (draw_x-window->width/2)*window->sin_value + (draw_y-window->height/2)*window->cos_value) * window->zoom_rate
								+ window->rev_add_cursor_y;
							gtk_widget_queue_draw_area(window->window, (gint)(update_x-update_r), (gint)(update_y-update_r),
								(gint)(update_r * 2 + BRUSH_UPDATE_MARGIN), (gint)(update_r * 2 + BRUSH_UPDATE_MARGIN));
skip_draw:
							dx -= brush->core.d;
							brush->remain_distance += brush->core.d * brush->core.d;
							brush->stamp_distance -= brush->core.d;
							if(brush->remain_distance > 0)
							{
								break;
							}
							else
							{
								draw_x += diff_x, draw_y += diff_y;
							}
						} while(1);
					}

					brush->finish_length += d;
					brush->travel += d;
					brush->draw_finished++;
					ref_point = brush->draw_finished % BRUSH_POINT_BUFFER_SIZE;
				}	// while(brush->sum_distance > brush->draw_start
						// && brush->draw_finished < brush->ref_point)
			}	// if(brush->sum_distance >= brush->draw_start
					// && brush->sum_distance >= brush->enter_length)
		}	// if(distance >= 1.0)

		window->flags |= DRAW_WINDOW_UPDATE_PART;
	}	// マウスの左ボタンが押されていたら
		// if(((*(GdkModifierType*)state) & GDK_BUTTON1_MASK) != 0)
}

#define BlendImageBrushEditSelectionMotion BlendImageBrushMotionCallBack

static void BlendImageBrushButtonReleaseCallBack(
	DRAW_WINDOW* window,
	FLOAT_T x,
	FLOAT_T y,
	FLOAT_T pressure,
	BRUSH_CORE *core,
	void* state
)
{
	// マウスの左ボタンなら
	if(((GdkEventButton*)state)->button == 1)
	{
		// ブラシの詳細情報にキャスト
		BLEND_IMAGE_BRUSH *brush = (BLEND_IMAGE_BRUSH*)core->brush_data;
		// 更新範囲のイメージ情報
		cairo_t *update;
		cairo_surface_t *update_surface;
		// ブラシの半径と不透明度
		FLOAT_T r, alpha;
		// 座標の最大・最小値
		FLOAT_T min_x, min_y, max_x, max_y;
		// X、Y方向の移動量
		FLOAT_T dx, dy;
		// ブラシの傾き用
		FLOAT_T diff_x, diff_y;
		// ブラシの移動量
		FLOAT_T d;
		// 描画を行う座標
		FLOAT_T draw_x, draw_y;
		// 画面更新を行う座標、範囲
		FLOAT_T update_x, update_y, update_r;
		// 入り、抜き時の色補正
		FLOAT_T enter_alpha, out_alpha;
		// ピクセルデータをリセットする座標
		int start_x, start_y;
		// 描画する幅、高さ、一行分のバイト数
		int width, height, stride;
		// 作業レイヤーの一行分のバイト数
		int layer_stride = window->work_layer->stride;
		// 作業レイヤーのピクセル
		uint8 *work_pixel = window->work_layer->pixels;
		// 画像に対しての拡大・回転処理用の行列データ
		cairo_matrix_t matrix, reset_matrix;
		// 一時合成用
		cairo_surface_t *draw_surface;
		// 画像の拡大率
		FLOAT_T zoom;
		// 移動量計算用
		FLOAT_T cos_x, sin_y, trans_x, trans_y;
		// 画像の幅・高さの半分
		FLOAT_T half_width, half_height;
		// 参照ピクセル
		uint8 *mask;
		uint8 *mask_pixel = window->mask->pixels;
		// 配列のインデックス用
		int ref_point;
		int before_point;
		int i;	// for文用のカウンタ

		ref_point = brush->ref_point % BRUSH_POINT_BUFFER_SIZE;
		brush->points[ref_point][1] = x, brush->points[ref_point][2] = y;
		brush->ref_point++;

		while(brush->ref_point > brush->draw_finished)
		{
			ref_point = brush->draw_finished % BRUSH_POINT_BUFFER_SIZE;

			if(brush->finish_length < brush->enter_length)
			{
				enter_alpha = brush->finish_length / brush->enter_length;
				r = brush->enter_size + brush->finish_length * 0.25;
			}
			else
			{
				enter_alpha = 1;
				r = 1;
			}

			if((brush->core.flags & STAMP_PRESSURE_SIZE) != 0)
			{
				r *= brush->points[ref_point][3];
			}
			if((brush->core.flags & STAMP_RANDOM_SIZE) != 0)
			{
				r *= 1 - (brush->size_range * (rand() / (FLOAT_T)RAND_MAX));
			}
			if(r < MIN_BRUSH_STEP)
			{
				r = MIN_BRUSH_STEP;
			}

			if((brush->core.flags & STAMP_RANDOM_ROTATE) != 0)
			{
				brush->core.rotate = (rand() / (FLOAT_T)RAND_MAX) * (2*G_PI);
			}

			half_width = brush->core.half_width * r;
			half_height = brush->core.half_height * r;
			zoom = (1/r) * brush->core.scale;
			r *= brush->core.r;

			if(brush->sum_distance < brush->draw_start)
			{
				out_alpha = brush->sum_distance / brush->draw_start;
				r -= (brush->draw_start - brush->sum_distance) * 0.25;
			}
			else
			{
				out_alpha = 1;
			}

			if(r < 0.0)
			{
				brush->draw_finished++;
				continue;
			}

			alpha = ((brush->core.flags & BRUSH_FLAG_FLOW) == 0)
				? 1 : brush->points[ref_point][3];
			alpha *= enter_alpha;

			before_point = (ref_point == 0) ? BRUSH_POINT_BUFFER_SIZE - 1 : ref_point - 1;
			d = brush->points[ref_point][0];
			brush->sum_distance -= d;
			if(brush->draw_finished == 0)
			{
				draw_x = brush->points[0][1], draw_y = brush->points[0][2];
			}
			else
			{
				draw_x = brush->points[before_point][1];
				draw_y = brush->points[before_point][2];
			}
			dx = brush->points[ref_point][1] - draw_x;
			dy = brush->points[ref_point][2] - draw_y;

			if((brush->core.flags & STAMP_RANDOM_ROTATE) != 0)
			{
				brush->core.rotate = brush->core.rotate_start +
					(rand() / (FLOAT_T)RAND_MAX) * brush->core.rotate_direction * brush->rotate_range;
				if((brush->core.flags & BRUSH_FLAG_ROTATE) != 0)
				{
					brush->core.rotate += brush->core.rotate_direction * atan2(dy, dx);
				}
			}
			else if((brush->core.flags & BRUSH_FLAG_ROTATE) != 0)
			{
				brush->core.rotate = brush->core.rotate_start + brush->core.rotate_direction * atan2(dy, dx);
			}
			else
			{
				brush->core.rotate = brush->core.rotate_start;
			}
			cos_x = cos(brush->core.rotate), sin_y = sin(brush->core.rotate);
			diff_x = dx/d, diff_y = dy/d;

			min_x = brush->points[ref_point][1] - r - 1;
			max_x = brush->points[ref_point][1] + r + 1;
			min_y = brush->points[ref_point][2] - r - 1;
			max_y = brush->points[ref_point][2] + r + 1;

			if(min_x < 0.0)
			{
				min_x = 0.0;
			}
			if(core->min_x > min_x)
			{
				core->min_x = min_x;
			}
			if(min_y < 0.0)
			{
				min_y = 0.0;
			}
			if(core->min_y > min_y)
			{
				core->min_y = min_y;
			}
			if(max_x > window->work_layer->width)
			{
				max_x = window->work_layer->width;
			}
			if(core->max_x < max_x)
			{
				core->max_x = max_x;
			}
			if(max_y > window->work_layer->height)
			{
				min_y = window->work_layer->height;
			}
			if(core->max_y < max_y)
			{
				core->max_y = max_y;
			}

			if(window->update.x > min_x)
			{
				window->update.width += window->update.x - (int)min_x;
				window->update.x = (int)min_x;
			}
			if(window->update.width + window->update.x < max_x)
			{
				window->update.width += (int)max_x - window->update.width + window->update.x;
			}
			if(window->update.y > min_y)
			{
				window->update.height += window->update.y - (int)min_y;
				window->update.y = (int)min_y;
			}
			if(window->update.height + window->update.y < max_y)
			{
				window->update.height += (int)max_y - window->update.height + window->update.y;
			}

			if(brush->stamp_distance > brush->core.d || brush->draw_finished == 0)
			{
				dx = d;
				do
				{
					start_x = (int)(draw_x - r);
					start_y = (int)(draw_y - r);
					width = (int)(draw_x + r);
					height = (int)(draw_y + r);

					if(start_x < 0)
					{
						start_x = 0;
					}
					else if(start_x > window->work_layer->width)
					{
						goto skip_draw;
					}
					if(start_y < 0)
					{
						start_y = 0;
					}
					else if(start_y > window->work_layer->height)
					{
						goto skip_draw;
					}
					if(width > window->work_layer->width)
					{
						width = window->work_layer->width - start_x;
					}
					else
					{
						width = width - start_x;
					}
					if(height > window->work_layer->height)
					{
						height = window->work_layer->height - start_y;
					}
					else
					{
						height = height - start_y;
					}

					if(width < 0 || height < 0)
					{
						goto skip_draw;
					}

					stride = width*4;

					update_surface = cairo_surface_create_for_rectangle(
						window->mask_temp->surface_p, draw_x - r, draw_y - r, r*2+1, r*2+1);
					update = cairo_create(update_surface);

					for(i=0; i<height; i++)
					{
						(void)memset(&window->mask_temp->pixels[(i+start_y)*window->mask_temp->stride+start_x*4],
							0, stride);
					}

					trans_x = r - (half_width * cos_x + half_height * sin_y);
					trans_y = r + (half_width * sin_y - half_height * cos_x);

					// 行列データに拡大・縮小、回転角をセット
					cairo_set_operator(window->mask_temp->cairo_p, CAIRO_OPERATOR_OVER);
					cairo_matrix_init_scale(&matrix, zoom, zoom);
					cairo_matrix_rotate(&matrix, brush->core.rotate);
					cairo_matrix_translate(&matrix, - trans_x, - trans_y);

					mask = window->mask_temp->pixels;
					if((window->flags & DRAW_WINDOW_HAS_SELECTION_AREA) == 0)
					{
						if((window->active_layer->flags & LAYER_LOCK_OPACITY) == 0)
						{
							cairo_set_source(update, core->brush_pattern);
							cairo_pattern_set_matrix(core->brush_pattern, &matrix);
							cairo_paint_with_alpha(update, alpha);
						}
						else
						{
							cairo_pattern_set_matrix(core->brush_pattern, &reset_matrix);
							cairo_set_source(core->temp_cairo, core->brush_pattern);
							cairo_paint_with_alpha(core->temp_cairo, alpha);
							cairo_set_source(update, core->temp_pattern);
							cairo_pattern_set_matrix(core->temp_pattern, &matrix);
							cairo_mask_surface(update,
								window->active_layer->surface_p, - draw_x + r, - draw_y + r);
						}
					}
					else
					{
						if((window->active_layer->flags & LAYER_LOCK_OPACITY) == 0)
						{
							cairo_pattern_set_matrix(core->brush_pattern, &reset_matrix);
							cairo_set_source(core->temp_cairo, core->brush_pattern);
							cairo_paint_with_alpha(core->temp_cairo, alpha);
							cairo_set_source(update, core->temp_pattern);
							cairo_pattern_set_matrix(core->temp_pattern, &matrix);
							cairo_mask_surface(update,
								window->selection->surface_p, - draw_x + r, - draw_y + r);
						}
						else
						{
							cairo_surface_t *temp_surface = cairo_surface_create_for_rectangle(
								window->temp_layer->surface_p, draw_x-r, draw_y-r, r*2+1, r*2+1
							);
							cairo_t *update_temp = cairo_create(temp_surface);

							for(i=0; i<height; i++)
							{
								(void)memset(&window->temp_layer->pixels[
									(i+start_y)*window->temp_layer->stride+start_x*4],
									0, stride
								);
							}

							cairo_pattern_set_matrix(core->brush_pattern, &reset_matrix);
							cairo_set_source(core->temp_cairo, core->brush_pattern);
							cairo_paint_with_alpha(core->temp_cairo, alpha);
							cairo_set_source(update, core->temp_pattern);
							cairo_mask_surface(update,
								window->selection->surface_p, - draw_x + r, - draw_y + r);
							cairo_set_source_surface(update_temp,
								update_surface, 0, 0);
							cairo_mask_surface(update_temp,
								window->active_layer->surface_p, - draw_x + r, - draw_y + r);

							mask = window->temp_layer->pixels;

							cairo_surface_destroy(temp_surface);
							cairo_destroy(update_temp);
						}
					}

					// テクスチャを適用
					if(window->app->textures.active_texture != 0)
					{
						cairo_surface_t *temp_surface = cairo_surface_create_for_rectangle(
							window->temp_layer->surface_p, draw_x - r, draw_y - r, r*2+1, r*2+1);
						cairo_t *update_temp = cairo_create(temp_surface);

						if(mask == window->mask_temp->pixels)
						{
							for(i=0; i<height; i++)
							{
								(void)memset(&window->temp_layer->pixels[
									(i+start_y)*window->temp_layer->stride+start_x*4],
									0, stride
								);
							}
							cairo_set_source_surface(update_temp,
								update_surface, 0, 0);
							cairo_mask_surface(update_temp, window->texture->surface_p, - draw_x + r, - draw_y + r);
							mask = window->temp_layer->pixels;
						}
						else
						{
							for(i=0; i<height; i++)
							{
								(void)memset(&window->mask_temp->pixels[
									(i+start_y)*window->mask_temp->stride+start_x*4],
									0, stride
								);
							}
							cairo_set_source_surface(update,
								temp_surface, 0, 0);
							cairo_mask_surface(update, window->texture->surface_p, - draw_x + r, - draw_y + r);
							mask = window->mask_temp->pixels;
						}

						cairo_surface_destroy(temp_surface);
						cairo_destroy(update_temp);
					}

					cairo_surface_destroy(update_surface);
					cairo_destroy(update);

					if(mask == window->mask_temp->pixels)
					{
						update_surface = cairo_surface_create_for_rectangle(
							window->mask_temp->surface_p, start_x, start_y, width, height);
					}
					else
					{
						update_surface = cairo_surface_create_for_rectangle(
							window->temp_layer->surface_p, start_x, start_y, width, height);
					}
					draw_surface = cairo_image_surface_create_for_data(window->mask->pixels,
						CAIRO_FORMAT_ARGB32, width, height, stride);
					for(i=0; i<height; i++)
					{
						(void)memcpy(&window->mask->pixels[i*stride],
							&window->brush_buffer[(start_y+i)*window->stride+start_x*4], stride);
					}

					update = cairo_create(draw_surface);
					cairo_set_operator(update, window->app->layer_blend_operators[brush->blend_mode]);
					cairo_set_source_surface(update, update_surface, 0, 0);
					cairo_paint(update);

					cairo_destroy(update);
					cairo_surface_destroy(draw_surface);
					cairo_surface_destroy(update_surface);

#ifdef _OPENMP
#pragma omp parallel for firstprivate(work_pixel, layer_stride, start_x, start_y, width, mask, mask_pixel, stride)
#endif
					for(i=0; i<height; i++)
					{
						uint8 *ref_pix = &work_pixel[
							(start_y+i)*layer_stride+start_x*4];
						uint8 *mask_pix = &mask_pixel[i*stride];
						uint8 *alpha_pix = &mask[(start_y+i)*layer_stride
							+start_x*4+3];
						uint8 draw_value;
						int j;

						for(j=0; j<width; j++, ref_pix+=4, mask_pix+=4, alpha_pix+=4)
						{
							if(ref_pix[3] < *alpha_pix)
							{
								draw_value = (uint8)((uint32)(((int)mask_pix[0]) * *alpha_pix >> 8));
								if(draw_value > ref_pix[0])
								{
									ref_pix[0] = (uint8)((uint32)(((int)draw_value-(int)ref_pix[0])
										* *alpha_pix >> 8) + ref_pix[0]);
								}
								draw_value = (uint8)((uint32)(((int)mask_pix[1]) * *alpha_pix >> 8));
								if(draw_value > ref_pix[1])
								{
									ref_pix[1] = (uint8)((uint32)(((int)draw_value-(int)ref_pix[1])
										* *alpha_pix >> 8) + ref_pix[1]);
								}
								draw_value = (uint8)((uint32)(((int)mask_pix[2]) * *alpha_pix >> 8));
								if(draw_value > ref_pix[2])
								{
									ref_pix[2] = (uint8)((uint32)(((int)draw_value-(int)ref_pix[2])
										* *alpha_pix >> 8) + ref_pix[2]);
								}
								ref_pix[3] = (uint8)((uint32)(((int)*alpha_pix-(int)ref_pix[3])
									* *alpha_pix >> 8) + ref_pix[3]);
							}
						}
					}

					update_r = r * window->zoom_rate;
					update_x = ((draw_x-window->width/2)*window->cos_value + (draw_y-window->height/2)*window->sin_value) * window->zoom_rate
						+ window->rev_add_cursor_x;
					update_y = (- (draw_x-window->width/2)*window->sin_value + (draw_y-window->height/2)*window->cos_value) * window->zoom_rate
						+ window->rev_add_cursor_y;
					gtk_widget_queue_draw_area(window->window, (gint)(update_x-update_r), (gint)(update_y-update_r),
						(gint)(update_r * 2 + BRUSH_UPDATE_MARGIN), (gint)(update_r * 2 + BRUSH_UPDATE_MARGIN));
skip_draw:
					dx -= brush->core.d;
					brush->stamp_distance -= brush->core.d;
					if(dx < brush->core.d)
					{
						break;
					}
					else
					{
						draw_x += diff_x, draw_y += diff_y;
					}
				} while(1);
			}

			brush->finish_length += d;
			brush->travel += d;
			brush->draw_finished++;
			ref_point = brush->draw_finished % BRUSH_POINT_BUFFER_SIZE;
		}	// while(brush->ref_point > brush->draw_finished)

		AddBrushHistory(core, window->active_layer);

		window->update.surface_p = cairo_surface_create_for_rectangle(
			window->active_layer->surface_p, window->update.x, window->update.y,
				window->update.width, window->update.height);
		window->update.cairo_p = cairo_create(window->update.surface_p);
		window->part_layer_blend_functions[window->work_layer->layer_mode](window->work_layer, &window->update);
		cairo_destroy(window->update.cairo_p);
		cairo_surface_destroy(window->update.surface_p);

		(void)memset(window->work_layer->pixels, 0, window->work_layer->stride*window->work_layer->height);

		window->work_layer->layer_mode = LAYER_BLEND_NORMAL;

		brush->core.rotate = brush->core.rotate_start;

		window->flags |= DRAW_WINDOW_UPDATE_PART;
	}	// マウスの左ボタンなら
		// if(((GdkEventButton*)state)->button == 1)
}

static void BlendImageBrushEditSelectionRelease(
	DRAW_WINDOW* window,
	FLOAT_T x,
	FLOAT_T y,
	FLOAT_T pressure,
	BRUSH_CORE *core,
	void* state
)
{
	// マウスの左ボタンなら
	if(((GdkEventButton*)state)->button == 1)
	{
		// ブラシの詳細情報にキャスト
		BLEND_IMAGE_BRUSH *brush = (BLEND_IMAGE_BRUSH*)core->brush_data;
		// ブラシの半径と不透明度
		FLOAT_T r, alpha;
		// 座標の最大・最小値
		FLOAT_T min_x, min_y, max_x, max_y;
		// X、Y方向の移動量
		FLOAT_T dx, dy;
		// ブラシの傾き用
		FLOAT_T diff_x, diff_y;
		// ブラシの移動量
		FLOAT_T d;
		// 描画を行う座標
		FLOAT_T draw_x, draw_y;
		// 入り、抜き時の色補正
		FLOAT_T enter_alpha, out_alpha;
		// ピクセルデータをリセットする座標
		int start_x, start_y;
		// 描画する幅、高さ、一行分のバイト数
		int width, height, stride;
		// 作業レイヤーの一行分のバイト数
		int layer_stride = window->work_layer->stride;
		// 作業レイヤーのピクセル
		uint8 *work_pixel = window->work_layer->pixels;
		// 画像に対しての拡大・回転処理用の行列データ
		cairo_matrix_t matrix, reset_matrix;
		// 画像の拡大率
		FLOAT_T zoom;
		// 移動量計算用
		FLOAT_T cos_x, sin_y, trans_x, trans_y;
		// 画像の幅・高さの半分
		FLOAT_T half_width, half_height;
		// 参照ピクセル
		uint8 *mask;
		// 配列のインデックス用
		int ref_point;
		int before_point;
		int i;	// for文用のカウンタ

		ref_point = brush->ref_point % BRUSH_POINT_BUFFER_SIZE;
		brush->points[ref_point][1] = x, brush->points[ref_point][2] = y;
		brush->ref_point++;

		while(brush->ref_point > brush->draw_finished)
		{
			ref_point = brush->draw_finished % BRUSH_POINT_BUFFER_SIZE;

			if(brush->finish_length < brush->enter_length)
			{
				enter_alpha = brush->finish_length / brush->enter_length;
				r = brush->enter_size + brush->finish_length * 0.25;
			}
			else
			{
				enter_alpha = 1;
				r = 1;
			}

			if((brush->core.flags & STAMP_PRESSURE_SIZE) != 0)
			{
				r *= brush->points[ref_point][3];
			}
			if((brush->core.flags & STAMP_RANDOM_SIZE) != 0)
			{
				r *= 1 - (brush->size_range * (rand() / (FLOAT_T)RAND_MAX));
			}
			if(r < MIN_BRUSH_STEP)
			{
				r = MIN_BRUSH_STEP;
			}

			if((brush->core.flags & STAMP_RANDOM_ROTATE) != 0)
			{
				brush->core.rotate = (rand() / (FLOAT_T)RAND_MAX) * (2*G_PI);
			}

			half_width = brush->core.half_width * r;
			half_height = brush->core.half_height * r;
			zoom = (1/r) * brush->core.scale;
			r *= brush->core.r;

			if(brush->sum_distance < brush->draw_start)
			{
				out_alpha = brush->sum_distance / brush->draw_start;
				r -= (brush->draw_start - brush->sum_distance) * 0.25;
			}
			else
			{
				out_alpha = 1;
			}

			if(r < 0.0)
			{
				brush->draw_finished++;
				continue;
			}

			alpha = ((brush->core.flags & BRUSH_FLAG_FLOW) == 0)
				? brush->core.flow : brush->core.flow * brush->points[ref_point][3];
			alpha *= enter_alpha;

			if(brush->core.brush_surface != NULL)
			{
				cairo_surface_destroy(brush->core.brush_surface);
			}
			brush->core.brush_surface = CreatePatternSurface(
				&window->app->stamps, *core->color, *core->back_color, brush->core.pattern_flags, brush->mode, alpha);

			before_point = (ref_point == 0) ? BRUSH_POINT_BUFFER_SIZE - 1 : ref_point - 1;
			d = brush->points[ref_point][0];
			brush->sum_distance -= d;
			if(brush->draw_finished == 0)
			{
				draw_x = brush->points[0][1], draw_y = brush->points[0][2];
			}
			else
			{
				draw_x = brush->points[before_point][1];
				draw_y = brush->points[before_point][2];
			}
			dx = brush->points[ref_point][1] - draw_x;
			dy = brush->points[ref_point][2] - draw_y;

			if((brush->core.flags & STAMP_RANDOM_ROTATE) != 0)
			{
				brush->core.rotate = brush->core.rotate_start +
					(rand() / (FLOAT_T)RAND_MAX) * brush->core.rotate_direction * brush->rotate_range;
				if((brush->core.flags & BRUSH_FLAG_ROTATE) != 0)
				{
					brush->core.rotate += brush->core.rotate_direction * atan2(dy, dx);
				}
			}
			else if((brush->core.flags & BRUSH_FLAG_ROTATE) != 0)
			{
				brush->core.rotate = brush->core.rotate_start + brush->core.rotate_direction * atan2(dy, dx);
			}
			else
			{
				brush->core.rotate = brush->core.rotate_start;
			}

			cos_x = cos(brush->core.rotate), sin_y = sin(brush->core.rotate);
			diff_x = dx/d, diff_y = dy/d;

			min_x = brush->points[ref_point][1] - r - 1;
			max_x = brush->points[ref_point][1] + r + 1;
			min_y = brush->points[ref_point][2] - r - 1;
			max_y = brush->points[ref_point][2] + r + 1;

			if(min_x < 0.0)
			{
				min_x = 0.0;
			}
			if(core->min_x > min_x)
			{
				core->min_x = min_x;
			}
			if(min_y < 0.0)
			{
				min_y = 0.0;
			}
			if(core->min_y > min_y)
			{
				core->min_y = min_y;
			}
			if(max_x > window->work_layer->width)
			{
				max_x = window->work_layer->width;
			}
			if(core->max_x < max_x)
			{
				core->max_x = max_x;
			}
			if(max_y > window->work_layer->height)
			{
				min_y = window->work_layer->height;
			}
			if(core->max_y < max_y)
			{
				core->max_y = max_y;
			}

			if(brush->stamp_distance > brush->core.d)
			{
				dx = d;
				do
				{
					start_x = (int)(draw_x - r);
					start_y = (int)(draw_y - r);
					width = (int)(draw_x + r);
					height = (int)(draw_y + r);

					if(start_x < 0)
					{
						start_x = 0;
					}
					else if(start_x > window->work_layer->width)
					{
						goto skip_draw;
					}
					if(start_y < 0)
					{
						start_y = 0;
					}
					else if(start_y > window->work_layer->height)
					{
						goto skip_draw;
					}
					if(width > window->work_layer->width)
					{
						width = window->work_layer->width - start_x;
					}
					else
					{
						width = width - start_x;
					}
					if(height > window->work_layer->height)
					{
						height = window->work_layer->height - start_y;
					}
					else
					{
						height = height - start_y;
					}

					if(width < 0 || height < 0)
					{
						goto skip_draw;
					}
					stride = width*4;

					for(i=0; i<height; i++)
					{
						(void)memset(&window->mask_temp->pixels[(i+start_y)*window->mask_temp->stride+start_x*4],
							0, stride);
					}

					trans_x = draw_x - (half_width * cos_x + half_height * sin_y);
					trans_y = draw_y + (half_width * sin_y - half_height * cos_x);
					// 行列データに拡大・縮小、回転角をセット
					cairo_set_operator(window->mask_temp->cairo_p, CAIRO_OPERATOR_OVER);
					cairo_matrix_init_scale(&matrix, zoom, zoom);
					cairo_matrix_rotate(&matrix, brush->core.rotate);
					cairo_matrix_translate(&matrix, - trans_x, - trans_y);

					mask = window->mask_temp->pixels;
					if((window->flags & DRAW_WINDOW_HAS_SELECTION_AREA) == 0)
					{
						if((window->active_layer->flags & LAYER_LOCK_OPACITY) == 0)
						{
							cairo_set_source(window->mask_temp->cairo_p, core->brush_pattern);
							cairo_pattern_set_matrix(core->brush_pattern, &matrix);
							cairo_paint_with_alpha(window->mask_temp->cairo_p, alpha);
						}
						else
						{
							cairo_pattern_set_matrix(core->brush_pattern, &reset_matrix);
							cairo_set_source(core->temp_cairo, core->brush_pattern);
							cairo_paint_with_alpha(core->temp_cairo, alpha);
							cairo_set_source(window->mask_temp->cairo_p, core->temp_pattern);
							cairo_pattern_set_matrix(core->temp_pattern, &matrix);
							cairo_mask_surface(window->mask_temp->cairo_p,
								window->active_layer->surface_p, 0, 0);
						}
					}
					else
					{
						if((window->active_layer->flags & LAYER_LOCK_OPACITY) == 0)
						{
							cairo_pattern_set_matrix(core->brush_pattern, &reset_matrix);
							cairo_set_source(core->temp_cairo, core->brush_pattern);
							cairo_paint_with_alpha(core->temp_cairo, alpha);
							cairo_set_source(window->mask_temp->cairo_p, core->temp_pattern);
							cairo_pattern_set_matrix(core->temp_pattern, &matrix);
							cairo_mask_surface(window->mask_temp->cairo_p,
								window->selection->surface_p, 0, 0);
						}
						else
						{
							for(i=0; i<height; i++)
							{
								(void)memset(&window->temp_layer->pixels[
									(i+start_y)*window->temp_layer->stride+start_x*4],
									0, stride
								);
							}

							cairo_pattern_set_matrix(core->brush_pattern, &reset_matrix);
							cairo_set_source(core->temp_cairo, core->brush_pattern);
							cairo_paint_with_alpha(core->temp_cairo, alpha);
							cairo_set_source(window->mask_temp->cairo_p, core->temp_pattern);
							cairo_mask_surface(window->mask_temp->cairo_p,
								window->selection->surface_p, 0, 0);
							cairo_set_source_surface(window->temp_layer->cairo_p,
								window->mask_temp->surface_p, 0, 0);
							cairo_mask_surface(window->temp_layer->cairo_p,
								window->active_layer->surface_p, 0, 0);

							mask = window->temp_layer->pixels;
						}
					}

					// テクスチャを適用
					if(window->app->textures.active_texture != 0)
					{
						if(mask == window->mask_temp->pixels)
						{
							for(i=0; i<height; i++)
							{
								(void)memset(&window->temp_layer->pixels[
									(i+start_y)*window->temp_layer->stride+start_x*4],
									0, stride
								);
							}
							cairo_set_source_surface(window->temp_layer->cairo_p,
								window->mask_temp->surface_p, 0, 0);
							cairo_mask_surface(window->temp_layer->cairo_p, window->texture->surface_p, 0, 0);
							mask = window->temp_layer->pixels;
						}
						else
						{
							for(i=0; i<height; i++)
							{
								(void)memset(&window->mask_temp->pixels[
									(i+start_y)*window->mask_temp->stride+start_x*4],
									0, stride
								);
							}
							cairo_set_source_surface(window->mask_temp->cairo_p,
								window->temp_layer->surface_p, 0, 0);
							cairo_mask_surface(window->mask_temp->cairo_p, window->texture->surface_p, 0, 0);
							mask = window->mask_temp->pixels;
						}
					}

#ifdef _OPENMP
#pragma omp parallel for firstprivate(work_pixel, width, layer_stride, start_x, start_y, mask)
#endif
					for(i=0; i<height; i++)
					{
						uint8 *ref_pix = &work_pixel[
							(start_y+i)*layer_stride+start_x*4];
						uint8 *mask_pix = &mask[(start_y+i)*layer_stride
							+start_x*4];
						int j;

						for(j=0; j<width; j++, ref_pix+=4, mask_pix+=4)
						{
							if(ref_pix[3] < mask_pix[3])
							{
								ref_pix[0] = (uint8)((uint32)(((int)mask_pix[0]-(int)ref_pix[0])
									* mask_pix[3] >> 8) + ref_pix[0]);
								ref_pix[1] = (uint8)((uint32)(((int)mask_pix[1]-(int)ref_pix[1])
									* mask_pix[3] >> 8) + ref_pix[1]);
								ref_pix[2] = (uint8)((uint32)(((int)mask_pix[2]-(int)ref_pix[2])
									* mask_pix[3] >> 8) + ref_pix[2]);
								ref_pix[3] = (uint8)((uint32)(((int)mask_pix[3]-(int)ref_pix[3])
									* mask_pix[3] >> 8) + ref_pix[3]);
							}
						}
					}
skip_draw:
					dx -= brush->core.d;
					brush->stamp_distance -= brush->core.d;
					if(dx < brush->core.d)
					{
						break;
					}
					else
					{
						draw_x += diff_x, draw_y += diff_y;
					}
				} while(1);
			}

			brush->finish_length += d;
			brush->travel += d;
			brush->draw_finished++;
			ref_point = brush->draw_finished % BRUSH_POINT_BUFFER_SIZE;
		}	// while(brush->ref_point > brush->draw_finished)

		AddSelectionEditHistory(core, window->selection);

		g_blend_selection_funcs[window->selection->layer_mode](window->work_layer, window->selection);

		(void)memset(window->work_layer->pixels, 0, window->work_layer->stride*window->work_layer->height);

		window->work_layer->layer_mode = LAYER_BLEND_NORMAL;

		brush->core.rotate = brush->core.rotate_start;
	}	// マウスの左ボタンなら
		// if(((GdkEventButton*)state)->button == 1)
}

static void BlendImageBrushDrawCursor(
	DRAW_WINDOW* window,
	FLOAT_T x,
	FLOAT_T y,
	void* data
)
{
	StampCoreDrawCursor(window, x, y, &((BLEND_IMAGE_BRUSH*)data)->core);
}

static void BlendImageBrushButtonUpdate(DRAW_WINDOW* window, FLOAT_T x, FLOAT_T y, BLEND_IMAGE_BRUSH* brush)
{
	FLOAT_T r;

	if(brush->core.half_width > brush->core.half_height)
	{
		r = brush->core.half_width * 2 * window->zoom_rate + 1;
	}
	else
	{
		r = brush->core.half_height * 2 * window->zoom_rate + 1;
	}

	gtk_widget_queue_draw_area(window->window, (gint)(x - r - 1),
		(gint)(y - r - 1), (gint)(r * 2) + 2, (gint)(r * 2) + 2);
}

static void BlendImageBrushMotionUpdate(DRAW_WINDOW* window, FLOAT_T x, FLOAT_T y, BLEND_IMAGE_BRUSH* brush)
{
	FLOAT_T start_x, start_y;
	FLOAT_T width, height;
	FLOAT_T r;
	FLOAT_T enter = (brush->enter_length + brush->draw_start) * window->zoom_rate;

	if(brush->core.half_width > brush->core.half_height)
	{
		r = brush->core.half_width * 2 * window->zoom_rate + 1;
	}
	else
	{
		r = brush->core.half_height * 2 * window->zoom_rate + 1;
	}

	if(window->before_cursor_x < x)
	{
		start_x = window->before_cursor_x - r;
		width = r * 2 + x - window->before_cursor_x;
	}
	else
	{
		start_x = x - r;
		width = r * 2 + window->before_cursor_x - x;
	}

	if(window->before_cursor_y < y)
	{
		start_y = window->before_cursor_y - r;
		height = r * 2 + y - window->before_cursor_y;
	}
	else
	{
		start_y = y - r;
		height = r * 2 + window->before_cursor_y - y;
	}

	start_x -= enter * 4;
	width += enter * 4 * 2 + 2;
	start_y -= enter * 4;
	height += enter * 4 * 2 + 2;

	gtk_widget_queue_draw_area(window->window,
		(gint)start_x, (gint)start_y, (gint)width, (gint)height);
}

static void BlendImageBrushChangeColor(const uint8 color[3], void* data)
{
	BLEND_IMAGE_BRUSH *brush = (BLEND_IMAGE_BRUSH*)data;
	InitializeStampCore(&brush->core, brush->mode, brush->core.app);
}

static void BlendImageBrushSetEnter(GtkAdjustment* slider, BLEND_IMAGE_BRUSH* brush)
{
	brush->enter = gtk_adjustment_get_value(slider);
}

static void BlendImageBrushSetOut(GtkAdjustment* slider, BLEND_IMAGE_BRUSH* brush)
{
	brush->out = gtk_adjustment_get_value(slider);
}

static void BlendImageBrushSetBlendMode(GtkComboBox* combo, BLEND_IMAGE_BRUSH* brush)
{
	brush->blend_mode = (uint16)gtk_combo_box_get_active(combo);
}

static void BlendImageBrushSetRotate2Direction(GtkWidget* button, BLEND_IMAGE_BRUSH* brush)
{
	if(gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(button)) == FALSE)
	{
		brush->core.flags &= ~(BRUSH_FLAG_ROTATE);
	}
	else
	{
		brush->core.flags |= BRUSH_FLAG_ROTATE;
	}
}

static void BlendImageBrushSetRotateDirection(GtkWidget* button, BLEND_IMAGE_BRUSH* brush)
{
	if(gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(button)) != FALSE)
	{
		brush->core.rotate_direction = GPOINTER_TO_INT(g_object_get_data(
			G_OBJECT(button), "rotate_direction"));
	}
}

static void BlendImageBrushSetSizeRange(GtkAdjustment* slider, BLEND_IMAGE_BRUSH* brush)
{
	brush->size_range = gtk_adjustment_get_value(slider) * 0.01;
}

static void BlendImageBrushSetRotateRange(GtkAdjustment* slider, BLEND_IMAGE_BRUSH* brush)
{
	brush->random_rotate_range = (int16)gtk_adjustment_get_value(slider);
	brush->rotate_range = brush->random_rotate_range * G_PI / 180;
}

static void BlendImageBrushSetBlendTarget(GtkWidget* button, BLEND_IMAGE_BRUSH* brush)
{
	int target = GPOINTER_TO_INT(g_object_get_data(G_OBJECT(button), "target"));
	if(gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(button)) != FALSE)
	{
		brush->target = (uint8)target;
	}
}

static GtkWidget* CreateBlendImageBrushDetailUI(APPLICATION* app, BRUSH_CORE* brush_core)
{
#define UI_FONT_SIZE 8.0
#define ICON_SIZE 32
	BLEND_IMAGE_BRUSH *brush = (BLEND_IMAGE_BRUSH*)brush_core->brush_data;
	STAMP_CORE *core = &brush->core;
	GtkWidget *vbox = gtk_vbox_new(FALSE, 0);
	// ラベル、スライダ
	GtkWidget* label, *scale;
	// スクロールドウィンドウ
	GtkWidget* scrolled_window;
	// ウィジェット整列用のテーブル
	GtkWidget* table;
	// 回転方向、モード設定用のラジオボタン
	GtkWidget* radio_buttons[PATTERN_MODE_NUM];
	// 筆圧使用設定のチェックボックス
	GtkWidget* check_button;
	// 合成モード選択用のコンボボックス
	GtkWidget* combo;
	// スライダに使用するアジャスタ
	GtkAdjustment* scale_adjustment;
	// ラベルのフォント変更用のマークアップバッファ
	char mark_up_buff[256];
	int i;	// for文用のカウンタ

	// アプリケーション管理の構造体へのポインタをセット
	core->app = app;

	// クリップボードのパターンを更新
	UpdateClipBoardPattern(&app->stamps);

	// 拡大縮小率設定用のウィジェット
	scale_adjustment = GTK_ADJUSTMENT(gtk_adjustment_new(
		(1 / core->scale) * 100, 10, 300, 0.1, 0.1, 0));
	scale = SpinScaleNew(scale_adjustment,
		app->labels->tool_box.brush_scale, 1);
	(void)g_signal_connect(G_OBJECT(scale_adjustment), "value_changed",
		G_CALLBACK(StampCoreChangeScale), core);
	g_object_set_data(G_OBJECT(scale_adjustment), "application", app);
	gtk_box_pack_start(GTK_BOX(vbox), scale, FALSE, FALSE, 0);

	// 濃度変更用ウィジェット
	scale_adjustment = GTK_ADJUSTMENT(gtk_adjustment_new(
		core->flow * 100, 0, 100, 0.1, 0.1, 0));
	scale = SpinScaleNew(scale_adjustment,
		app->labels->tool_box.flow, 1);
	g_object_set_data(G_OBJECT(scale_adjustment), "application", app);
	g_signal_connect(G_OBJECT(scale_adjustment), "value_changed",
		G_CALLBACK(StampCoreChangeFlow), core);
	table = gtk_table_new(1, 3, TRUE);
	gtk_table_attach_defaults(GTK_TABLE(table), scale, 0, 3, 0, 1);
	gtk_box_pack_start(GTK_BOX(vbox), table, FALSE, TRUE, 0);

	// 開始回転角変更用ウィジェット
	scale_adjustment = GTK_ADJUSTMENT(gtk_adjustment_new(
		fabs(core->rotate_start) * 180 / G_PI, 0, 360, 0.1, 0.1, 0));
	scale = SpinScaleNew(scale_adjustment,
		app->labels->tool_box.rotate_start, 1);
	g_object_set_data(G_OBJECT(scale_adjustment), "application", app);
	(void)g_signal_connect(G_OBJECT(scale_adjustment), "value_changed",
		G_CALLBACK(StampCoreChangeRotateStart), core);
	gtk_box_pack_start(GTK_BOX(vbox), scale, FALSE, FALSE, 0);

	// 間隔変更用ウィジェット
	scale_adjustment = GTK_ADJUSTMENT(gtk_adjustment_new(
		core->stamp_distance, 0.1, 3, 0.1, 0.1, 0));
	scale = SpinScaleNew(scale_adjustment,
		app->labels->tool_box.distance, 1);
	(void)g_signal_connect(G_OBJECT(scale_adjustment), "value_changed",
		G_CALLBACK(StampCoreChangeDistance), core);
	g_object_set_data(G_OBJECT(scale_adjustment), "application", app);
	gtk_box_pack_start(GTK_BOX(vbox), scale, FALSE, FALSE, 0);

	core->mode = &brush->mode;
	core->mode_select[0] = radio_buttons[0] =
		gtk_radio_button_new_with_label(NULL, app->labels->tool_box.saturation);
	core->mode_select[1] = radio_buttons[1] = gtk_radio_button_new_with_label(
		gtk_radio_button_get_group(GTK_RADIO_BUTTON(radio_buttons[0])),
		app->labels->tool_box.brightness
	);
	core->mode_select[2] = radio_buttons[2] = gtk_radio_button_new_with_label(
		gtk_radio_button_get_group(GTK_RADIO_BUTTON(radio_buttons[0])),
		app->labels->tool_box.gradation_reverse
	);
	gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(radio_buttons[brush->mode]), TRUE);
	g_object_set_data(G_OBJECT(radio_buttons[0]), "mode", GINT_TO_POINTER(0));
	g_object_set_data(G_OBJECT(radio_buttons[0]), "application", app);
	g_object_set_data(G_OBJECT(radio_buttons[0]), "stamp_core", core);
	(void)g_signal_connect(G_OBJECT(radio_buttons[0]), "toggled", G_CALLBACK(StampCoreSetMode), &brush->mode);
	g_object_set_data(G_OBJECT(radio_buttons[1]), "mode", GINT_TO_POINTER(1));
	g_object_set_data(G_OBJECT(radio_buttons[1]), "application", app);
	g_object_set_data(G_OBJECT(radio_buttons[1]), "stamp_core", core);
	(void)g_signal_connect(G_OBJECT(radio_buttons[1]), "toggled", G_CALLBACK(StampCoreSetMode), &brush->mode);
	g_object_set_data(G_OBJECT(radio_buttons[2]), "mode", GINT_TO_POINTER(2));
	g_object_set_data(G_OBJECT(radio_buttons[2]), "application", app);
	g_object_set_data(G_OBJECT(radio_buttons[2]), "stamp_core", core);
	(void)g_signal_connect(G_OBJECT(radio_buttons[2]), "toggled", G_CALLBACK(StampCoreSetMode), &brush->mode);
	table = gtk_hbox_new(FALSE, 0);
	gtk_box_pack_start(GTK_BOX(table), radio_buttons[0], FALSE, TRUE, 0);
	gtk_box_pack_start(GTK_BOX(table), radio_buttons[1], FALSE, TRUE, 0);
	gtk_box_pack_start(GTK_BOX(vbox), table, FALSE, TRUE, 0);
	gtk_box_pack_start(GTK_BOX(vbox), radio_buttons[2], FALSE, TRUE, 0);

	// 左右反転、上下反転選択用チェックボックス
	table = gtk_hbox_new(FALSE, 0);
	label = gtk_label_new("");
	(void)sprintf(mark_up_buff, "<span font_desc=\"%.2f\">%s : </span>",
		UI_FONT_SIZE * app->gui_scale, app->labels->tool_box.reverse);
	gtk_label_set_markup(GTK_LABEL(label), mark_up_buff);
	gtk_box_pack_start(GTK_BOX(table), label, FALSE, FALSE, 0);
	check_button = gtk_check_button_new_with_label(app->labels->tool_box.reverse_horizontally);
	g_object_set_data(G_OBJECT(check_button), "flag-id", GINT_TO_POINTER(0));
	g_object_set_data(G_OBJECT(check_button), "application", app);
	gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(check_button),
		core->pattern_flags & PATTERN_FLIP_HORIZONTALLY);
	(void)g_signal_connect(G_OBJECT(check_button), "toggled", G_CALLBACK(StampCoreSetPatternFlags), core);
	gtk_box_pack_start(GTK_BOX(table), check_button, FALSE, TRUE, 0);
	check_button = gtk_check_button_new_with_label(app->labels->tool_box.reverse_vertically);
	g_object_set_data(G_OBJECT(check_button), "flag-id", GINT_TO_POINTER(1));
	g_object_set_data(G_OBJECT(check_button), "application", app);
	gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(check_button),
		core->pattern_flags & PATTERN_FLIP_VERTICALLY);
	(void)g_signal_connect(G_OBJECT(check_button), "toggled", G_CALLBACK(StampCoreSetPatternFlags), core);
	gtk_box_pack_start(GTK_BOX(table), check_button, FALSE, TRUE, 0);
	gtk_box_pack_start(GTK_BOX(vbox), table, FALSE, TRUE, 0);

	// 回転方向変更用ウィジェット
	radio_buttons[0] = gtk_radio_button_new_with_label(NULL, app->labels->tool_box.clockwise);
	radio_buttons[1] = gtk_radio_button_new_with_label(
		gtk_radio_button_get_group(GTK_RADIO_BUTTON(radio_buttons[0])),
		app->labels->tool_box.counter_clockwise
	);

	if(core->rotate_direction < 0)
	{
		gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(radio_buttons[0]), TRUE);
	}
	else
	{
		gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(radio_buttons[1]), TRUE);
	}

	table = gtk_hbox_new(FALSE, 0);
	g_object_set_data(G_OBJECT(radio_buttons[0]), "rotate_direction", GINT_TO_POINTER(1));
	g_object_set_data(G_OBJECT(radio_buttons[1]), "rotate_direction", GINT_TO_POINTER(-1));
	(void)g_signal_connect(G_OBJECT(radio_buttons[0]), "toggled",
		G_CALLBACK(BlendImageBrushSetRotateDirection), brush);
	(void)g_signal_connect(G_OBJECT(radio_buttons[1]), "toggled",
		G_CALLBACK(BlendImageBrushSetRotateDirection), brush);
	gtk_box_pack_start(GTK_BOX(table), radio_buttons[0], FALSE, TRUE, 0);
	gtk_box_pack_start(GTK_BOX(table), radio_buttons[1], FALSE, TRUE, 0);
	gtk_box_pack_start(GTK_BOX(vbox), table, FALSE, TRUE, 0);
	// 詳細設定のUIが閉じられるときにボタン配列を開放する
	(void)g_signal_connect(G_OBJECT(vbox), "destroy", G_CALLBACK(OnStampDetailUIDestroy), core);

	// スタンプ選択テーブルを作成してスクロールドウィンドウに入れる
	table = gtk_hbox_new(FALSE, 0);
	scrolled_window = gtk_scrolled_window_new(NULL, NULL);
	gtk_widget_set_size_request(table,
		ICON_SIZE*STAMP_SELECT_TABLE_WIDTH+4, ICON_SIZE*4+4);
	gtk_scrolled_window_add_with_viewport(GTK_SCROLLED_WINDOW(scrolled_window),
		CreateStampSelectTable(core));
	gtk_scrolled_window_set_policy(GTK_SCROLLED_WINDOW(scrolled_window),
		GTK_POLICY_NEVER, GTK_POLICY_AUTOMATIC);
	gtk_box_pack_start(GTK_BOX(table), scrolled_window, FALSE, FALSE, 0);
	gtk_box_pack_start(GTK_BOX(vbox), table, FALSE, TRUE, 0);

	// クリップボードのスタンプがアクティブならばセット
	if(app->stamps.has_clip_board_pattern != FALSE)
	{
		if(core->stamp_id == 0)
		{
			app->stamps.active_pattern =
				&app->stamps.clip_board;
		}
		else
		{
			app->stamps.active_pattern =
				&app->stamps.patterns[core->stamp_id-1];
		}
	}

	// アクティブなパターンがチャンネル数2以外ならば着色モードは無効
	gtk_widget_set_sensitive(core->mode_select[0], app->stamps.active_pattern->channel == 2);
	gtk_widget_set_sensitive(core->mode_select[1], app->stamps.active_pattern->channel == 2);
	gtk_widget_set_sensitive(core->mode_select[2], app->stamps.active_pattern->channel == 2);

	InitializeStampCore(core, (int)brush->mode, app);

	table = gtk_hbox_new(FALSE, 0);
	label = gtk_label_new("");
#if GTK_MAJOR_VERSION <= 2
	combo = gtk_combo_box_new_text();
#else
	combo = gtk_combo_box_text_new();
#endif
	(void)sprintf(mark_up_buff, "<span font_desc=\"%.2f\">%s : </span>",
		UI_FONT_SIZE * app->gui_scale, app->labels->layer_window.blend_mode);
	gtk_label_set_markup(GTK_LABEL(label), mark_up_buff);
	gtk_box_pack_start(GTK_BOX(table), label, FALSE, FALSE, 0);
	for(i=0; i<LAYER_BLEND_SLELECTABLE_NUM; i++)
	{
#if GTK_MAJOR_VERSION <= 2
		gtk_combo_box_append_text(GTK_COMBO_BOX(combo), app->labels->layer_window.blend_modes[i]);
#else
		gtk_combo_box_text_append_text(GTK_COMBO_BOX_TEXT(combo), app->labels->layer_window.blend_modes[i]);
#endif
	}
	gtk_combo_box_set_active(GTK_COMBO_BOX(combo), brush->blend_mode);
	(void)g_signal_connect(G_OBJECT(combo), "changed",
		G_CALLBACK(BlendImageBrushSetBlendMode), brush);
	gtk_box_pack_start(GTK_BOX(table), combo, FALSE, TRUE, 0);
	gtk_box_pack_start(GTK_BOX(vbox), table, FALSE, TRUE, 0);

	scale_adjustment = GTK_ADJUSTMENT(gtk_adjustment_new(brush->enter, 0, 100, 1, 1, 0));
	scale = SpinScaleNew(scale_adjustment,
		app->labels->tool_box.enter, 1);
	(void)g_signal_connect(G_OBJECT(scale_adjustment), "value_changed",
		G_CALLBACK(BlendImageBrushSetEnter), core);
	gtk_box_pack_start(GTK_BOX(vbox), scale, FALSE, FALSE, 0);

	scale_adjustment = GTK_ADJUSTMENT(gtk_adjustment_new(brush->out, 0, 100, 1, 1, 0));
	scale = SpinScaleNew(scale_adjustment,
		app->labels->tool_box.out, 1);
	(void)g_signal_connect(G_OBJECT(scale_adjustment), "value_changed",
		G_CALLBACK(BlendImageBrushSetOut), core);
	gtk_box_pack_start(GTK_BOX(vbox), scale, FALSE, FALSE, 0);

	label = gtk_label_new("");
	(void)sprintf(mark_up_buff, "<span font_desc=\"%.2f\">%s : </span>",
		UI_FONT_SIZE * app->gui_scale, app->labels->tool_box.select.target);
	gtk_label_set_markup(GTK_LABEL(label), mark_up_buff);
	table = gtk_hbox_new(FALSE, 0);
	gtk_box_pack_start(GTK_BOX(table), label, FALSE, FALSE, 0);
	gtk_box_pack_start(GTK_BOX(vbox), table, FALSE, FALSE, 0);
	radio_buttons[0] = gtk_radio_button_new_with_label(NULL, app->labels->tool_box.select.under_layer);
	g_object_set_data(G_OBJECT(radio_buttons[0]), "target", GINT_TO_POINTER(BLEND_BRUSH_TARGET_UNDER_LAYER));
	(void)g_signal_connect(G_OBJECT(radio_buttons[0]), "toggled", G_CALLBACK(BlendImageBrushSetBlendTarget), brush);
	radio_buttons[1] = gtk_radio_button_new_with_label(gtk_radio_button_get_group(
		GTK_RADIO_BUTTON(radio_buttons[0])), app->labels->tool_box.select.canvas);
	g_object_set_data(G_OBJECT(radio_buttons[1]), "target", GINT_TO_POINTER(BLEND_BRUSH_TARGET_CANVAS));
	(void)g_signal_connect(G_OBJECT(radio_buttons[1]), "toggled", G_CALLBACK(BlendImageBrushSetBlendTarget), brush);
	gtk_box_pack_start(GTK_BOX(vbox), radio_buttons[0], FALSE, FALSE, 0);
	gtk_box_pack_start(GTK_BOX(vbox), radio_buttons[1], FALSE, FALSE, 0);
	gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(radio_buttons[brush->target]), TRUE);

	// 筆圧使用設定変更用ウィジェット
	table = gtk_hbox_new(FALSE, 0);
	label = gtk_label_new("");
	(void)sprintf(mark_up_buff, "<span font_desc=\"%.2f\">%s : </span>",
		UI_FONT_SIZE * app->gui_scale, app->labels->tool_box.pressure);
	gtk_label_set_markup(GTK_LABEL(label), mark_up_buff);
	gtk_box_pack_start(GTK_BOX(table), label, FALSE, FALSE, 0);
	check_button = gtk_check_button_new_with_label(app->labels->tool_box.scale);
	g_object_set_data(G_OBJECT(check_button), "flag-id", GINT_TO_POINTER(0));
	gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(check_button), core->flags & BRUSH_FLAG_SIZE);
	(void)g_signal_connect(G_OBJECT(check_button), "toggled", G_CALLBACK(StampCoreSetFlags), core);
	gtk_box_pack_start(GTK_BOX(table), check_button, FALSE, TRUE, 0);
	check_button = gtk_check_button_new_with_label(app->labels->tool_box.flow);
	g_object_set_data(G_OBJECT(check_button), "flag-id", GINT_TO_POINTER(1));
	gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(check_button), core->flags & BRUSH_FLAG_FLOW);
	(void)g_signal_connect(G_OBJECT(check_button), "toggled", G_CALLBACK(StampCoreSetFlags), core);
	gtk_box_pack_start(GTK_BOX(table), check_button, FALSE, TRUE, 0);
	gtk_box_pack_start(GTK_BOX(vbox), table, FALSE, FALSE, 0);
	check_button = gtk_check_button_new_with_label(app->labels->tool_box.random_size);
	g_object_set_data(G_OBJECT(check_button), "flag-value", GUINT_TO_POINTER(STAMP_RANDOM_SIZE));
	g_object_set_data(G_OBJECT(check_button), "application", app);
	gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(check_button), core->flags & STAMP_RANDOM_SIZE);
	(void)g_signal_connect(G_OBJECT(check_button), "toggled", G_CALLBACK(StampCoreSetFlag), core);
	gtk_box_pack_start(GTK_BOX(vbox), check_button, FALSE, TRUE, 0);

	// ブラシの移動方向へ回転
	check_button = gtk_check_button_new_with_label(app->labels->tool_box.rotate_to_brush_direction);
	gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(check_button),
		brush->core.flags & BRUSH_FLAG_ROTATE);
	(void)g_signal_connect(G_OBJECT(check_button), "toggled",
		G_CALLBACK(BlendImageBrushSetRotate2Direction), brush);
	gtk_box_pack_start(GTK_BOX(vbox), check_button, FALSE, FALSE, 0);

	// ランダムに回転
	check_button = gtk_check_button_new_with_label(app->labels->tool_box.random_rotate);
	gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(check_button), (core->flags & STAMP_RANDOM_ROTATE) != 0);
	g_object_set_data(G_OBJECT(check_button), "flag-value", GUINT_TO_POINTER(STAMP_RANDOM_ROTATE));
	g_object_set_data(G_OBJECT(check_button), "application", app);
	(void)g_signal_connect(G_OBJECT(check_button), "toggled", G_CALLBACK(StampCoreSetFlag), core);
	gtk_box_pack_start(GTK_BOX(vbox), check_button, FALSE, TRUE, 0);

	// ランダムサイズの変化幅
	scale_adjustment = GTK_ADJUSTMENT(gtk_adjustment_new(brush->size_range * 100, 0, 100, 1, 1, 0));
	scale = SpinScaleNew(scale_adjustment, app->labels->tool_box.size_range, 1);
	(void)g_signal_connect(G_OBJECT(scale_adjustment), "value_changed",
		G_CALLBACK(BlendImageBrushSetSizeRange), brush);
	gtk_box_pack_start(GTK_BOX(vbox), scale, FALSE, FALSE, 0);

	// ランダム回転の変化幅
	brush->rotate_range = brush->random_rotate_range * G_PI / 180;
	scale_adjustment = GTK_ADJUSTMENT(gtk_adjustment_new(brush->random_rotate_range, 0, 360, 1, 1, 0));
	scale = SpinScaleNew(scale_adjustment, app->labels->tool_box.rotate_range, 0);
	(void)g_signal_connect(G_OBJECT(scale_adjustment), "value_changed",
		G_CALLBACK(BlendImageBrushSetRotateRange), brush);
	gtk_box_pack_start(GTK_BOX(vbox), scale, FALSE, FALSE, 0);

#undef UI_FONT_SIZE
#undef ICON_SIZE

	return vbox;
}

static void PickerBrushButtonPressCallBack(
	DRAW_WINDOW* window,
	FLOAT_T x,
	FLOAT_T y,
	FLOAT_T pressure,
	BRUSH_CORE *core,
	void* state
)
{
	// 左クリックなら
	if(((GdkEventButton*)state)->button == 1)
	{
		// ブラシの詳細情報にキャスト
		PICKER_BRUSH *brush = (PICKER_BRUSH*)core->brush_data;
		// ブラシの背景と不透明度
		FLOAT_T r, alpha;
		// 更新範囲のイメージ情報
		cairo_surface_t *update_surface;
		cairo_t *update;
		// ブラシの拡大縮小率
		FLOAT_T zoom;
		// 座標の最大・最小値
		FLOAT_T min_x, max_x, min_y, max_y;
		// ピクセルデータを更新する座標
		int start_x, start_y;
		// 描画する幅、高さ、一行分のバイト数
		int width, height;
		// 描画座標指定・拡大縮小用
		cairo_matrix_t matrix;
		// 参照ピクセル
		uint8 *mask;
		// 描画色
		uint8 color[4];
		// ブラシの位置のピクセル値合計
		unsigned int sum_color0 = 0, sum_color1 = 0, sum_color2 = 0,
			sum_color3 = 1, sum_color4 = 0, sum_color5 = 1;
		// 作業レイヤーの幅
		int layer_width = window->work_layer->width;
		// 色を抽出するレイヤー
		LAYER *target;
		// 描画時にマスクするサーフェース
		cairo_surface_t *mask_surface;
		int i;	// for文用のカウンタ

		// 合成モードを設定
		window->work_layer->layer_mode = brush->blend_mode;
		// 一部更新モードへ
		window->flags |= DRAW_WINDOW_UPDATE_PART;

		// 座標を記憶
		brush->before_x = x, brush->before_y = y;

		// 画面外クリックなら終了
		if(x < 0 || x >= window->width || y < 0 || y >= window->height)
		{
			return;
		}

		// 筆圧でのサイズ変更の有無
		if((brush->flags & PICKER_FLAG_PRESSURE_SIZE) == 0)
		{
			r = brush->r;
			zoom = 1;
		}
		else
		{
			r = brush->r * pressure;
			zoom = 1 / pressure;
		}

		// 筆圧での濃度変更の有無
		if((brush->flags & PICKER_FLAG_PRESSURE_FLOW) == 0)
		{
			alpha = brush->alpha;
		}
		else
		{
			alpha = brush->alpha * pressure;
		}

		// マウスの座標とブラシの半径から
			// 描画する座標の最大・最小値を決定
		min_x = x - r, min_y = y - r;
		max_x = x + r + 1, max_y = y + r + 1;

		update_surface = cairo_surface_create_for_rectangle(
			window->alpha_surface, min_x, min_y, r*2+1, r*2+1);
		update = cairo_create(update_surface);

		if(min_x < 0.0)
		{
			min_x = 0.0;
		}
		if(min_y < 0.0)
		{
			min_y = 0.0;
		}
		if(max_x > window->work_layer->width)
		{
			max_x = window->work_layer->width;
		}
		if(max_y > window->work_layer->height)
		{
			max_y = window->work_layer->height;
		}

		window->update.x = (int)min_x, window->update.y = (int)min_y;
		window->update.width = (int)max_x - window->update.x;
		window->update.height = (int)max_y - window->update.y;

		window->flags |= DRAW_WINDOW_UPDATE_PART;

		core->min_x = min_x, core->min_y = min_y;
		core->max_x = max_x, core->max_y = max_y;

		min_x = x - r, max_x = x + r;
		min_y = y - r, max_y = y + r;

		mask = window->mask->pixels;
		(void)memset(window->mask->pixels, 0, window->width * window->height);
		mask_surface = window->alpha_surface;

		if(window->app->textures.active_texture == 0)
		{
			if((window->flags & DRAW_WINDOW_HAS_SELECTION_AREA) == 0)
			{
				if((window->active_layer->flags & LAYER_LOCK_OPACITY) == 0)
				{
					cairo_matrix_init_scale(&matrix, zoom, zoom);
					cairo_pattern_set_matrix(core->brush_pattern, &matrix);
					cairo_set_source(update, core->brush_pattern);
					cairo_paint_with_alpha(update, alpha);
				}
				else
				{
					cairo_matrix_init_scale(&matrix, zoom, zoom);
					cairo_pattern_set_matrix(core->brush_pattern, &matrix);
					cairo_set_source(core->temp_cairo, core->brush_pattern);
					cairo_paint_with_alpha(core->temp_cairo, alpha);
					cairo_matrix_init_translate(&matrix, 0, 0);
					cairo_pattern_set_matrix(core->temp_pattern, &matrix);
					cairo_set_source(update, core->temp_pattern);
					cairo_mask_surface(update,
						window->active_layer->surface_p, - x + r, - y + r);
				}
			}
			else
			{
				if((window->active_layer->flags & LAYER_LOCK_OPACITY) == 0)
				{
					cairo_matrix_init_scale(&matrix, zoom, zoom);
					cairo_pattern_set_matrix(core->brush_pattern, &matrix);
					cairo_set_source(core->temp_cairo, core->brush_pattern);
					cairo_paint_with_alpha(core->temp_cairo, alpha);
					cairo_matrix_init_translate(&matrix, 0, 0);
					cairo_pattern_set_matrix(core->temp_pattern, &matrix);
					cairo_set_source(update, core->temp_pattern);
					cairo_mask_surface(update,
						window->selection->surface_p, - x + r, - y + r);
				}
				else
				{
					cairo_surface_t *temp_surface = cairo_surface_create_for_rectangle(
						window->alpha_temp, x - r, y - r, r*2+1, r*2+1);
					cairo_t *update_temp = cairo_create(temp_surface);

					cairo_matrix_init_scale(&matrix, zoom, zoom);
					cairo_pattern_set_matrix(core->brush_pattern, &matrix);
					cairo_set_source(core->temp_cairo, core->brush_pattern);
					cairo_paint_with_alpha(core->temp_cairo, alpha);
					cairo_matrix_init_translate(&matrix, 0, 0);
					cairo_pattern_set_matrix(core->temp_pattern, &matrix);
					cairo_set_source(update, core->temp_pattern);

					(void)memset(window->temp_layer->pixels, 0,
						window->width*window->height);

					cairo_mask_surface(update,
						window->selection->surface_p, 0, 0);
					cairo_set_source_surface(update_temp,
						update_surface, 0, 0);
					cairo_mask_surface(update_temp,
						window->active_layer->surface_p, - x + r, - y + r);

					mask = window->temp_layer->pixels;
					mask_surface = window->temp_layer->surface_p;

					cairo_surface_destroy(temp_surface);
					cairo_destroy(update_temp);
				}
			}
		}
		else
		{
			cairo_surface_t *temp_surface = cairo_surface_create_for_rectangle(
				window->alpha_temp, x - r, y - r, r*2+1, r*2+1);
			cairo_t *update_temp = cairo_create(temp_surface);

			if((window->flags & DRAW_WINDOW_HAS_SELECTION_AREA) == 0)
			{
				if((window->active_layer->flags & LAYER_LOCK_OPACITY) == 0)
				{
					cairo_matrix_init_scale(&matrix, zoom, zoom);
					cairo_pattern_set_matrix(core->brush_pattern, &matrix);
					cairo_set_source(update, core->brush_pattern);
					cairo_paint_with_alpha(update, alpha);
				}
				else
				{
					cairo_matrix_init_scale(&matrix, zoom, zoom);
					cairo_pattern_set_matrix(core->brush_pattern, &matrix);
					cairo_set_source(core->temp_cairo, core->brush_pattern);
					cairo_paint_with_alpha(core->temp_cairo, alpha);
					cairo_matrix_init_translate(&matrix, 0, 0);
					cairo_pattern_set_matrix(core->temp_pattern, &matrix);
					cairo_set_source(update, core->temp_pattern);
					cairo_mask_surface(update,
						window->active_layer->surface_p, - x + r, - y + r);
				}

				cairo_set_source_surface(update_temp, update_surface, 0, 0);
				cairo_mask_surface(update_temp, window->texture->surface_p, - x + r, - y + r);

				mask = window->temp_layer->pixels;
				mask_surface = window->temp_layer->surface_p;
			}
			else
			{
				if((window->active_layer->flags & LAYER_LOCK_OPACITY) == 0)
				{
					cairo_matrix_init_scale(&matrix, zoom, zoom);
					cairo_pattern_set_matrix(core->brush_pattern, &matrix);
					cairo_set_source(core->temp_cairo, core->brush_pattern);
					cairo_paint_with_alpha(core->temp_cairo, alpha);
					cairo_matrix_init_translate(&matrix, 0, 0);
					cairo_pattern_set_matrix(core->temp_pattern, &matrix);
					cairo_set_source(update, core->temp_pattern);
					cairo_mask_surface(update,
						window->selection->surface_p, - x + r, - y + r);

					cairo_set_source_surface(update_temp, update_surface, 0, 0);
					cairo_mask_surface(update_temp, window->texture->surface_p, - x + r, - y + r);

					mask = window->temp_layer->pixels;
					mask_surface = window->temp_layer->surface_p;
				}
				else
				{
					cairo_matrix_init_scale(&matrix, zoom, zoom);
					cairo_pattern_set_matrix(core->brush_pattern, &matrix);
					cairo_set_source(core->temp_cairo, core->brush_pattern);
					cairo_paint_with_alpha(core->temp_cairo, alpha);
					cairo_matrix_init_translate(&matrix, 0, 0);
					cairo_pattern_set_matrix(core->temp_pattern, &matrix);
					cairo_set_source(update, core->temp_pattern);

					(void)memset(window->temp_layer->pixels, 0,
						window->width*window->height);

					cairo_mask_surface(update,
						window->selection->surface_p, 0, 0);
					cairo_set_source_surface(update_temp,
						update_surface, 0, 0);
					cairo_mask_surface(update_temp,
						window->active_layer->surface_p, - x + r, - y + r);

					cairo_set_operator(update, CAIRO_OPERATOR_SOURCE);
					cairo_set_source_surface(update, temp_surface, 0, 0);
					cairo_mask_surface(update, window->texture->surface_p, - x + r, - y + r);
				}
			}

			cairo_surface_destroy(temp_surface);
			cairo_destroy(update_temp);
		}

		start_x = (int)min_x, start_y = (int)min_y;
		width = (int)(max_x - min_x);
		height = (int)(max_y - min_y);

		if(brush->picker_source == COLOR_PICKER_SOURCE_ACTIVE_LAYER)
		{
			(void)memcpy(window->mask_temp->pixels, window->active_layer->pixels,
				window->pixel_buf_size);
			target = window->mask_temp;
			window->layer_blend_functions[brush->blend_mode](window->work_layer, target);
		}
		else
		{
			target = window->mixed_layer;
		}

		if(brush->picker_mode == PICKER_MODE_SINGLE_PIXEL)
		{
			int int_x = (int)x, int_y = (int)y;
			color[0] = target->pixels[target->stride*int_y+int_x*4];
			color[1] = target->pixels[target->stride*int_y+int_x*4+1];
			color[2] = target->pixels[target->stride*int_y+int_x*4+2];
			color[3] = target->pixels[target->stride*int_y+int_x*4+3];
		}
		else
		{
#ifdef _OPENMP
#pragma omp parallel for reduction( +: sum_color0, sum_color1, sum_color2, sum_color3, sum_color4, sum_color5) firstprivate(width, layer_width, start_x, start_y)
#endif
			for(i=0; i<height; i++)
			{
				uint8 *ref_pix = &target->pixels[(i+start_y)*target->stride+start_x*4];
				uint8 *mask_pix = &mask[(i+start_y)*layer_width+start_x];
				int j;

				for(j=0; j<width; j++, ref_pix+=4, mask_pix++)
				{
					sum_color0 += ((ref_pix[0]+1) * *mask_pix * ref_pix[3]) >> 8;
					sum_color1 += ((ref_pix[1]+1) * *mask_pix * ref_pix[3]) >> 8;
					sum_color2 += ((ref_pix[2]+1) * *mask_pix * ref_pix[3]) >> 8;
					sum_color3 += ((ref_pix[3]+1) * *mask_pix) >> 8;
					sum_color4 += ref_pix[3] * *mask_pix;
					sum_color5 += *mask_pix;
				}
			}

			color[0] = (uint8)((sum_color0 + sum_color3 / 2) / sum_color3);
			color[1] = (uint8)((sum_color1 + sum_color3 / 2) / sum_color3);
			color[2] = (uint8)((sum_color2 + sum_color3 / 2) / sum_color3);
			color[3] = (uint8)(sum_color4 / sum_color5);
		}

		// 色調整
		if((brush->flags & PICKER_FLAG_CHANGE_HSV) != 0)
		{
			HSV hsv;
			int s, v;
#if defined(USE_BGR_COLOR_SPACE) && USE_BGR_COLOR_SPACE != 0
			uint8 r;
			r = color[2];
			color[2] = color[0];
			color[0] = r;
#endif
			RGB2HSV_Pixel(color, &hsv);
			hsv.h += brush->add_h;
			s = hsv.s, v = hsv.v;
			if(hsv.h < 0)
			{
				hsv.h += 360;
			}
			else if(hsv.h >= 360)
			{
				hsv.h -= 360;
			}
			s += brush->add_s;
			if(s < 0)
			{
				s = 0;
			}
			else if(s > 255)
			{
				s = 255;
			}
			hsv.s = (uint8)s;

			v += brush->add_v;
			if(v < 0)
			{
				v = 0;
			}
			else if(v > 255)
			{
				v = 255;
			}
			hsv.v = (uint8)v;
			HSV2RGB_Pixel(&hsv, color);
#if defined(USE_BGR_COLOR_SPACE) && USE_BGR_COLOR_SPACE != 0
			r = color[2];
			color[2] = color[0];
			color[0] = r;
#endif
		}

		cairo_destroy(update);
		cairo_surface_destroy(update_surface);

		update_surface = cairo_surface_create_for_rectangle(
			window->work_layer->surface_p, min_x, min_y, r*2+1, r*2+1);
		update = cairo_create(update_surface);

		// 抽出した色で描画
#if defined(USE_BGR_COLOR_SPACE) && USE_BGR_COLOR_SPACE != 0
		cairo_set_source_rgba(update,
			color[2]*DIV_PIXEL, color[1]*DIV_PIXEL, color[1]*DIV_PIXEL, color[3]*DIV_PIXEL);
#else
		cairo_set_source_rgba(update,
			color[0]*DIV_PIXEL, color[1]*DIV_PIXEL, color[2]*DIV_PIXEL, color[3]*DIV_PIXEL);
#endif
		cairo_mask_surface(update, mask_surface, - x + r, - y + r);

		cairo_destroy(update);
		cairo_surface_destroy(update_surface);
	}
}

static void PickerBrushMotionCallBack(
	DRAW_WINDOW* window,
	FLOAT_T x,
	FLOAT_T y,
	FLOAT_T pressure,
	BRUSH_CORE *core,
	void* state
)
{
	if(((*(GdkModifierType*)state) & GDK_BUTTON1_MASK) != 0)
	{
		PICKER_BRUSH* brush = (PICKER_BRUSH*)core->brush_data;
		// ブラシの背景と不透明度
		FLOAT_T r, alpha;
		// 更新範囲のイメージ情報
		cairo_surface_t *update_surface;
		cairo_t *update, *update_temp;
		// 描画する座標
		FLOAT_T draw_x = brush->before_x, draw_y = brush->before_y;
		// 前回の描画からの移動距離
		FLOAT_T d;
		// 描画時の移動量
		FLOAT_T dx, dy;
		// 前回描画時からの移動量
		FLOAT_T diff_x, diff_y, step;
		// ブラシの拡大縮小率
		FLOAT_T zoom;
		// 座標の最大・最小値
		FLOAT_T min_x, max_x, min_y, max_y;
		// ピクセルデータを更新する座標
		int start_x, start_y;
		// 描画する幅、高さ、一行分のバイト数
		int width, height;
		// 作業レイヤーの幅
		int layer_width = window->work_layer->width;
		// 作業レイヤーの一行分のバイト数
		int layer_stride = window->work_layer->stride;
		// 作業レイヤーのピクセル
		uint8 *work_pixel = window->work_layer->pixels;
		// 描画座標指定・拡大縮小用
		cairo_matrix_t matrix;
		// 参照ピクセル
		uint8 *mask;
		// 描画色
		uint8 color[4];
		// ブラシの位置のピクセル値合計
		unsigned int sum_color0, sum_color1, sum_color2,
			sum_color3, sum_color4, sum_color5;
		// 色を抽出するレイヤー
		LAYER *target;
		// 描画時にマスクするサーフェース
		cairo_surface_t *mask_surface, *temp_surface;
		int i;	// for文用のカウンタ

		if(x < 0 || y < 0 || x >= window->width || y >= window->height)
		{
			return;
		}

		if((brush->flags & PICKER_FLAG_PRESSURE_SIZE) == 0)
		{
			r = brush->r;
			zoom = 1;
		}
		else
		{
			r = brush->r * pressure;
			zoom = 1 / pressure;
		}

		step = r * BRUSH_STEP;
		if(step < MIN_BRUSH_STEP)
		{
			dx = 0;
			goto skip_draw;
		}
		alpha = ((brush->flags & PICKER_FLAG_PRESSURE_FLOW) == 0) ?
			1 : pressure;
		dx = x-brush->before_x, dy = y-brush->before_y;
		d = sqrt(dx*dx+dy*dy);
		diff_x = step * dx / d, diff_y = step * dy / d;

		min_x = x - r*2, min_y = y - r*2;
		max_x = x + r*2, max_y = y + r*2;

		if(min_x < 0.0)
		{
			min_x = 0.0;
		}
		if(min_y < 0.0)
		{
			min_y = 0.0;
		}
		if(max_x > window->work_layer->width)
		{
			max_x = window->work_layer->width;
		}
		if(max_y > window->work_layer->height)
		{
			max_y = window->work_layer->height;
		}

		if(window->update.x > min_x)
		{
			window->update.width += window->update.x - (int)min_x;
			window->update.x = (int)min_x;
		}
		if(window->update.width + window->update.x < max_x)
		{
			window->update.width += (int)max_x - window->update.width + window->update.x;
		}
		if(window->update.y > min_y)
		{
			window->update.height += window->update.y - (int)min_y;
			window->update.y = (int)min_y;
		}
		if(window->update.height + window->update.y < max_y)
		{
			window->update.height += (int)max_y - window->update.height + window->update.y;
		}

		if(core->min_x > min_x)
		{
			core->min_x = min_x;
		}
		if(core->min_y > min_y)
		{
			core->min_y = min_y;
		}
		if(core->max_x < max_x)
		{
			core->max_x = max_x;
		}
		if(core->max_y < max_y)
		{
			core->max_y = max_y;
		}

		cairo_set_operator(window->work_layer->cairo_p, CAIRO_OPERATOR_OVER);
		dx = d;
		while(1)
		{
			if(draw_x < 0 || draw_x >= window->width
				|| draw_y < 0 || draw_y >= window->height)
			{
				dx = 0;
				goto skip_draw;
			}

			update_surface = cairo_surface_create_for_rectangle(
				window->alpha_surface, draw_x - r, draw_y - r, r*2+1, r*2+1);
			update = cairo_create(update_surface);
			start_x = (int32)(draw_x - r - 1);
			width = (int32)(draw_x + r + 1);
			start_y = (int32)(draw_y - r - 1);
			height = (int32)(draw_y + r + 1);

			if(start_x < 0)
			{
				start_x = 0;
			}
			else if(width > window->width)
			{
				width = window->width;
			}
			if(start_y < 0)
			{
				start_y = 0;
			}
			if(height > window->height)
			{
				height = window->height;
			}
			width = width - start_x;
			height = height - start_y;

			if(width <= 0 || height <= 0)
			{
				dx = 0;
				goto skip_draw;
			}

			for(i=0; i<height; i++)
			{
				(void)memset(&window->temp_layer->pixels[(i+start_y)*window->work_layer->stride+start_x*window->work_layer->channel],
					0x0, width*window->work_layer->channel);
			}

			mask = window->mask->pixels;
			(void)memset(window->mask->pixels, 0, window->width * window->height);
			mask_surface = window->alpha_surface;

			if(window->app->textures.active_texture == 0)
			{
				if((window->flags & DRAW_WINDOW_HAS_SELECTION_AREA) == 0)
				{
					if((window->active_layer->flags & LAYER_LOCK_OPACITY) == 0)
					{
						cairo_matrix_init_scale(&matrix, zoom, zoom);
						cairo_pattern_set_matrix(core->brush_pattern, &matrix);
						cairo_set_source(update, core->brush_pattern);
						cairo_paint_with_alpha(update, alpha);
					}
					else
					{
						cairo_matrix_init_scale(&matrix, zoom, zoom);
						cairo_pattern_set_matrix(core->brush_pattern, &matrix);
						cairo_set_source(core->temp_cairo, core->brush_pattern);
						cairo_paint_with_alpha(core->temp_cairo, alpha);
						cairo_matrix_init_translate(&matrix, 0, 0);
						cairo_pattern_set_matrix(core->temp_pattern, &matrix);
						cairo_set_source(update, core->temp_pattern);
						cairo_mask_surface(update,
							window->active_layer->surface_p, - draw_x + r, - draw_y + r);
					}
				}
				else
				{
					if((window->active_layer->flags & LAYER_LOCK_OPACITY) == 0)
					{
						cairo_matrix_init_scale(&matrix, zoom, zoom);
						cairo_pattern_set_matrix(core->brush_pattern, &matrix);
						cairo_set_source(core->temp_cairo, core->brush_pattern);
						cairo_paint_with_alpha(core->temp_cairo, alpha);
						cairo_matrix_init_translate(&matrix, 0, 0);
						cairo_pattern_set_matrix(core->temp_pattern, &matrix);
						cairo_set_source(update, core->temp_pattern);
						cairo_mask_surface(update,
							window->selection->surface_p, - draw_x + r, - draw_y + r);
					}
					else
					{
						temp_surface = cairo_surface_create_for_rectangle(
							window->alpha_temp, draw_x - r, draw_y - r, r*2+1, r*2+1);
						update_temp = cairo_create(temp_surface);

						cairo_matrix_init_scale(&matrix, zoom, zoom);
						cairo_pattern_set_matrix(core->brush_pattern, &matrix);
						cairo_set_source(core->temp_cairo, core->brush_pattern);
						cairo_paint_with_alpha(core->temp_cairo, alpha);
						cairo_matrix_init_translate(&matrix, 0, 0);
						cairo_pattern_set_matrix(core->temp_pattern, &matrix);
						cairo_set_source(update, core->temp_pattern);

						(void)memset(window->temp_layer->pixels, 0,
							window->width*window->height);

						cairo_mask_surface(update,
							window->selection->surface_p, 0, 0);
						cairo_set_source_surface(update_temp,
							update_surface, 0, 0);
						cairo_mask_surface(update_temp,
							window->active_layer->surface_p, - draw_x + r, - draw_y + r);

						mask = window->temp_layer->pixels;
						mask_surface = window->temp_layer->surface_p;

						cairo_surface_destroy(temp_surface);
						cairo_destroy(update_temp);
					}
				}
			}
			else
			{
				temp_surface = cairo_surface_create_for_rectangle(
					window->alpha_temp, draw_x - r, draw_y - r, r*2+1, r*2+1);
				update_temp = cairo_create(temp_surface);

				if((window->flags & DRAW_WINDOW_HAS_SELECTION_AREA) == 0)
				{
					if((window->active_layer->flags & LAYER_LOCK_OPACITY) == 0)
					{
						cairo_matrix_init_scale(&matrix, zoom, zoom);
						cairo_pattern_set_matrix(core->brush_pattern, &matrix);
						cairo_set_source(update, core->brush_pattern);
						cairo_paint_with_alpha(update, alpha);
					}
					else
					{
						cairo_matrix_init_scale(&matrix, zoom, zoom);
						cairo_pattern_set_matrix(core->brush_pattern, &matrix);
						cairo_set_source(core->temp_cairo, core->brush_pattern);
						cairo_paint_with_alpha(core->temp_cairo, alpha);
						cairo_matrix_init_translate(&matrix, 0, 0);
						cairo_pattern_set_matrix(core->temp_pattern, &matrix);
						cairo_set_source(update, core->temp_pattern);
						cairo_mask_surface(update,
							window->active_layer->surface_p, - draw_x + r, - draw_y + r);
					}

					cairo_set_source_surface(update_temp, update_surface, 0, 0);
					cairo_mask_surface(update_temp, window->texture->surface_p, - x + r, - y + r);

					mask = window->temp_layer->pixels;
					mask_surface = window->temp_layer->surface_p;
				}
				else
				{
					if((window->active_layer->flags & LAYER_LOCK_OPACITY) == 0)
					{
						cairo_matrix_init_scale(&matrix, zoom, zoom);
						cairo_pattern_set_matrix(core->brush_pattern, &matrix);
						cairo_set_source(core->temp_cairo, core->brush_pattern);
						cairo_paint_with_alpha(core->temp_cairo, alpha);
						cairo_matrix_init_translate(&matrix, 0, 0);
						cairo_pattern_set_matrix(core->temp_pattern, &matrix);
						cairo_set_source(update, core->temp_pattern);
						cairo_mask_surface(update,
							window->selection->surface_p, - x + r, - y + r);

						cairo_set_source_surface(update_temp, update_surface, 0, 0);
						cairo_mask_surface(update_temp, window->texture->surface_p, - x + r, - y + r);

						mask = window->temp_layer->pixels;
						mask_surface = window->temp_layer->surface_p;
					}
					else
					{
						cairo_matrix_init_scale(&matrix, zoom, zoom);
						cairo_pattern_set_matrix(core->brush_pattern, &matrix);
						cairo_set_source(core->temp_cairo, core->brush_pattern);
						cairo_paint_with_alpha(core->temp_cairo, alpha);
						cairo_matrix_init_translate(&matrix, 0, 0);
						cairo_pattern_set_matrix(core->temp_pattern, &matrix);
						cairo_set_source(update, core->temp_pattern);

						(void)memset(window->temp_layer->pixels, 0,
							window->width*window->height);

						cairo_mask_surface(update,
							window->selection->surface_p, 0, 0);
						cairo_set_source_surface(update_temp,
							update_surface, 0, 0);
						cairo_mask_surface(update_temp,
							window->active_layer->surface_p, - x + r, - y + r);

						cairo_set_operator(update, CAIRO_OPERATOR_SOURCE);
						cairo_set_source_surface(update, temp_surface, 0, 0);
						cairo_mask_surface(update, window->texture->surface_p, - x + r, - y + r);
					}
				}

				cairo_surface_destroy(temp_surface);
				cairo_destroy(update_temp);
			}

			start_x = (int)min_x, start_y = (int)min_y;
			width = (int)(max_x - min_x);
			height = (int)(max_y - min_y);

			if(brush->picker_source == COLOR_PICKER_SOURCE_ACTIVE_LAYER)
			{
				(void)memcpy(window->mask_temp->pixels, window->active_layer->pixels,
					window->pixel_buf_size);
				target = window->mask_temp;
				window->layer_blend_functions[brush->blend_mode](window->work_layer, target);
			}
			else
			{
				target = window->mixed_layer;
			}

			if(brush->picker_mode == PICKER_MODE_SINGLE_PIXEL)
			{
				int int_x = (int)x, int_y = (int)y;
				color[0] = target->pixels[target->stride*int_y+int_x*4];
				color[1] = target->pixels[target->stride*int_y+int_x*4+1];
				color[2] = target->pixels[target->stride*int_y+int_x*4+2];
				color[3] = target->pixels[target->stride*int_y+int_x*4+3];
			}
			else
			{
				sum_color0 = sum_color1 = sum_color2 = sum_color4 = 0;
				sum_color3 = sum_color5 = 1;

#ifdef _OPENMP
#pragma omp parallel for reduction( +: sum_color0, sum_color1, sum_color2, sum_color3, sum_color4, sum_color5) firstprivate(width, start_x, start_y, layer_width, mask)
#endif
				for(i=0; i<height; i++)
				{
					uint8 *ref_pix = &target->pixels[(i+start_y)*target->stride+start_x*4];
					uint8 *mask_pix = &mask[(i+start_y)*layer_width+start_x];
					int j;

					for(j=0; j<width; j++, ref_pix+=4, mask_pix++)
					{
						sum_color0 += ((ref_pix[0]+1) * *mask_pix * ref_pix[3]) >> 8;
						sum_color1 += ((ref_pix[1]+1) * *mask_pix * ref_pix[3]) >> 8;
						sum_color2 += ((ref_pix[2]+1) * *mask_pix * ref_pix[3]) >> 8;
						sum_color3 += ((ref_pix[3]+1) * *mask_pix) >> 8;
						sum_color4 += ref_pix[3] * *mask_pix;
						sum_color5 += *mask_pix;
					}
				}

				color[0] = (uint8)((sum_color0 + sum_color3 / 2) / sum_color3);
				color[1] = (uint8)((sum_color1 + sum_color3 / 2) / sum_color3);
				color[2] = (uint8)((sum_color2 + sum_color3 / 2) / sum_color3);
				color[3] = (uint8)(sum_color4 / sum_color5);
			}

			// 色調整
			if((brush->flags & PICKER_FLAG_CHANGE_HSV) != 0)
			{
				HSV hsv;
				int s, v;
#if defined(USE_BGR_COLOR_SPACE) && USE_BGR_COLOR_SPACE != 0
				uint8 r;
				r = color[2];
				color[2] = color[0];
				color[0] = r;
#endif
				RGB2HSV_Pixel(color, &hsv);
				hsv.h += brush->add_h;
				s = hsv.s, v = hsv.v;
				if(hsv.h < 0)
				{
					hsv.h += 360;
				}
				else if(hsv.h >= 360)
				{
					hsv.h -= 360;
				}
				s += brush->add_s;
				if(s < 0)
				{
					s = 0;
				}
				else if(s > 255)
				{
					s = 255;
				}
				hsv.s = (uint8)s;

				v += brush->add_v;
				if(v < 0)
				{
					v = 0;
				}
				else if(v > 255)
				{
					v = 255;
				}
				hsv.v = (uint8)v;
				HSV2RGB_Pixel(&hsv, color);
#if defined(USE_BGR_COLOR_SPACE) && USE_BGR_COLOR_SPACE != 0
				r = color[2];
				color[2] = color[0];
				color[0] = r;
#endif
			}

			mask = window->brush_buffer;
			temp_surface = cairo_image_surface_create_for_data(
				mask, CAIRO_FORMAT_ARGB32, width, height, width*4);
			(void)memset(mask, 0, width*4*height);
			update_temp = cairo_create(temp_surface);

			// 抽出した色で描画
#if defined(USE_BGR_COLOR_SPACE) && USE_BGR_COLOR_SPACE != 0
			cairo_set_source_rgba(update_temp,
				color[2]*DIV_PIXEL, color[1]*DIV_PIXEL, color[0]*DIV_PIXEL, color[3]*DIV_PIXEL);
#else
			cairo_set_source_rgba(update_temp,
				color[0]*DIV_PIXEL, color[1]*DIV_PIXEL, color[2]*DIV_PIXEL, color[3]*DIV_PIXEL);
#endif
			cairo_mask_surface(update_temp, update_surface, r, r);

			cairo_destroy(update);
			cairo_surface_destroy(update_surface);
			cairo_destroy(update_temp);
			cairo_surface_destroy(temp_surface);

#ifdef _OPENMP
#pragma omp parallel for firstprivate(work_pixel, width, layer_stride, start_x, start_y, mask)
#endif
			for(i=0; i<height; i++)
			{
				uint8 *ref_pix = &work_pixel[
					(start_y+i)*layer_stride+start_x*4];
				uint8 *mask_pix = &mask[i*width*4];
				uint8 src_value;
				uint8 dst_value;
				FLOAT_T src_alpha;
				FLOAT_T dst_alpha;
				FLOAT_T div_alpha;
				int j;

				for(j=0; j<width; j++, ref_pix+=4, mask_pix+=4)
				{
					if(ref_pix[3] < mask_pix[3])
					{
						ref_pix[0] = (uint8)((uint32)(((int)mask_pix[0]-(int)ref_pix[0])
							* mask_pix[3] >> 8) + ref_pix[0]);
						ref_pix[1] = (uint8)((uint32)(((int)mask_pix[1]-(int)ref_pix[1])
							* mask_pix[3] >> 8) + ref_pix[1]);
						ref_pix[2] = (uint8)((uint32)(((int)mask_pix[2]-(int)ref_pix[2])
							* mask_pix[3] >> 8) + ref_pix[2]);
						ref_pix[3] = (uint8)((uint32)(((int)mask_pix[3]-(int)ref_pix[3])
							* mask_pix[3] >> 8) + ref_pix[3]);
					}
					else if(mask_pix[3] > 0)
					{
						src_value = mask_pix[3];
						dst_value = ref_pix[3];
						src_alpha = src_value * DIV_PIXEL;
						dst_alpha = dst_value * DIV_PIXEL;
						div_alpha = src_alpha + dst_alpha*(1-src_alpha);
						if(div_alpha > 0)
						{
							div_alpha = 1 / div_alpha;
							ref_pix[0] = (uint8)(color[0]*src_alpha+(ref_pix[0]*dst_alpha*(1-src_alpha))*div_alpha);
							ref_pix[1] = (uint8)(color[1]*src_alpha+(ref_pix[1]*dst_alpha*(1-src_alpha))*div_alpha);
							ref_pix[2] = (uint8)(color[2]*src_alpha+(ref_pix[2]*dst_alpha*(1-src_alpha))*div_alpha);
						}
					}
				}
			}

			if((brush->flags & PICKER_FLAG_ANTI_ALIAS) != 0)
			{
				ANTI_ALIAS_RECTANGLE range = {start_x-1, start_y-1, width+1, height+1};
				AntiAliasLayer(window->work_layer, window->temp_layer, &range);
			}


skip_draw:
			dx -= step;
			if(dx < 1)
			{
				break;
			}
			else if(dx >= step)
			{
				draw_x += diff_x, draw_y += diff_y;
			}
			else
			{
				draw_x = x, draw_y = y;
			}
		}

		brush->before_x = x, brush->before_y = y;
		window->flags |= DRAW_WINDOW_UPDATE_PART;
	}
}

#define PickerBrushButtonReleaseCallBack DefaultReleaseCallBack

static void PickerBrushDrawCursor(
	DRAW_WINDOW* window,
	FLOAT_T x,
	FLOAT_T y,
	void* data
)
{
	PICKER_BRUSH *brush = (PICKER_BRUSH*)data;
	FLOAT_T r = brush->r * window->zoom_rate;
	cairo_set_line_width(window->disp_temp->cairo_p, 1.0);
	cairo_set_source_rgb(window->disp_temp->cairo_p, 1, 1, 1);
	cairo_arc(window->disp_temp->cairo_p, x, y, r, 0, 2*G_PI);
	cairo_stroke(window->disp_temp->cairo_p);

	cairo_rectangle(window->disp_layer->cairo_p, x - r, y - r,
		(r + BRUSH_UPDATE_MARGIN) * 2, (r + BRUSH_UPDATE_MARGIN) * 2);
	cairo_clip(window->disp_layer->cairo_p);
}

static void PickerBrushButtonUpdate(DRAW_WINDOW* window, FLOAT_T x, FLOAT_T y, PICKER_BRUSH* brush)
{
	FLOAT_T r = brush->r * window->zoom_rate + 1;
	gtk_widget_queue_draw_area(window->window, (gint)(x - r - 1),
		(gint)(y - r - 1), (gint)(r * 2) + 2, (gint)(r * 2) + 2);
}

static void PickerBrushMotionUpdate(DRAW_WINDOW* window, FLOAT_T x, FLOAT_T y, PICKER_BRUSH* brush)
{
	FLOAT_T start_x, start_y;
	FLOAT_T width, height;
	FLOAT_T r = brush->r * window->zoom_rate * 1.275 + BRUSH_UPDATE_MARGIN;

	if(window->before_cursor_x < x)
	{
		start_x = window->before_cursor_x - r;
		width = r * 2 + x - window->before_cursor_x;
	}
	else
	{
		start_x = x - r;
		width = r * 2 + window->before_cursor_x - x;
	}

	if(window->before_cursor_y < y)
	{
		start_y = window->before_cursor_y - r;
		height = r * 2 + y - window->before_cursor_y;
	}
	else
	{
		start_y = y - r;
		height = r * 2 + window->before_cursor_y - y;
	}

	gtk_widget_queue_draw_area(window->window,
		(gint)start_x, (gint)start_y, (gint)width + 2, (gint)height + 2);
}

static void PickerBrushSetScale(GtkAdjustment* slider, PICKER_BRUSH* brush)
{
	brush->r = gtk_adjustment_get_value(slider) * 0.5;
	BrushCoreSetGrayCirclePattern(brush->core, brush->r, brush->outline_hardness * 0.01,
		brush->blur * 0.01, brush->alpha * 0.01);
}

static void PickerBrushSetFlow(GtkAdjustment* slider, PICKER_BRUSH* brush)
{
	brush->alpha = gtk_adjustment_get_value(slider);
	BrushCoreSetGrayCirclePattern(brush->core, brush->r, brush->outline_hardness * 0.01,
		brush->blur * 0.01, brush->alpha * 0.01);
}

static void PickerBrushSetBlur(GtkAdjustment* slider, PICKER_BRUSH* brush)
{
	brush->blur = gtk_adjustment_get_value(slider);
	BrushCoreSetGrayCirclePattern(brush->core, brush->r, brush->outline_hardness * 0.01,
		brush->blur * 0.01, brush->alpha * 0.01);
}

static void PickerBrushSetOutlineHardness(GtkAdjustment* slider, PICKER_BRUSH* brush)
{
	brush->outline_hardness = gtk_adjustment_get_value(slider);
	BrushCoreSetGrayCirclePattern(brush->core, brush->r, brush->outline_hardness * 0.01,
		brush->blur * 0.01, brush->alpha * 0.01);
}

static void PickerBrushSetAddHue(GtkAdjustment* slider, PICKER_BRUSH* brush)
{
	brush->add_h = (int)gtk_adjustment_get_value(slider);

	if(brush->add_h == 0 && brush->add_s == 0 && brush->add_v == 0)
	{
		brush->flags &= ~(PICKER_FLAG_CHANGE_HSV);
	}
	else
	{
		brush->flags |= PICKER_FLAG_CHANGE_HSV;
	}
}

static void PickerBrushSetAddSaturation(GtkAdjustment* slider, PICKER_BRUSH* brush)
{
	brush->add_s = (int)(gtk_adjustment_get_value(slider) * 2.552);

	if(brush->add_h == 0 && brush->add_s == 0 && brush->add_v == 0)
	{
		brush->flags &= ~(PICKER_FLAG_CHANGE_HSV);
	}
	else
	{
		brush->flags |= PICKER_FLAG_CHANGE_HSV;
	}
}

static void PickerBrushSetAddVivid(GtkAdjustment* slider, PICKER_BRUSH* brush)
{
	brush->add_v = (int)(gtk_adjustment_get_value(slider) * 2.552);

	if(brush->add_h == 0 && brush->add_s == 0 && brush->add_v == 0)
	{
		brush->flags &= ~(PICKER_FLAG_CHANGE_HSV);
	}
	else
	{
		brush->flags |= PICKER_FLAG_CHANGE_HSV;
	}
}

static void PickerBrushSetPickTarget(GtkWidget* button, PICKER_BRUSH* brush)
{
	int mode = GPOINTER_TO_INT(g_object_get_data(G_OBJECT(button), "pick_target"));
	if(gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(button)) != FALSE)
	{
		brush->picker_source = (uint8)mode;
	}
}

static void PickerBrushSetPickMode(GtkWidget* button, PICKER_BRUSH* brush)
{
	int mode = GPOINTER_TO_INT(g_object_get_data(G_OBJECT(button), "pick_mode"));
	if(gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(button)) != FALSE)
	{
		brush->picker_mode = (uint8)mode;
	}
}

static void PickerBrushSetPressureSize(GtkWidget* button, PICKER_BRUSH* brush)
{
	if(gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(button)) == FALSE)
	{
		brush->flags &= ~(PICKER_FLAG_PRESSURE_SIZE);
	}
	else
	{
		brush->flags |= PICKER_FLAG_PRESSURE_SIZE;
	}
}

static void PickerBrushSetPressureFlow(GtkWidget* button, PICKER_BRUSH* brush)
{
	if(gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(button)) == FALSE)
	{
		brush->flags &= ~(PICKER_FLAG_PRESSURE_FLOW);
	}
	else
	{
		brush->flags |= PICKER_FLAG_PRESSURE_FLOW;
	}
}

static void PickerBrushSetBlendMode(GtkComboBox* combo, PICKER_BRUSH* brush)
{
	brush->blend_mode = (uint16)gtk_combo_box_get_active(combo);
}

static void PickerBrushSetAntiAlias(GtkWidget* button, PICKER_BRUSH* brush)
{
	if(gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(button)) == FALSE)
	{
		brush->flags &= ~(PICKER_FLAG_ANTI_ALIAS);
	}
	else
	{
		brush->flags |= PICKER_FLAG_ANTI_ALIAS;
	}
}

static GtkWidget* CreatePickerBrushDetailUI(APPLICATION* app, BRUSH_CORE* core)
{
#define UI_FONT_SIZE 8.0
	PICKER_BRUSH *brush = (PICKER_BRUSH*)core->brush_data;
	GtkWidget *vbox = gtk_vbox_new(FALSE, 0);
	GtkWidget *hbox;
	GtkWidget *brush_scale;
	GtkWidget *check_button;
	GtkWidget *buttons[2];
	GtkWidget *combo;
	GtkWidget *label;
	GtkAdjustment *scale_adjustment;
	char mark_up_buff[256];
	int i;

	brush->core = core;

	{
		const char *mag_str[] = {"x 0.1", "x 1", "x 10"};
		hbox = gtk_hbox_new(FALSE, 0);
		label = gtk_label_new("");
		(void)sprintf(mark_up_buff, "<span font_desc=\"%.2f\">%s : </span>",
			UI_FONT_SIZE * app->gui_scale, app->labels->tool_box.base_scale);
		gtk_label_set_markup(GTK_LABEL(label), mark_up_buff);
		gtk_box_pack_start(GTK_BOX(hbox), label, FALSE, FALSE, 0);
#if GTK_MAJOR_VERSION <= 2
		combo = gtk_combo_box_new_text();
		gtk_combo_box_append_text(GTK_COMBO_BOX(combo), mag_str[0]);
		gtk_combo_box_append_text(GTK_COMBO_BOX(combo), mag_str[1]);
		gtk_combo_box_append_text(GTK_COMBO_BOX(combo), mag_str[2]);
#else
		combo = gtk_combo_box_text_new();
		gtk_combo_box_text_append_text(GTK_COMBO_BOX_TEXT(combo), mag_str[0]);
		gtk_combo_box_text_append_text(GTK_COMBO_BOX_TEXT(combo), mag_str[1]);
		gtk_combo_box_text_append_text(GTK_COMBO_BOX_TEXT(combo), mag_str[2]);
#endif
		gtk_combo_box_set_active(GTK_COMBO_BOX(combo), brush->base_scale);
		gtk_box_pack_start(GTK_BOX(hbox), combo, TRUE, TRUE, 0);
		gtk_box_pack_start(GTK_BOX(vbox), hbox, FALSE, FALSE, 0);
	}

	switch(brush->base_scale)
	{
	case 0:
		scale_adjustment = GTK_ADJUSTMENT(gtk_adjustment_new(
			brush->r * 2, 0.1, 10.0, 0.1, 0.1, 0.0));
		break;
	case 1:
		scale_adjustment = GTK_ADJUSTMENT(gtk_adjustment_new(
			brush->r * 2, 1.0, 100.0, 1.0, 1.0, 0.0));
		break;
	default:
		scale_adjustment = GTK_ADJUSTMENT(gtk_adjustment_new(
			brush->r * 2, 5.0, 500.0, 1.0, 1.0, 0.0));
	}

	(void)g_signal_connect(G_OBJECT(scale_adjustment), "value_changed",
		G_CALLBACK(PickerBrushSetScale), brush);
	brush_scale = SpinScaleNew(scale_adjustment, app->labels->tool_box.brush_scale, 1);
	gtk_box_pack_start(GTK_BOX(vbox), brush_scale, FALSE, FALSE, 0);

	g_object_set_data(G_OBJECT(combo), "scale", brush_scale);
	(void)g_signal_connect(G_OBJECT(combo), "changed", G_CALLBACK(SetBrushBaseScale), &brush->base_scale);

	scale_adjustment = GTK_ADJUSTMENT(gtk_adjustment_new(
		brush->alpha, 0.0, 100.0, 1.0, 1.0, 0.0));
	(void)g_signal_connect(G_OBJECT(scale_adjustment), "value_changed",
		G_CALLBACK(PickerBrushSetFlow), brush);
	brush_scale = SpinScaleNew(scale_adjustment, app->labels->tool_box.flow, 1);
	gtk_box_pack_start(GTK_BOX(vbox), brush_scale, FALSE, FALSE, 0);

	scale_adjustment = GTK_ADJUSTMENT(gtk_adjustment_new(
		brush->outline_hardness, 0.0, 100.0, 1.0, 1.0, 0.0));
	(void)g_signal_connect(G_OBJECT(scale_adjustment), "value_changed",
		G_CALLBACK(PickerBrushSetOutlineHardness), brush);
	brush_scale = SpinScaleNew(scale_adjustment, app->labels->tool_box.outline_hardness, 1);
	gtk_box_pack_start(GTK_BOX(vbox), brush_scale, FALSE, FALSE, 0);

	scale_adjustment = GTK_ADJUSTMENT(gtk_adjustment_new(
		brush->blur, 0.0, 100.0, 1.0, 1.0, 0.0));
	(void)g_signal_connect(G_OBJECT(scale_adjustment), "value_changed",
		G_CALLBACK(PickerBrushSetBlur), brush);
	brush_scale = SpinScaleNew(scale_adjustment, app->labels->tool_box.blur, 1);
	gtk_box_pack_start(GTK_BOX(vbox), brush_scale, FALSE, FALSE, 0);

	hbox = gtk_hbox_new(FALSE, 0);
	label = gtk_label_new("");
#if GTK_MAJOR_VERSION <= 2
	combo = gtk_combo_box_new_text();
#else
	combo = gtk_combo_box_text_new();
#endif
	(void)sprintf(mark_up_buff, "<span font_desc=\"%.2f\">%s : </span>",
		UI_FONT_SIZE * app->gui_scale, app->labels->layer_window.blend_mode);
	gtk_label_set_markup(GTK_LABEL(label), mark_up_buff);
	gtk_box_pack_start(GTK_BOX(hbox), label, FALSE, FALSE, 0);
	for(i=0; i<LAYER_BLEND_SLELECTABLE_NUM; i++)
	{
#if GTK_MAJOR_VERSION <= 2
		gtk_combo_box_append_text(GTK_COMBO_BOX(combo), app->labels->layer_window.blend_modes[i]);
#else
		gtk_combo_box_text_append_text(GTK_COMBO_BOX_TEXT(combo), app->labels->layer_window.blend_modes[i]);
#endif
	}
	gtk_combo_box_set_active(GTK_COMBO_BOX(combo), brush->blend_mode);
	(void)g_signal_connect(G_OBJECT(combo), "changed",
		G_CALLBACK(PickerBrushSetBlendMode), brush);
	gtk_box_pack_start(GTK_BOX(hbox), combo, FALSE, TRUE, 0);
	gtk_box_pack_start(GTK_BOX(vbox), hbox, FALSE, TRUE, 0);

	hbox = gtk_hbox_new(FALSE, 0);
	label = gtk_label_new("");
	(void)sprintf(mark_up_buff, "<span font_desc=\"%.2f\">%s : </span>",
		UI_FONT_SIZE * app->gui_scale, app->labels->tool_box.pressure);
	gtk_label_set_markup(GTK_LABEL(label), mark_up_buff);
	gtk_box_pack_start(GTK_BOX(hbox), label, FALSE, FALSE, 0);
	check_button = gtk_check_button_new_with_label(app->labels->tool_box.scale);
	(void)g_signal_connect(G_OBJECT(check_button), "toggled",
		G_CALLBACK(PickerBrushSetPressureSize), brush);
	gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(check_button), brush->flags & BRUSH_FLAG_SIZE);
	gtk_box_pack_start(GTK_BOX(hbox), check_button, FALSE, TRUE, 0);
	check_button = gtk_check_button_new_with_label(app->labels->tool_box.flow);
	(void)g_signal_connect(G_OBJECT(check_button), "toggled",
		G_CALLBACK(PickerBrushSetPressureFlow), brush);
	gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(check_button), brush->flags & BRUSH_FLAG_FLOW);
	gtk_box_pack_start(GTK_BOX(hbox), check_button, FALSE, TRUE, 0);
	gtk_box_pack_start(GTK_BOX(vbox), hbox, FALSE, TRUE, 0);

	check_button = gtk_check_button_new_with_label(app->labels->tool_box.anti_alias);
	(void)g_signal_connect(G_OBJECT(check_button), "toggled",
		G_CALLBACK(PickerBrushSetAntiAlias), brush);
	gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(check_button), brush->flags & BRUSH_FLAG_ANTI_ALIAS);
	gtk_box_pack_start(GTK_BOX(vbox), check_button, FALSE, TRUE, 0);

	scale_adjustment = GTK_ADJUSTMENT(gtk_adjustment_new(
		brush->add_h, -180.0, 180.0, 1.0, 1.0, 0.0));
	(void)g_signal_connect(G_OBJECT(scale_adjustment), "value_changed",
		G_CALLBACK(PickerBrushSetAddHue), brush);
	brush_scale = SpinScaleNew(scale_adjustment, app->labels->tool_box.hue, 1);
	gtk_box_pack_start(GTK_BOX(vbox), brush_scale, FALSE, FALSE, 0);

	scale_adjustment = GTK_ADJUSTMENT(gtk_adjustment_new(
		(brush->add_s/255.0)*100, 0.0, 100.0, 1.0, 1.0, 0.0));
	g_signal_connect(G_OBJECT(scale_adjustment), "value_changed",
		G_CALLBACK(PickerBrushSetAddSaturation), brush);
	brush_scale = SpinScaleNew(scale_adjustment, app->labels->tool_box.saturation, 1);
	gtk_box_pack_start(GTK_BOX(vbox), brush_scale, FALSE, FALSE, 0);

	scale_adjustment = GTK_ADJUSTMENT(gtk_adjustment_new(
		(brush->add_h/255.0)*100, 0.0, 100.0, 1.0, 1.0, 0.0));
	(void)g_signal_connect(G_OBJECT(scale_adjustment), "value_changed",
		G_CALLBACK(PickerBrushSetAddVivid), brush);
	brush_scale = SpinScaleNew(scale_adjustment, app->labels->tool_box.brightness, 1);
	gtk_box_pack_start(GTK_BOX(vbox), brush_scale, FALSE, FALSE, 0);

	if(brush->add_h == 0 && brush->add_s == 0 && brush->add_v == 0)
	{
		brush->flags &= ~(PICKER_FLAG_CHANGE_HSV);
	}
	else
	{
		brush->flags |= PICKER_FLAG_CHANGE_HSV;
	}

	label = gtk_label_new("");
	(void)sprintf(mark_up_buff, "<span font_desc=\"%.2f\">%s : </span>",
		UI_FONT_SIZE * app->gui_scale, app->labels->unit.target);
	gtk_label_set_markup(GTK_LABEL(label), mark_up_buff);
	hbox = gtk_hbox_new(FALSE, 0);
	gtk_box_pack_start(GTK_BOX(hbox), label, FALSE, FALSE, 0);
	gtk_box_pack_start(GTK_BOX(vbox), hbox, FALSE, FALSE, 0);
	buttons[0] = gtk_radio_button_new_with_label(NULL, app->labels->tool_box.select.active_layer);
	g_object_set_data(G_OBJECT(buttons[0]), "pick_target", GINT_TO_POINTER(COLOR_PICKER_SOURCE_ACTIVE_LAYER));
	(void)g_signal_connect(G_OBJECT(buttons[0]), "toggled", G_CALLBACK(PickerBrushSetPickTarget), brush);
	buttons[1] = gtk_radio_button_new_with_label(gtk_radio_button_get_group(
		GTK_RADIO_BUTTON(buttons[0])), app->labels->tool_box.select.canvas);
	g_object_set_data(G_OBJECT(buttons[1]), "pick_target", GINT_TO_POINTER(COLOR_PICKER_SOURCE_CANVAS));
	g_signal_connect(G_OBJECT(buttons[1]), "toggled", G_CALLBACK(PickerBrushSetPickTarget), brush);
	gtk_box_pack_start(GTK_BOX(vbox), buttons[0], FALSE, FALSE, 0);
	gtk_box_pack_start(GTK_BOX(vbox), buttons[1], FALSE, FALSE, 0);
	gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(buttons[brush->picker_source]), TRUE);

	label = gtk_label_new("");
	(void)sprintf(mark_up_buff, "<span font_desc=\"%.2f\">%s : </span>",
		UI_FONT_SIZE * app->gui_scale, app->labels->tool_box.pick_mode);
	gtk_label_set_markup(GTK_LABEL(label), mark_up_buff);
	hbox = gtk_hbox_new(FALSE, 0);
	gtk_box_pack_start(GTK_BOX(hbox), label, FALSE, FALSE, 0);
	gtk_box_pack_start(GTK_BOX(vbox), hbox, FALSE, FALSE, 0);
	buttons[0] = gtk_radio_button_new_with_label(NULL, app->labels->tool_box.single_pixels);
	g_object_set_data(G_OBJECT(buttons[0]), "pick_mode", GINT_TO_POINTER(PICKER_MODE_SINGLE_PIXEL));
	(void)g_signal_connect(G_OBJECT(buttons[0]), "toggled", G_CALLBACK(PickerBrushSetPickMode), brush);
	buttons[1] = gtk_radio_button_new_with_label(gtk_radio_button_get_group(
		GTK_RADIO_BUTTON(buttons[0])), app->labels->tool_box.average_color);
	g_object_set_data(G_OBJECT(buttons[1]), "pick_mode", GINT_TO_POINTER(PICKER_MODE_AVERAGE));
	(void)g_signal_connect(G_OBJECT(buttons[1]), "toggled", G_CALLBACK(PickerBrushSetPickMode), brush);
	gtk_box_pack_start(GTK_BOX(vbox), buttons[0], FALSE, FALSE, 0);
	gtk_box_pack_start(GTK_BOX(vbox), buttons[1], FALSE, FALSE, 0);
	gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(buttons[brush->picker_mode]), TRUE);

	BrushCoreSetGrayCirclePattern(brush->core, brush->r, brush->outline_hardness * 0.01,
		brush->blur * 0.01, brush->alpha * 0.01);

	return vbox;
}

static void PickerImageBrushPressCallBack(
	DRAW_WINDOW* window,
	FLOAT_T x,
	FLOAT_T y,
	FLOAT_T pressure,
	BRUSH_CORE *core,
	void* state
)
{
	// 左クリックなら
	if(((GdkEventButton*)state)->button == 1)
	{
		// ブラシの詳細情報にキャスト
		PICKER_IMAGE_BRUSH *brush = (PICKER_IMAGE_BRUSH*)core->brush_data;
		// ブラシの半径
		FLOAT_T r;
		// 座標の最大値・最小値
		FLOAT_T min_x, min_y, max_x, max_y;
		// 描画色
		FLOAT_T color[3] = {(*core->color)[0]*DIV_PIXEL,
			(*core->color)[1]*DIV_PIXEL, (*core->color)[2]*DIV_PIXEL};

		window->work_layer->layer_mode = brush->blend_mode;

		r = ((brush->core.flags & STAMP_PRESSURE_SIZE) == 0) ?
			brush->core.r : brush->core.r * pressure;

		if((brush->core.flags & STAMP_RANDOM_SIZE) != 0)
		{
			r *= rand() / (FLOAT_T)RAND_MAX;
		}

		brush->stamp_distance = 0;
		brush->core.before_x = x, brush->core.before_y = y;
		brush->points[0][1] = x, brush->points[0][2] = y;
		brush->points[0][3] = pressure;
		brush->sum_distance = brush->travel = brush->finish_length = 0;
		//brush->remain_distance = brush->core.d * brush->core.d;
		brush->remain_distance = brush->core.d;
		brush->draw_start = r * brush->out * 0.01 * 4;
		brush->enter_length = r * brush->enter * 0.01 * 4;
		brush->enter_size = (1 - brush->enter * 0.01);
		brush->num_point = 0;
		brush->draw_finished = 0;
		brush->ref_point = 1;

		min_x = x - r, max_x = x + r;
		min_y = y - r, max_y = y + r;

		if(min_x < 0.0)
		{
			min_x = 0.0;
		}
		if(min_y < 0.0)
		{
			min_y = 0.0;
		}
		if(max_x > window->work_layer->width)
		{
			max_x = window->work_layer->width;
		}
		if(max_y > window->work_layer->height)
		{
			max_y = window->work_layer->height;
		}

		core->min_x = min_x, core->min_y = min_y;
		core->max_x = max_x, core->max_y = max_y;

		window->update.x = (int)min_x, window->update.y = (int)min_y;
		window->update.width = (int)max_x - window->update.x;
		window->update.height = (int)max_y - window->update.y;

		window->flags |= DRAW_WINDOW_UPDATE_PART;
	}	// 左クリックなら
		// if(((GdkEventButton*)state)->button == 1)
}

#define PickerImageBrushEditSelectionPress PickerImageBrushPressCallBack

static void PickerImageBrushMotionCallBack(
	DRAW_WINDOW* window,
	FLOAT_T x,
	FLOAT_T y,
	FLOAT_T pressure,
	BRUSH_CORE *core,
	void* state
)
{
	// マウスの左ボタンが押されていたら
	if(((*(GdkModifierType*)state) & GDK_BUTTON1_MASK) != 0)
	{
		// ブラシの詳細情報にキャスト
		PICKER_IMAGE_BRUSH *brush = (PICKER_IMAGE_BRUSH*)core->brush_data;
		FLOAT_T distance;
		int index = brush->ref_point % BRUSH_POINT_BUFFER_SIZE;

		distance = sqrt((x-brush->core.before_x)*(x-brush->core.before_x)
			+(y-brush->core.before_y)*(y-brush->core.before_y));
		brush->stamp_distance += distance;

		if(distance >= 1.0)
		{
			brush->core.before_x = x, brush->core.before_y = y;
			brush->sum_distance += distance;
			brush->remain_distance -= distance;
			brush->travel += distance;
			brush->points[index][0] = distance;
			brush->points[index][1] = x, brush->points[index][2] = y;
			brush->points[index][3] = pressure;
			brush->ref_point++;

			if(brush->sum_distance >= brush->draw_start
				&& brush->sum_distance >= brush->enter_length
				&& brush->remain_distance <= 0)
			{
				// 更新範囲のイメージ情報
				cairo_t *update, *update_temp;
				cairo_surface_t *update_surface, *temp_surface;
				// 入りの色補正用
				FLOAT_T enter_alpha;
				// ブラシの半径と不透明度
				FLOAT_T r, alpha;
				// 座標の最大・最小値
				FLOAT_T min_x, min_y, max_x, max_y;
				// X、Y方向の移動量
				FLOAT_T dx, dy;
				// ブラシの傾き用
				FLOAT_T diff_x, diff_y;
				// ブラシの移動量
				FLOAT_T d;
				// 描画を行う座標
				FLOAT_T draw_x = brush->core.before_x, draw_y = brush->core.before_y;
				// 画面更新を行う座標、範囲
				FLOAT_T update_x, update_y, update_r;
				// 画像に対しての拡大・回転処理用の行列データ
				cairo_matrix_t matrix, reset_matrix;
				// 画像の拡大率
				FLOAT_T zoom;
				// 移動量計算用
				FLOAT_T cos_x, sin_y, trans_x, trans_y;
				// 画像の幅・高さの半分
				FLOAT_T half_width, half_height;
				// ピクセルデータをリセットする座標
				int start_x, start_y;
				// 描画する幅、高さ、一行分のバイト数
				int width, height, stride;
				// 作業レイヤーの一行分のバイト数
				int layer_stride = window->work_layer->stride;
				// 作業レイヤーのピクセル
				uint8 *work_pixel = window->work_layer->pixels;
				// 参照ピクセル
				uint8 *mask;
				// 配列のインデックス用
				int ref_point = brush->draw_finished % BRUSH_POINT_BUFFER_SIZE;
				int before_point;
				// 描画色
				uint8 color[4];
				// 平均色計算用
				uint64 sum_color0, sum_color1, sum_color2,
					sum_color3, sum_color4, sum_color5;
				// 色を抽出するレイヤー
				LAYER *target;
				// αブレンド用
				int i;	// for文用のカウンタ

				cairo_matrix_init_scale(&reset_matrix, 1, 1);

				while(brush->sum_distance > brush->draw_start
					&& brush->draw_finished < brush->ref_point-1)
				{
					if(brush->finish_length < brush->enter_length)
					{
						enter_alpha = brush->finish_length / brush->enter_length;
						r = brush->enter_size + brush->finish_length * 0.25;
					}
					else
					{
						enter_alpha = 1, r = 1;
					}
					if((brush->core.flags & STAMP_PRESSURE_SIZE) != 0)
					{
						r *= brush->points[ref_point][3];
					}
					if((brush->core.flags & STAMP_RANDOM_SIZE) != 0)
					{
						r *= 1 - (brush->size_range * (rand() / (FLOAT_T)RAND_MAX));
					}

					if(r < MIN_BRUSH_STEP)
					{
						r = MIN_BRUSH_STEP;
					}

					half_width = brush->core.half_width * r;
					half_height = brush->core.half_height * r;
					zoom = (1/r) * brush->core.scale;
					r *= brush->core.r;

					alpha = ((brush->core.flags & BRUSH_FLAG_FLOW) == 0)
						? 1 : brush->points[ref_point][3];
					alpha *= enter_alpha;

					before_point = (ref_point == 0) ? BRUSH_POINT_BUFFER_SIZE - 1 : ref_point - 1;
					d = brush->points[ref_point][0];
					brush->sum_distance -= d;
					if(brush->draw_finished == 0)
					{
						draw_x = brush->points[0][1], draw_y = brush->points[0][2];
					}
					else
					{
						draw_x = brush->points[before_point][1];
						draw_y = brush->points[before_point][2];
					}
					dx = brush->points[ref_point][1] - draw_x;
					dy = brush->points[ref_point][2] - draw_y;

					if((brush->core.flags & STAMP_RANDOM_ROTATE) != 0)
					{
						brush->core.rotate = brush->core.rotate_start +
							(rand() / (FLOAT_T)RAND_MAX) * brush->core.rotate_direction * brush->rotate_range;
						if((brush->core.flags & BRUSH_FLAG_ROTATE) != 0)
						{
							brush->core.rotate += brush->core.rotate_direction * atan2(dy, dx);
						}
					}
					else if((brush->core.flags & STAMP_RANDOM_ROTATE) != 0)
					{
						brush->core.rotate = (rand() / (FLOAT_T)RAND_MAX) * (2*G_PI);
					}
					else if((brush->core.flags & BRUSH_FLAG_ROTATE) != 0)
					{
						brush->core.rotate = brush->core.rotate_start + brush->core.rotate_direction * atan2(dy, dx);
					}
					else
					{
						brush->core.rotate = brush->core.rotate_start;
					}
					cos_x = cos(brush->core.rotate), sin_y = sin(brush->core.rotate);
					diff_x = brush->core.d * dx/d, diff_y = brush->core.d * dy/d;

					min_x = brush->points[ref_point][1] - r - 1;
					max_x = brush->points[ref_point][1] + r + 1;
					min_y = brush->points[ref_point][2] - r - 1;
					max_y = brush->points[ref_point][2] + r + 1;

					if(min_x < 0.0)
					{
						min_x = 0.0;
					}
					if(core->min_x > min_x)
					{
						core->min_x = min_x;
					}
					if(min_y < 0.0)
					{
						min_y = 0.0;
					}
					if(core->min_y > min_y)
					{
						core->min_y = min_y;
					}
					if(max_x > window->work_layer->width)
					{
						max_x = window->work_layer->width;
					}
					if(core->max_x < max_x)
					{
						core->max_x = max_x;
					}
					if(max_y > window->work_layer->height)
					{
						min_y = window->work_layer->height;
					}
					if(core->max_y < max_y)
					{
						core->max_y = max_y;
					}

					if(window->update.x > min_x)
					{
						window->update.width += window->update.x - (int)min_x;
						window->update.x = (int)min_x;
					}
					if(window->update.width + window->update.x < max_x)
					{
						window->update.width += (int)max_x - window->update.width + window->update.x;
					}
					if(window->update.y > min_y)
					{
						window->update.height += window->update.y - (int)min_y;
						window->update.y = (int)min_y;
					}
					if(window->update.height + window->update.y < max_y)
					{
						window->update.height += (int)max_y - window->update.height + window->update.y;
					}

					if(brush->stamp_distance >= brush->core.d)
					{
						dx = d;
						do
						{
							if(draw_x < 0 || draw_x >= window->width
								|| draw_y < 0 || draw_y >= window->height)
							{
								dx = 0;
								goto skip_draw;
							}

							start_x = (int)(draw_x - r);
							start_y = (int)(draw_y - r);
							width = (int)(draw_x + r);
							height = (int)(draw_y + r);

							if(start_x < 0)
							{
								start_x = 0;
							}
							else if(start_x > window->work_layer->width)
							{
								goto skip_draw;
							}
							if(start_y < 0)
							{
								start_y = 0;
							}
							else if(start_y > window->work_layer->height)
							{
								goto skip_draw;
							}
							if(width > window->work_layer->width)
							{
								width = window->work_layer->width - start_x;
							}
							else
							{
								width = width - start_x;
							}
							if(height > window->work_layer->height)
							{
								height = window->work_layer->height - start_y;
							}
							else
							{
								height = height - start_y;
							}

							if(width < 0 || height < 0)
							{
								goto skip_draw;
							}

							stride = width*4;

							update_surface = cairo_surface_create_for_rectangle(
								window->mask_temp->surface_p, draw_x - r, draw_y - r, r*2+1, r*2+1);
							update = cairo_create(update_surface);

							for(i=0; i<height; i++)
							{
								(void)memset(&window->mask_temp->pixels[(i+start_y)*window->mask_temp->stride+start_x*4],
									0, stride);
							}

							trans_x = r - (half_width * cos_x + half_height * sin_y);
							trans_y = r + (half_width * sin_y - half_height * cos_x);

							// 行列データに拡大・縮小、回転角をセット
							cairo_set_operator(window->mask_temp->cairo_p, CAIRO_OPERATOR_OVER);
							cairo_matrix_init_scale(&matrix, zoom, zoom);
							cairo_matrix_rotate(&matrix, brush->core.rotate);
							cairo_matrix_translate(&matrix, - trans_x, - trans_y);

							mask = window->mask_temp->pixels;
							if((window->flags & DRAW_WINDOW_HAS_SELECTION_AREA) == 0)
							{
								if((window->active_layer->flags & LAYER_LOCK_OPACITY) == 0)
								{
									cairo_set_source(update, core->brush_pattern);
									cairo_pattern_set_matrix(core->brush_pattern, &matrix);
									cairo_paint_with_alpha(update, alpha);
								}
								else
								{
									cairo_pattern_set_matrix(core->brush_pattern, &reset_matrix);
									cairo_set_source(core->temp_cairo, core->brush_pattern);
									cairo_paint_with_alpha(core->temp_cairo, alpha);
									cairo_set_source(update, core->temp_pattern);
									cairo_pattern_set_matrix(core->temp_pattern, &matrix);
									cairo_mask_surface(update,
										window->active_layer->surface_p, - draw_x + r, - draw_y + r);
								}
							}
							else
							{
								if((window->active_layer->flags & LAYER_LOCK_OPACITY) == 0)
								{
									cairo_pattern_set_matrix(core->brush_pattern, &reset_matrix);
									cairo_set_source(core->temp_cairo, core->brush_pattern);
									cairo_paint_with_alpha(core->temp_cairo, alpha);
									cairo_set_source(update, core->temp_pattern);
									cairo_pattern_set_matrix(core->temp_pattern, &matrix);
									cairo_mask_surface(update,
										window->selection->surface_p, - draw_x + r, - draw_y + r);
								}
								else
								{
									temp_surface = cairo_surface_create_for_rectangle(
										window->temp_layer->surface_p, draw_x-r, draw_y-r, r*2+1, r*2+1
									);
									update_temp = cairo_create(temp_surface);

									for(i=0; i<height; i++)
									{
										(void)memset(&window->temp_layer->pixels[
											(i+start_y)*window->temp_layer->stride+start_x*4],
											0, stride
										);
									}

									cairo_pattern_set_matrix(core->brush_pattern, &reset_matrix);
									cairo_set_source(core->temp_cairo, core->brush_pattern);
									cairo_paint_with_alpha(core->temp_cairo, alpha);
									cairo_set_source(update, core->temp_pattern);
									cairo_mask_surface(update,
										window->selection->surface_p, - draw_x + r, - draw_y + r);
									cairo_set_source_surface(update_temp,
										update_surface, 0, 0);
									cairo_mask_surface(update_temp,
										window->active_layer->surface_p, - draw_x + r, - draw_y + r);

									mask = window->temp_layer->pixels;

									cairo_surface_destroy(temp_surface);
									cairo_destroy(update_temp);
								}
							}

							// テクスチャを適用
							if(window->app->textures.active_texture != 0)
							{
								temp_surface = cairo_surface_create_for_rectangle(
									window->temp_layer->surface_p, draw_x - r, draw_y - r, r*2+1, r*2+1);
								update_temp = cairo_create(temp_surface);

								if(mask == window->mask_temp->pixels)
								{
									for(i=0; i<height; i++)
									{
										(void)memset(&window->temp_layer->pixels[
											(i+start_y)*window->temp_layer->stride+start_x*4],
											0, stride
										);
									}
									cairo_set_source_surface(update_temp,
										update_surface, 0, 0);
									cairo_mask_surface(update_temp, window->texture->surface_p, - draw_x + r, - draw_y + r);
									mask = window->temp_layer->pixels;
								}
								else
								{
									for(i=0; i<height; i++)
									{
										(void)memset(&window->mask_temp->pixels[
											(i+start_y)*window->mask_temp->stride+start_x*4],
											0, stride
										);
									}
									cairo_set_source_surface(update,
										temp_surface, 0, 0);
									cairo_mask_surface(update, window->texture->surface_p, - draw_x + r, - draw_y + r);
									mask = window->mask_temp->pixels;
								}

								cairo_surface_destroy(temp_surface);
								cairo_destroy(update_temp);
							}

							if(brush->picker_source == COLOR_PICKER_SOURCE_ACTIVE_LAYER)
							{
								(void)memcpy(window->mask->pixels, window->active_layer->pixels,
									window->pixel_buf_size);
								target = window->mask;
								window->layer_blend_functions[brush->blend_mode](window->work_layer, target);
							}
							else
							{
								target = window->mixed_layer;
							}

							if(brush->picker_mode == PICKER_MODE_SINGLE_PIXEL)
							{
								int int_x = (int)x, int_y = (int)y;
								color[0] = target->pixels[target->stride*int_y+int_x*4];
								color[1] = target->pixels[target->stride*int_y+int_x*4+1];
								color[2] = target->pixels[target->stride*int_y+int_x*4+2];
								color[3] = target->pixels[target->stride*int_y+int_x*4+3];
							}
							else
							{
								sum_color0 = sum_color1 = sum_color2 = sum_color4 = 0;
								sum_color3 = sum_color5 = 1;

#ifdef _OPENMP
#pragma omp parallel for reduction( +: sum_color0, sum_color1, sum_color2, sum_color3, sum_color4, sum_color5) firstprivate(mask, start_x, start_y, width, layer_stride)
#endif
								for(i=0; i<height; i++)
								{
									uint8 *ref_pix = &target->pixels[(i+start_y)*target->stride+start_x*4];
									uint8 *mask_pix = &mask[(i+start_y)*layer_stride+start_x*4+3];
									int j;

									for(j=0; j<width; j++, ref_pix+=4, mask_pix+=4)
									{
										sum_color0 += ((ref_pix[0]+1) * *mask_pix * ref_pix[3]) >> 8;
										sum_color1 += ((ref_pix[1]+1) * *mask_pix * ref_pix[3]) >> 8;
										sum_color2 += ((ref_pix[2]+1) * *mask_pix * ref_pix[3]) >> 8;
										sum_color3 += ((ref_pix[3]+1) * *mask_pix) >> 8;
										sum_color4 += ref_pix[3] * *mask_pix;
										sum_color5 += *mask_pix;
									}
								}

								color[0] = (uint8)((sum_color0 + sum_color3 / 2) / sum_color3);
								color[1] = (uint8)((sum_color1 + sum_color3 / 2) / sum_color3);
								color[2] = (uint8)((sum_color2 + sum_color3 / 2) / sum_color3);
								color[3] = (uint8)(sum_color4 / sum_color5);
							}

							// 色調整
							if((brush->flags & PICKER_FLAG_CHANGE_HSV) != 0)
							{
								HSV hsv;
								int s, v;
#if defined(USE_BGR_COLOR_SPACE) && USE_BGR_COLOR_SPACE != 0
								uint8 r;
								r = color[2];
								color[2] = color[0];
								color[0] = r;
#endif
								RGB2HSV_Pixel(color, &hsv);
								hsv.h += brush->add_h;
								s = hsv.s, v = hsv.v;
								if(hsv.h < 0)
								{
									hsv.h += 360;
								}
								else if(hsv.h >= 360)
								{
									hsv.h -= 360;
								}
								s += brush->add_s;
								if(s < 0)
								{
									s = 0;
								}
								else if(s > 255)
								{
									s = 255;
								}
								hsv.s = (uint8)s;

								v += brush->add_v;
								if(v < 0)
								{
									v = 0;
								}
								else if(v > 255)
								{
									v = 255;
								}
								hsv.v = (uint8)v;
								HSV2RGB_Pixel(&hsv, color);
#if defined(USE_BGR_COLOR_SPACE) && USE_BGR_COLOR_SPACE != 0
								r = color[2];
								color[2] = color[0];
								color[0] = r;
#endif
							}

							cairo_surface_destroy(update_surface);
							cairo_destroy(update);

							if(mask == window->mask_temp->pixels)
							{
								temp_surface = cairo_surface_create_for_rectangle(
									window->mask_temp->surface_p, draw_x - r, draw_y - r, r*2+1, r*2+1);
								update_surface = cairo_surface_create_for_rectangle(
									window->temp_layer->surface_p, draw_x - r, draw_y - r, r*2+1, r*2+1);
								mask = window->temp_layer->pixels;
							}
							else
							{
								temp_surface = cairo_surface_create_for_rectangle(
									window->temp_layer->surface_p, draw_x - r, draw_y - r, r*2+1, r*2+1);
								update_surface = cairo_surface_create_for_rectangle(
									window->mask_temp->surface_p, draw_x - r, draw_y - r, r*2+1, r*2+1);
								mask = window->mask_temp->pixels;
							}

							for(i=0; i<height; i++)
							{
								(void)memset(&mask[(start_y+i)*window->stride+start_x*4], 0, stride);
							}
							update = cairo_create(update_surface);
#if defined(USE_BGR_COLOR_SPACE) && USE_BGR_COLOR_SPACE != 0
							cairo_set_source_rgba(update, color[2]*DIV_PIXEL,
								color[1]*DIV_PIXEL, color[0]*DIV_PIXEL, color[3]*DIV_PIXEL);
#else
							cairo_set_source_rgba(update, color[0]*DIV_PIXEL,
								color[1]*DIV_PIXEL, color[2]*DIV_PIXEL, color[3]*DIV_PIXEL);
#endif
							cairo_mask_surface(update, temp_surface, 0, 0);

							cairo_destroy(update);
							cairo_surface_destroy(temp_surface);
							cairo_surface_destroy(update_surface);

#ifdef _OPENMP
#pragma omp parallel for firstprivate(work_pixel, width, layer_stride, start_x, start_y, mask)
#endif
							for(i=0; i<height; i++)
							{
								uint8 *ref_pix = &work_pixel[
									(start_y+i)*layer_stride+start_x*4];
								uint8 *mask_pix = &mask[(start_y+i)*layer_stride
									+start_x*4];
								int j;

								for(j=0; j<width; j++, ref_pix+=4, mask_pix+=4)
								{
									if(ref_pix[3] < mask_pix[3])
									{
										ref_pix[0] = (uint8)((uint32)(((int)mask_pix[0]-(int)ref_pix[0])
											* mask_pix[3] >> 8) + ref_pix[0]);
										ref_pix[1] = (uint8)((uint32)(((int)mask_pix[1]-(int)ref_pix[1])
											* mask_pix[3] >> 8) + ref_pix[1]);
										ref_pix[2] = (uint8)((uint32)(((int)mask_pix[2]-(int)ref_pix[2])
											* mask_pix[3] >> 8) + ref_pix[2]);
										ref_pix[3] = (uint8)((uint32)(((int)mask_pix[3]-(int)ref_pix[3])
											* mask_pix[3] >> 8) + ref_pix[3]);
									}
									else if(mask_pix[3] > 0)
									{
										uint8 src_value = mask_pix[3];
										uint8 dst_value = ref_pix[3];
										FLOAT_T src_alpha = src_value * DIV_PIXEL;
										FLOAT_T dst_alpha = dst_value * DIV_PIXEL;
										FLOAT_T div_alpha = src_alpha + dst_alpha*(1-src_alpha);
										if(div_alpha > 0)
										{
											div_alpha = 1 / div_alpha;
											ref_pix[0] = (uint8)(color[0]*src_alpha+(ref_pix[0]*dst_alpha*(1-src_alpha))*div_alpha);
											ref_pix[1] = (uint8)(color[1]*src_alpha+(ref_pix[1]*dst_alpha*(1-src_alpha))*div_alpha);
											ref_pix[2] = (uint8)(color[2]*src_alpha+(ref_pix[2]*dst_alpha*(1-src_alpha))*div_alpha);
										}
									}
								}
							}

							update_r = r * window->zoom_rate;
							update_x = ((draw_x-window->width/2)*window->cos_value + (draw_y-window->height/2)*window->sin_value) * window->zoom_rate
								+ window->rev_add_cursor_x;
							update_y = (- (draw_x-window->width/2)*window->sin_value + (draw_y-window->height/2)*window->cos_value) * window->zoom_rate
								+ window->rev_add_cursor_y;
							gtk_widget_queue_draw_area(window->window, (gint)(update_x-update_r), (gint)(update_y-update_r),
								(gint)(update_r * 2 + BRUSH_UPDATE_MARGIN), (gint)(update_r * 2 + BRUSH_UPDATE_MARGIN));
skip_draw:
							dx -= brush->core.d;
							brush->stamp_distance -= brush->core.d;
							brush->remain_distance += brush->core.d * brush->core.d;
							if(dx < brush->core.d)
							{
								break;
							}
							else
							{
								draw_x += diff_x, draw_y += diff_y;
							}
						} while(1);
					}

					brush->finish_length += d;
					brush->travel += d;
					brush->draw_finished++;
					ref_point = brush->draw_finished % BRUSH_POINT_BUFFER_SIZE;
				}	// while(brush->sum_distance > brush->draw_start
						// && brush->draw_finished < brush->ref_point)
			}	// if(brush->sum_distance >= brush->draw_start
					// && brush->sum_distance >= brush->enter_length)
		}	// if(distance >= 1.0)

		window->flags |= DRAW_WINDOW_UPDATE_PART;
	}	// マウスの左ボタンが押されていたら
		// if(((*(GdkModifierType*)state) & GDK_BUTTON1_MASK) != 0)
}

#define PickerImageBrushEditSelectionMotion PickerImageBrushMotionCallBack

static void PickerImageBrushReleaseCallBack(
	DRAW_WINDOW* window,
	FLOAT_T x,
	FLOAT_T y,
	FLOAT_T pressure,
	BRUSH_CORE *core,
	void* state
)
{
	// マウスの左ボタンなら
	if(((GdkEventButton*)state)->button == 1)
	{
		// ブラシの詳細情報にキャスト
		PICKER_IMAGE_BRUSH *brush = (PICKER_IMAGE_BRUSH*)core->brush_data;
		// 更新範囲のイメージ情報
		cairo_t *update, *update_temp;
		cairo_surface_t *update_surface, *temp_surface;
		// ブラシの半径と不透明度
		FLOAT_T r, alpha;
		// 座標の最大・最小値
		FLOAT_T min_x, min_y, max_x, max_y;
		// X、Y方向の移動量
		FLOAT_T dx, dy;
		// ブラシの傾き用
		FLOAT_T diff_x, diff_y;
		// ブラシの移動量
		FLOAT_T d;
		// 描画を行う座標
		FLOAT_T draw_x, draw_y;
		// 画面更新を行う座標、範囲
		FLOAT_T update_x, update_y, update_r;
		// 入り、抜き時の色補正
		FLOAT_T enter_alpha, out_alpha;
		// 描画色
		uint8 color[4];
		// 平均色計算用
		uint64 sum_color0, sum_color1, sum_color2,
			sum_color3, sum_color4, sum_color5;
		// ピクセルデータをリセットする座標
		int start_x, start_y;
		// 描画する幅、高さ、一行分のバイト数
		int width, height, stride;
		// 作業レイヤーの一行分のバイト数
		int layer_stride = window->work_layer->stride;
		// 作業レイヤーのピクセル
		uint8 *work_pixel = window->work_layer->pixels;
		// 画像に対しての拡大・回転処理用の行列データ
		cairo_matrix_t matrix, reset_matrix;
		// 画像の拡大率
		FLOAT_T zoom;
		// 移動量計算用
		FLOAT_T cos_x, sin_y, trans_x, trans_y;
		// 画像の幅・高さの半分
		FLOAT_T half_width, half_height;
		// 色を抽出するレイヤー
		LAYER *target;
		// 参照ピクセル
		uint8 *mask;
		// 配列のインデックス用
		int ref_point;
		int before_point;
		int i;	// for文用のカウンタ

		ref_point = brush->ref_point % BRUSH_POINT_BUFFER_SIZE;
		brush->points[ref_point][1] = x, brush->points[ref_point][2] = y;
		brush->ref_point++;

		while(brush->ref_point > brush->draw_finished)
		{
			ref_point = brush->draw_finished % BRUSH_POINT_BUFFER_SIZE;

			if(brush->finish_length < brush->enter_length)
			{
				enter_alpha = brush->finish_length / brush->enter_length;
				r = brush->enter_size + brush->finish_length * 0.25;
			}
			else
			{
				enter_alpha = 1;
				r = 1;
			}

			if((brush->core.flags & STAMP_PRESSURE_SIZE) != 0)
			{
				r *= brush->points[ref_point][3];
			}
			if((brush->core.flags & STAMP_RANDOM_SIZE) != 0)
			{
				r *= 1 - (brush->size_range * (rand() / (FLOAT_T)RAND_MAX));
			}
			if(r < MIN_BRUSH_STEP)
			{
				r = MIN_BRUSH_STEP;
			}

			if((brush->core.flags & STAMP_RANDOM_ROTATE) != 0)
			{
				brush->core.rotate = (rand() / (FLOAT_T)RAND_MAX) * (2*G_PI);
			}

			half_width = brush->core.half_width * r;
			half_height = brush->core.half_height * r;
			zoom = (1/r) * brush->core.scale;
			r *= brush->core.r;

			if(brush->sum_distance < brush->draw_start)
			{
				out_alpha = brush->sum_distance / brush->draw_start;
				r -= (brush->draw_start - brush->sum_distance) * 0.25;
			}
			else
			{
				out_alpha = 1;
			}

			if(r < 0.0)
			{
				brush->draw_finished++;
				continue;
			}

			alpha = ((brush->core.flags & BRUSH_FLAG_FLOW) == 0)
				? 1 : brush->points[ref_point][3];
			alpha *= enter_alpha;

			before_point = (ref_point == 0) ? BRUSH_POINT_BUFFER_SIZE - 1 : ref_point - 1;
			d = brush->points[ref_point][0];
			brush->sum_distance -= d;
			if(brush->draw_finished == 0)
			{
				draw_x = brush->points[0][1], draw_y = brush->points[0][2];
			}
			else
			{
				draw_x = brush->points[before_point][1];
				draw_y = brush->points[before_point][2];
			}
			dx = brush->points[ref_point][1] - draw_x;
			dy = brush->points[ref_point][2] - draw_y;

			if((brush->core.flags & STAMP_RANDOM_ROTATE) != 0)
			{
				brush->core.rotate = brush->core.rotate_start +
					(rand() / (FLOAT_T)RAND_MAX) * brush->core.rotate_direction * brush->rotate_range;
				if((brush->core.flags & BRUSH_FLAG_ROTATE) != 0)
				{
					brush->core.rotate += brush->core.rotate_direction * atan2(dy, dx);
				}
			}
			else if((brush->core.flags & BRUSH_FLAG_ROTATE) != 0)
			{
				brush->core.rotate = brush->core.rotate_start + brush->core.rotate_direction * atan2(dy, dx);
			}
			else
			{
				brush->core.rotate = brush->core.rotate_start;
			}
			cos_x = cos(brush->core.rotate), sin_y = sin(brush->core.rotate);
			diff_x = dx/d, diff_y = dy/d;

			min_x = brush->points[ref_point][1] - r - 1;
			max_x = brush->points[ref_point][1] + r + 1;
			min_y = brush->points[ref_point][2] - r - 1;
			max_y = brush->points[ref_point][2] + r + 1;

			if(min_x < 0.0)
			{
				min_x = 0.0;
			}
			if(core->min_x > min_x)
			{
				core->min_x = min_x;
			}
			if(min_y < 0.0)
			{
				min_y = 0.0;
			}
			if(core->min_y > min_y)
			{
				core->min_y = min_y;
			}
			if(max_x > window->work_layer->width)
			{
				max_x = window->work_layer->width;
			}
			if(core->max_x < max_x)
			{
				core->max_x = max_x;
			}
			if(max_y > window->work_layer->height)
			{
				min_y = window->work_layer->height;
			}
			if(core->max_y < max_y)
			{
				core->max_y = max_y;
			}

			if(window->update.x > min_x)
			{
				window->update.width += window->update.x - (int)min_x;
				window->update.x = (int)min_x;
			}
			if(window->update.width + window->update.x < max_x)
			{
				window->update.width += (int)max_x - window->update.width + window->update.x;
			}
			if(window->update.y > min_y)
			{
				window->update.height += window->update.y - (int)min_y;
				window->update.y = (int)min_y;
			}
			if(window->update.height + window->update.y < max_y)
			{
				window->update.height += (int)max_y - window->update.height + window->update.y;
			}

			if(brush->stamp_distance > brush->core.d || brush->draw_finished == 0)
			{
				dx = d;
				do
				{
					if(draw_x < 0 || draw_x >= window->width
						|| draw_y < 0 || draw_y >= window->height)
					{
						dx = 0;
						goto skip_draw;
					}

					start_x = (int)(draw_x - r);
					start_y = (int)(draw_y - r);
					width = (int)(draw_x + r);
					height = (int)(draw_y + r);

					if(start_x < 0)
					{
						start_x = 0;
					}
					else if(start_x > window->work_layer->width)
					{
						goto skip_draw;
					}
					if(start_y < 0)
					{
						start_y = 0;
					}
					else if(start_y > window->work_layer->height)
					{
						goto skip_draw;
					}
					if(width > window->work_layer->width)
					{
						width = window->work_layer->width - start_x;
					}
					else
					{
						width = width - start_x;
					}
					if(height > window->work_layer->height)
					{
						height = window->work_layer->height - start_y;
					}
					else
					{
						height = height - start_y;
					}

					if(width < 0 || height < 0)
					{
						goto skip_draw;
					}

					stride = width*4;

					update_surface = cairo_surface_create_for_rectangle(
						window->mask_temp->surface_p, draw_x - r, draw_y - r, r*2+1, r*2+1);
					update = cairo_create(update_surface);

					for(i=0; i<height; i++)
					{
						(void)memset(&window->mask_temp->pixels[(i+start_y)*window->mask_temp->stride+start_x*4],
							0, stride);
					}

					trans_x = r - (half_width * cos_x + half_height * sin_y);
					trans_y = r + (half_width * sin_y - half_height * cos_x);

					// 行列データに拡大・縮小、回転角をセット
					cairo_set_operator(window->mask_temp->cairo_p, CAIRO_OPERATOR_OVER);
					cairo_matrix_init_scale(&matrix, zoom, zoom);
					cairo_matrix_rotate(&matrix, brush->core.rotate);
					cairo_matrix_translate(&matrix, - trans_x, - trans_y);

					mask = window->mask_temp->pixels;
					if((window->flags & DRAW_WINDOW_HAS_SELECTION_AREA) == 0)
					{
						if((window->active_layer->flags & LAYER_LOCK_OPACITY) == 0)
						{
							cairo_set_source(update, core->brush_pattern);
							cairo_pattern_set_matrix(core->brush_pattern, &matrix);
							cairo_paint_with_alpha(update, alpha);
						}
						else
						{
							cairo_pattern_set_matrix(core->brush_pattern, &reset_matrix);
							cairo_set_source(core->temp_cairo, core->brush_pattern);
							cairo_paint_with_alpha(core->temp_cairo, alpha);
							cairo_set_source(update, core->temp_pattern);
							cairo_pattern_set_matrix(core->temp_pattern, &matrix);
							cairo_mask_surface(update,
								window->active_layer->surface_p, - draw_x + r, - draw_y + r);
						}
					}
					else
					{
						if((window->active_layer->flags & LAYER_LOCK_OPACITY) == 0)
						{
							cairo_pattern_set_matrix(core->brush_pattern, &reset_matrix);
							cairo_set_source(core->temp_cairo, core->brush_pattern);
							cairo_paint_with_alpha(core->temp_cairo, alpha);
							cairo_set_source(update, core->temp_pattern);
							cairo_pattern_set_matrix(core->temp_pattern, &matrix);
							cairo_mask_surface(update,
								window->selection->surface_p, - draw_x + r, - draw_y + r);
						}
						else
						{
							temp_surface = cairo_surface_create_for_rectangle(
								window->temp_layer->surface_p, draw_x-r, draw_y-r, r*2+1, r*2+1
							);
							update_temp = cairo_create(temp_surface);

							for(i=0; i<height; i++)
							{
								(void)memset(&window->temp_layer->pixels[
									(i+start_y)*window->temp_layer->stride+start_x*4],
									0, stride
								);
							}

							cairo_pattern_set_matrix(core->brush_pattern, &reset_matrix);
							cairo_set_source(core->temp_cairo, core->brush_pattern);
							cairo_paint_with_alpha(core->temp_cairo, alpha);
							cairo_set_source(update, core->temp_pattern);
							cairo_mask_surface(update,
								window->selection->surface_p, - draw_x + r, - draw_y + r);
							cairo_set_source_surface(update_temp,
								update_surface, 0, 0);
							cairo_mask_surface(update_temp,
								window->active_layer->surface_p, - draw_x + r, - draw_y + r);

							mask = window->temp_layer->pixels;

							cairo_surface_destroy(temp_surface);
							cairo_destroy(update_temp);
						}
					}

					// テクスチャを適用
					if(window->app->textures.active_texture != 0)
					{
						temp_surface = cairo_surface_create_for_rectangle(
							window->temp_layer->surface_p, draw_x - r, draw_y - r, r*2+1, r*2+1);
						update_temp = cairo_create(temp_surface);

						if(mask == window->mask_temp->pixels)
						{
							for(i=0; i<height; i++)
							{
								(void)memset(&window->temp_layer->pixels[
									(i+start_y)*window->temp_layer->stride+start_x*4],
									0, stride
								);
							}
							cairo_set_source_surface(update_temp,
								update_surface, 0, 0);
							cairo_mask_surface(update_temp, window->texture->surface_p, - draw_x + r, - draw_y + r);
							mask = window->temp_layer->pixels;
						}
						else
						{
							for(i=0; i<height; i++)
							{
								(void)memset(&window->mask_temp->pixels[
									(i+start_y)*window->mask_temp->stride+start_x*4],
									0, stride
								);
							}
							cairo_set_source_surface(update,
								temp_surface, 0, 0);
							cairo_mask_surface(update, window->texture->surface_p, - draw_x + r, - draw_y + r);
							mask = window->mask_temp->pixels;
						}

						cairo_surface_destroy(temp_surface);
						cairo_destroy(update_temp);
					}

					if(brush->picker_source == COLOR_PICKER_SOURCE_ACTIVE_LAYER)
					{
						(void)memcpy(window->mask_temp->pixels, window->active_layer->pixels,
							window->pixel_buf_size);
						target = window->mask_temp;
						window->layer_blend_functions[brush->blend_mode](window->work_layer, target);
					}
					else
					{
						target = window->mixed_layer;
					}

					if(brush->picker_mode == PICKER_MODE_SINGLE_PIXEL)
					{
						int int_x = (int)x, int_y = (int)y;
						color[0] = target->pixels[target->stride*int_y+int_x*4];
						color[1] = target->pixels[target->stride*int_y+int_x*4+1];
						color[2] = target->pixels[target->stride*int_y+int_x*4+2];
						color[3] = target->pixels[target->stride*int_y+int_x*4+3];
					}
					else
					{
						sum_color0 = sum_color1 = sum_color2 = sum_color4 = 0;
						sum_color3 = sum_color5 = 1;

#ifdef _OPENMP
#pragma omp parallel for reduction( +: sum_color0, sum_color1, sum_color2, sum_color3, sum_color4, sum_color5) firstprivate(mask, start_x, start_y, layer_stride, width)
#endif
						for(i=0; i<height; i++)
						{
							uint8 *ref_pix = &target->pixels[(i+start_y)*target->stride+start_x*4];
							uint8 *mask_pix = &mask[(i+start_y)*layer_stride+start_x*4+3];
							int j;

							for(j=0; j<width; j++, ref_pix+=4, mask_pix+=4)
							{
								sum_color0 += ((ref_pix[0]+1) * *mask_pix * ref_pix[3]) >> 8;
								sum_color1 += ((ref_pix[1]+1) * *mask_pix * ref_pix[3]) >> 8;
								sum_color2 += ((ref_pix[2]+1) * *mask_pix * ref_pix[3]) >> 8;
								sum_color3 += ((ref_pix[3]+1) * *mask_pix) >> 8;
								sum_color4 += ref_pix[3] * *mask_pix;
								sum_color5 += *mask_pix;
							}
						}

						color[0] = (uint8)((sum_color0 + sum_color3 / 2) / sum_color3);
						color[1] = (uint8)((sum_color1 + sum_color3 / 2) / sum_color3);
						color[2] = (uint8)((sum_color2 + sum_color3 / 2) / sum_color3);
						color[3] = (uint8)(sum_color4 / sum_color5);
					}

					// 色調整
					if((brush->flags & PICKER_FLAG_CHANGE_HSV) != 0)
					{
						HSV hsv;
						int s, v;
#if defined(USE_BGR_COLOR_SPACE) && USE_BGR_COLOR_SPACE != 0
						uint8 r;
						r = color[2];
						color[2] = color[0];
						color[0] = r;
#endif
						RGB2HSV_Pixel(color, &hsv);
						hsv.h += brush->add_h;
						s = hsv.s, v = hsv.v;
						if(hsv.h < 0)
						{
							hsv.h += 360;
						}
						else if(hsv.h >= 360)
						{
							hsv.h -= 360;
						}
						s += brush->add_s;
						if(s < 0)
						{
							s = 0;
						}
						else if(s > 255)
						{
							s = 255;
						}
						hsv.s = (uint8)s;

						v += brush->add_v;
						if(v < 0)
						{
							v = 0;
						}
						else if(v > 255)
						{
							v = 255;
						}
						hsv.v = (uint8)v;
						HSV2RGB_Pixel(&hsv, color);
#if defined(USE_BGR_COLOR_SPACE) && USE_BGR_COLOR_SPACE != 0
						r = color[2];
						color[2] = color[0];
						color[0] = r;
#endif
					}

					cairo_surface_destroy(update_surface);
					cairo_destroy(update);

					if(mask == window->mask_temp->pixels)
					{
						temp_surface = cairo_surface_create_for_rectangle(
							window->mask_temp->surface_p, draw_x - r, draw_y - r, r*2+1, r*2+1);
						update_surface = cairo_surface_create_for_rectangle(
							window->temp_layer->surface_p, draw_x - r, draw_y - r, r*2+1, r*2+1);
						mask = window->temp_layer->pixels;
					}
					else
					{
						temp_surface = cairo_surface_create_for_rectangle(
							window->temp_layer->surface_p, draw_x - r, draw_y - r, r*2+1, r*2+1);
						update_surface = cairo_surface_create_for_rectangle(
							window->mask_temp->surface_p, draw_x - r, draw_y - r, r*2+1, r*2+1);
						mask = window->mask_temp->pixels;
					}
					update = cairo_create(update_surface);
					for(i=0; i<height; i++)
					{
						(void)memset(&mask[(start_y+i)*window->stride+start_x*4], 0, stride);
					}
#if defined(USE_BGR_COLOR_SPACE) && USE_BGR_COLOR_SPACE != 0
					cairo_set_source_rgba(update, color[2]*DIV_PIXEL,
						color[1]*DIV_PIXEL, color[0]*DIV_PIXEL, color[3]*DIV_PIXEL);
#else
					cairo_set_source_rgba(update, color[0]*DIV_PIXEL,
						color[1]*DIV_PIXEL, color[2]*DIV_PIXEL, color[3]*DIV_PIXEL);
#endif
					cairo_mask_surface(update, temp_surface, 0, 0);

					cairo_destroy(update);
					cairo_surface_destroy(temp_surface);
					cairo_surface_destroy(update_surface);

#ifdef _OPENMP
#pragma omp parallel for firstprivate(work_pixel, width, layer_stride, start_x, start_y, mask)
#endif
					for(i=0; i<height; i++)
					{
						uint8 *ref_pix = &work_pixel[
							(start_y+i)*layer_stride+start_x*4];
						uint8 *mask_pix = &mask[(start_y+i)*layer_stride
							+start_x*4];
						int j;

						for(j=0; j<width; j++, ref_pix+=4, mask_pix+=4)
						{
							if(ref_pix[3] < mask_pix[3])
							{
								ref_pix[0] = (uint8)((uint32)(((int)mask_pix[0]-(int)ref_pix[0])
									* mask_pix[3] >> 8) + ref_pix[0]);
								ref_pix[1] = (uint8)((uint32)(((int)mask_pix[1]-(int)ref_pix[1])
									* mask_pix[3] >> 8) + ref_pix[1]);
								ref_pix[2] = (uint8)((uint32)(((int)mask_pix[2]-(int)ref_pix[2])
									* mask_pix[3] >> 8) + ref_pix[2]);
								ref_pix[3] = (uint8)((uint32)(((int)mask_pix[3]-(int)ref_pix[3])
									* mask_pix[3] >> 8) + ref_pix[3]);
							}
							else if(mask_pix[3] > 0)
							{
								uint8 src_value = mask_pix[3];
								uint8 dst_value = ref_pix[3];
								FLOAT_T src_alpha = src_value * DIV_PIXEL;
								FLOAT_T dst_alpha = dst_value * DIV_PIXEL;
								FLOAT_T div_alpha = src_alpha + dst_alpha*(1-src_alpha);
								if(div_alpha > 0)
								{
									div_alpha = 1 / div_alpha;
									ref_pix[0] = (uint8)(color[0]*src_alpha+(ref_pix[0]*dst_alpha*(1-src_alpha))*div_alpha);
									ref_pix[1] = (uint8)(color[1]*src_alpha+(ref_pix[1]*dst_alpha*(1-src_alpha))*div_alpha);
									ref_pix[2] = (uint8)(color[2]*src_alpha+(ref_pix[2]*dst_alpha*(1-src_alpha))*div_alpha);
								}
							}
						}
					}

					update_r = r * window->zoom_rate;
					update_x = ((draw_x-window->width/2)*window->cos_value + (draw_y-window->height/2)*window->sin_value) * window->zoom_rate
						+ window->rev_add_cursor_x;
					update_y = (- (draw_x-window->width/2)*window->sin_value + (draw_y-window->height/2)*window->cos_value) * window->zoom_rate
						+ window->rev_add_cursor_y;
					gtk_widget_queue_draw_area(window->window, (gint)(update_x-update_r), (gint)(update_y-update_r),
						(gint)(update_r * 2 + BRUSH_UPDATE_MARGIN), (gint)(update_r * 2 + BRUSH_UPDATE_MARGIN));
skip_draw:
					dx -= brush->core.d;
					brush->stamp_distance -= brush->core.d;
					if(dx < brush->core.d)
					{
						break;
					}
					else
					{
						draw_x += diff_x, draw_y += diff_y;
					}
				} while(1);
			}

			brush->finish_length += d;
			brush->travel += d;
			brush->draw_finished++;
			ref_point = brush->draw_finished % BRUSH_POINT_BUFFER_SIZE;
		}	// while(brush->ref_point > brush->draw_finished)

		AddBrushHistory(core, window->active_layer);

		window->update.surface_p = cairo_surface_create_for_rectangle(
			window->active_layer->surface_p, window->update.x, window->update.y,
				window->update.width, window->update.height);
		window->update.cairo_p = cairo_create(window->update.surface_p);
		window->part_layer_blend_functions[window->work_layer->layer_mode](window->work_layer, &window->update);
		cairo_destroy(window->update.cairo_p);
		cairo_surface_destroy(window->update.surface_p);

		(void)memset(window->work_layer->pixels, 0, window->work_layer->stride*window->work_layer->height);

		window->work_layer->layer_mode = LAYER_BLEND_NORMAL;

		brush->core.rotate = brush->core.rotate_start;

		window->flags |= DRAW_WINDOW_UPDATE_PART;
	}	// マウスの左ボタンなら
		// if(((GdkEventButton*)state)->button == 1)
}

static void PickerImageBrushDrawCursor(
	DRAW_WINDOW* window,
	FLOAT_T x,
	FLOAT_T y,
	void* data
)
{
	StampCoreDrawCursor(window, x, y, &((PICKER_IMAGE_BRUSH*)data)->core);
}

static void PickerImageBrushButtonUpdate(DRAW_WINDOW* window, FLOAT_T x, FLOAT_T y, PICKER_IMAGE_BRUSH* brush)
{
	FLOAT_T r;

	if(brush->core.half_width > brush->core.half_height)
	{
		r = brush->core.half_width * 2 * window->zoom_rate + 1;
	}
	else
	{
		r = brush->core.half_height * 2 * window->zoom_rate + 1;
	}

	gtk_widget_queue_draw_area(window->window, (gint)(x - r - 1),
		(gint)(y - r - 1), (gint)(r * 2) + 2, (gint)(r * 2) + 2);
}

static void PickerImageBrushMotionUpdate(DRAW_WINDOW* window, FLOAT_T x, FLOAT_T y, PICKER_IMAGE_BRUSH* brush)
{
	FLOAT_T start_x, start_y;
	FLOAT_T width, height;
	FLOAT_T r;
	FLOAT_T enter = (brush->enter_length + brush->draw_start) * window->zoom_rate;

	if(brush->core.half_width > brush->core.half_height)
	{
		r = brush->core.half_width * 2 * window->zoom_rate + 1;
	}
	else
	{
		r = brush->core.half_height * 2 * window->zoom_rate + 1;
	}

	if(window->before_cursor_x < x)
	{
		start_x = window->before_cursor_x - r;
		width = r * 2 + x - window->before_cursor_x;
	}
	else
	{
		start_x = x - r;
		width = r * 2 + window->before_cursor_x - x;
	}

	if(window->before_cursor_y < y)
	{
		start_y = window->before_cursor_y - r;
		height = r * 2 + y - window->before_cursor_y;
	}
	else
	{
		start_y = y - r;
		height = r * 2 + window->before_cursor_y - y;
	}

	start_x -= enter * 4;
	width += enter * 4 * 2 + 2;
	start_y -= enter * 4;
	height += enter * 4 * 2 + 2;

	gtk_widget_queue_draw_area(window->window,
		(gint)start_x, (gint)start_y, (gint)width, (gint)height);
}

static void PickerImageBrushSetEnter(GtkAdjustment* slider, PICKER_IMAGE_BRUSH* brush)
{
	brush->enter = gtk_adjustment_get_value(slider);
}

static void PickerImageBrushSetOut(GtkAdjustment* slider, PICKER_IMAGE_BRUSH* brush)
{
	brush->out = gtk_adjustment_get_value(slider);
}

static void PickerImageBrushSetBlendMode(GtkComboBox* combo, PICKER_IMAGE_BRUSH* brush)
{
	brush->blend_mode = (uint16)gtk_combo_box_get_active(combo);
}

static void PickerImageBrushSetRotate2Direction(GtkWidget* button, PICKER_IMAGE_BRUSH* brush)
{
	if(gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(button)) == FALSE)
	{
		brush->core.flags &= ~(BRUSH_FLAG_ROTATE);
	}
	else
	{
		brush->core.flags |= BRUSH_FLAG_ROTATE;
	}
}

static void PickerImageBrushSetRotateDirection(GtkWidget* button, PICKER_IMAGE_BRUSH* brush)
{
	if(gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(button)) != FALSE)
	{
		brush->core.rotate_direction = GPOINTER_TO_INT(g_object_get_data(
			G_OBJECT(button), "rotate_direction"));
	}
}

static void PickerImageBrushSetAddHue(GtkAdjustment* slider, PICKER_IMAGE_BRUSH* brush)
{
	brush->add_h = (int)gtk_adjustment_get_value(slider);

	if(brush->add_h == 0 && brush->add_s == 0 && brush->add_v == 0)
	{
		brush->flags &= ~(PICKER_FLAG_CHANGE_HSV);
	}
	else
	{
		brush->flags |= PICKER_FLAG_CHANGE_HSV;
	}
}

static void PickerImageBrushSetAddSaturation(GtkAdjustment* slider, PICKER_IMAGE_BRUSH* brush)
{
	brush->add_s = (int)(gtk_adjustment_get_value(slider) * 2.552);

	if(brush->add_h == 0 && brush->add_s == 0 && brush->add_v == 0)
	{
		brush->flags &= ~(PICKER_FLAG_CHANGE_HSV);
	}
	else
	{
		brush->flags |= PICKER_FLAG_CHANGE_HSV;
	}
}

static void PickerImageBrushSetAddVivid(GtkAdjustment* slider, PICKER_IMAGE_BRUSH* brush)
{
	brush->add_v = (int)(gtk_adjustment_get_value(slider) * 2.552);

	if(brush->add_h == 0 && brush->add_s == 0 && brush->add_v == 0)
	{
		brush->flags &= ~(PICKER_FLAG_CHANGE_HSV);
	}
	else
	{
		brush->flags |= PICKER_FLAG_CHANGE_HSV;
	}
}

static void PickerImageBrushSetPickTarget(GtkWidget* button, PICKER_IMAGE_BRUSH* brush)
{
	int mode = GPOINTER_TO_INT(g_object_get_data(G_OBJECT(button), "pick_target"));
	if(gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(button)) != FALSE)
	{
		brush->picker_source = (uint8)mode;
	}
}

static void PickerImageBrushSetPickMode(GtkWidget* button, PICKER_IMAGE_BRUSH* brush)
{
	int mode = GPOINTER_TO_INT(g_object_get_data(G_OBJECT(button), "pick_mode"));
	if(gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(button)) != FALSE)
	{
		brush->picker_mode = (uint8)mode;
	}
}

static void PickerImageBrushSetSizeRange(GtkAdjustment* slider, PICKER_IMAGE_BRUSH* brush)
{
	brush->size_range = gtk_adjustment_get_value(slider) * 0.01;
}


static void PickerImageBrushSetRotateRange(GtkAdjustment* slider, PICKER_IMAGE_BRUSH* brush)
{
	brush->random_rotate_range = (int16)gtk_adjustment_get_value(slider);
	brush->rotate_range = brush->random_rotate_range * G_PI / 180;
}

static GtkWidget* CreatePickerImageBrushDetailUI(APPLICATION* app, BRUSH_CORE* brush_core)
{
#define UI_FONT_SIZE 8.0
#define ICON_SIZE 32
	PICKER_IMAGE_BRUSH *brush = (PICKER_IMAGE_BRUSH*)brush_core->brush_data;
	STAMP_CORE *core = &brush->core;
	GtkWidget *vbox = gtk_vbox_new(FALSE, 0);
	GtkWidget *hbox;
	// ラベル、スライダ
	GtkWidget* label, *scale;
	// スクロールドウィンドウ
	GtkWidget* scrolled_window;
	// ウィジェット整列用のテーブル
	GtkWidget* table;
	// 回転方向、モード設定用のラジオボタン
	GtkWidget* radio_buttons[PATTERN_MODE_NUM];
	// 筆圧使用設定のチェックボックス
	GtkWidget* check_button;
	// 合成モード選択用のコンボボックス
	GtkWidget* combo;
	// スライダに使用するアジャスタ
	GtkAdjustment* scale_adjustment;
	// ラベルのフォント変更用のマークアップバッファ
	char mark_up_buff[256];
	int i;	// for文用のカウンタ

	// アプリケーション管理の構造体へのポインタをセット
	core->app = app;

	// クリップボードのパターンを更新
	UpdateClipBoardPattern(&app->stamps);

	// 拡大縮小率設定用のウィジェット
	scale_adjustment = GTK_ADJUSTMENT(gtk_adjustment_new(
		(1 / core->scale) * 100, 10, 300, 0.1, 0.1, 0));
	scale = SpinScaleNew(scale_adjustment,
		app->labels->tool_box.brush_scale, 1);
	(void)g_signal_connect(G_OBJECT(scale_adjustment), "value_changed",
		G_CALLBACK(StampCoreChangeScale), core);
	g_object_set_data(G_OBJECT(scale_adjustment), "application", app);
	gtk_box_pack_start(GTK_BOX(vbox), scale, FALSE, FALSE, 0);

	// 濃度変更用ウィジェット
	scale_adjustment = GTK_ADJUSTMENT(gtk_adjustment_new(
		core->flow * 100, 0, 100, 0.1, 0.1, 0));
	scale = SpinScaleNew(scale_adjustment,
		app->labels->tool_box.flow, 1);
	g_object_set_data(G_OBJECT(scale_adjustment), "application", app);
	(void)g_signal_connect(G_OBJECT(scale_adjustment), "value_changed",
		G_CALLBACK(StampCoreChangeFlow), core);
	table = gtk_table_new(1, 3, TRUE);
	gtk_table_attach_defaults(GTK_TABLE(table), scale, 0, 3, 0, 1);
	gtk_box_pack_start(GTK_BOX(vbox), table, FALSE, TRUE, 0);

	// 開始回転角変更用ウィジェット
	scale_adjustment = GTK_ADJUSTMENT(gtk_adjustment_new(
		fabs(core->rotate_start) * 180 / G_PI, 0, 360, 0.1, 0.1, 0));
	scale = SpinScaleNew(scale_adjustment,
		app->labels->tool_box.rotate_start, 1);
	g_object_set_data(G_OBJECT(scale_adjustment), "application", app);
	(void)g_signal_connect(G_OBJECT(scale_adjustment), "value_changed",
		G_CALLBACK(StampCoreChangeRotateStart), core);
	gtk_box_pack_start(GTK_BOX(vbox), scale, FALSE, FALSE, 0);

	// 間隔変更用ウィジェット
	scale_adjustment = GTK_ADJUSTMENT(gtk_adjustment_new(
		core->stamp_distance, 0.1, 3, 0.1, 0.1, 0));
	scale = SpinScaleNew(scale_adjustment,
		app->labels->tool_box.distance, 1);
	(void)g_signal_connect(G_OBJECT(scale_adjustment), "value_changed",
		G_CALLBACK(StampCoreChangeDistance), core);
	g_object_set_data(G_OBJECT(scale_adjustment), "application", app);
	gtk_box_pack_start(GTK_BOX(vbox), scale, FALSE, FALSE, 0);

	// 左右反転、上下反転選択用チェックボックス
	table = gtk_hbox_new(FALSE, 0);
	label = gtk_label_new("");
	(void)sprintf(mark_up_buff, "<span font_desc=\"%.2f\">%s : </span>",
		UI_FONT_SIZE * app->gui_scale, app->labels->tool_box.reverse);
	gtk_label_set_markup(GTK_LABEL(label), mark_up_buff);
	gtk_box_pack_start(GTK_BOX(table), label, FALSE, FALSE, 0);
	check_button = gtk_check_button_new_with_label(app->labels->tool_box.reverse_horizontally);
	g_object_set_data(G_OBJECT(check_button), "flag-id", GINT_TO_POINTER(0));
	g_object_set_data(G_OBJECT(check_button), "application", app);
	gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(check_button),
		core->pattern_flags & PATTERN_FLIP_HORIZONTALLY);
	(void)g_signal_connect(G_OBJECT(check_button), "toggled", G_CALLBACK(StampCoreSetPatternFlags), core);
	gtk_box_pack_start(GTK_BOX(table), check_button, FALSE, TRUE, 0);
	check_button = gtk_check_button_new_with_label(app->labels->tool_box.reverse_vertically);
	g_object_set_data(G_OBJECT(check_button), "flag-id", GINT_TO_POINTER(1));
	g_object_set_data(G_OBJECT(check_button), "application", app);
	gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(check_button),
		core->pattern_flags & PATTERN_FLIP_VERTICALLY);
	(void)g_signal_connect(G_OBJECT(check_button), "toggled", G_CALLBACK(StampCoreSetPatternFlags), core);
	gtk_box_pack_start(GTK_BOX(table), check_button, FALSE, TRUE, 0);
	gtk_box_pack_start(GTK_BOX(vbox), table, FALSE, TRUE, 0);

	// 回転方向変更用ウィジェット
	radio_buttons[0] = gtk_radio_button_new_with_label(NULL, app->labels->tool_box.clockwise);
	radio_buttons[1] = gtk_radio_button_new_with_label(
		gtk_radio_button_get_group(GTK_RADIO_BUTTON(radio_buttons[0])),
		app->labels->tool_box.counter_clockwise
	);

	if(core->rotate_direction < 0)
	{
		gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(radio_buttons[0]), TRUE);
	}
	else
	{
		gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(radio_buttons[1]), TRUE);
	}

	table = gtk_hbox_new(FALSE, 0);
	g_object_set_data(G_OBJECT(radio_buttons[0]), "rotate_direction", GINT_TO_POINTER(1));
	g_object_set_data(G_OBJECT(radio_buttons[1]), "rotate_direction", GINT_TO_POINTER(-1));
	(void)g_signal_connect(G_OBJECT(radio_buttons[0]), "toggled",
		G_CALLBACK(ImageBrushSetRotateDirection), brush);
	(void)g_signal_connect(G_OBJECT(radio_buttons[1]), "toggled",
		G_CALLBACK(ImageBrushSetRotateDirection), brush);
	gtk_box_pack_start(GTK_BOX(table), radio_buttons[0], FALSE, TRUE, 0);
	gtk_box_pack_start(GTK_BOX(table), radio_buttons[1], FALSE, TRUE, 0);
	gtk_box_pack_start(GTK_BOX(vbox), table, FALSE, TRUE, 0);

	// 詳細設定のUIが閉じられるときにボタン配列を開放する
	(void)g_signal_connect(G_OBJECT(vbox), "destroy", G_CALLBACK(OnStampDetailUIDestroy), core);

	// スタンプ選択テーブルを作成してスクロールドウィンドウに入れる
	table = gtk_hbox_new(FALSE, 0);
	scrolled_window = gtk_scrolled_window_new(NULL, NULL);
	gtk_widget_set_size_request(table,
		ICON_SIZE*STAMP_SELECT_TABLE_WIDTH+4, ICON_SIZE*4+4);
	gtk_scrolled_window_add_with_viewport(GTK_SCROLLED_WINDOW(scrolled_window),
		CreateStampSelectTable(core));
	gtk_scrolled_window_set_policy(GTK_SCROLLED_WINDOW(scrolled_window),
		GTK_POLICY_NEVER, GTK_POLICY_AUTOMATIC);
	gtk_box_pack_start(GTK_BOX(table), scrolled_window, FALSE, FALSE, 0);
	gtk_box_pack_start(GTK_BOX(vbox), table, FALSE, TRUE, 0);

	// クリップボードのスタンプがアクティブならばセット
	if(app->stamps.has_clip_board_pattern != FALSE)
	{
		if(core->stamp_id == 0)
		{
			app->stamps.active_pattern =
				&app->stamps.clip_board;
		}
		else
		{
			app->stamps.active_pattern =
				&app->stamps.patterns[core->stamp_id-1];
		}
	}

	// アクティブなパターンがチャンネル数2以外ならば着色モードは無効
	gtk_widget_set_sensitive(core->mode_select[0], app->stamps.active_pattern->channel == 2);
	gtk_widget_set_sensitive(core->mode_select[1], app->stamps.active_pattern->channel == 2);
	gtk_widget_set_sensitive(core->mode_select[2], app->stamps.active_pattern->channel == 2);

	InitializeStampCore(core, PATTERN_MODE_SATURATION, app);

	table = gtk_hbox_new(FALSE, 0);
	label = gtk_label_new("");
#if GTK_MAJOR_VERSION <= 2
	combo = gtk_combo_box_new_text();
#else
	combo = gtk_combo_box_text_new();
#endif
	(void)sprintf(mark_up_buff, "<span font_desc=\"%.2f\">%s : </span>",
		UI_FONT_SIZE * app->gui_scale, app->labels->layer_window.blend_mode);
	gtk_label_set_markup(GTK_LABEL(label), mark_up_buff);
	gtk_box_pack_start(GTK_BOX(table), label, FALSE, FALSE, 0);
	for(i=0; i<LAYER_BLEND_SLELECTABLE_NUM; i++)
	{
#if GTK_MAJOR_VERSION <= 2
		gtk_combo_box_append_text(GTK_COMBO_BOX(combo), app->labels->layer_window.blend_modes[i]);
#else
		gtk_combo_box_text_append_text(GTK_COMBO_BOX_TEXT(combo), app->labels->layer_window.blend_modes[i]);
#endif
	}
	gtk_combo_box_set_active(GTK_COMBO_BOX(combo), brush->blend_mode);
	(void)g_signal_connect(G_OBJECT(combo), "changed",
		G_CALLBACK(ImageBrushSetBlendMode), brush);
	gtk_box_pack_start(GTK_BOX(table), combo, FALSE, TRUE, 0);
	gtk_box_pack_start(GTK_BOX(vbox), table, FALSE, TRUE, 0);

	scale_adjustment = GTK_ADJUSTMENT(gtk_adjustment_new(brush->enter, 0, 100, 1, 1, 0));
	scale = SpinScaleNew(scale_adjustment,
		app->labels->tool_box.enter, 1);
	(void)g_signal_connect(G_OBJECT(scale_adjustment), "value_changed",
		G_CALLBACK(ImageBrushSetEnter), core);
	gtk_box_pack_start(GTK_BOX(vbox), scale, FALSE, FALSE, 0);

	scale_adjustment = GTK_ADJUSTMENT(gtk_adjustment_new(brush->out, 0, 100, 1, 1, 0));
	scale = SpinScaleNew(scale_adjustment,
		app->labels->tool_box.out, 1);
	(void)g_signal_connect(G_OBJECT(scale_adjustment), "value_changed",
		G_CALLBACK(ImageBrushSetOut), core);
	gtk_box_pack_start(GTK_BOX(vbox), scale, FALSE, FALSE, 0);

	// 筆圧使用設定変更用ウィジェット
	table = gtk_hbox_new(FALSE, 0);
	label = gtk_label_new("");
	(void)sprintf(mark_up_buff, "<span font_desc=\"%.2f\">%s : </span>",
		UI_FONT_SIZE * app->gui_scale, app->labels->tool_box.pressure);
	gtk_label_set_markup(GTK_LABEL(label), mark_up_buff);
	gtk_box_pack_start(GTK_BOX(table), label, FALSE, FALSE, 0);
	check_button = gtk_check_button_new_with_label(app->labels->tool_box.scale);
	g_object_set_data(G_OBJECT(check_button), "flag-id", GINT_TO_POINTER(0));
	gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(check_button), core->flags & BRUSH_FLAG_SIZE);
	(void)g_signal_connect(G_OBJECT(check_button), "toggled", G_CALLBACK(StampCoreSetFlags), core);
	gtk_box_pack_start(GTK_BOX(table), check_button, FALSE, TRUE, 0);
	check_button = gtk_check_button_new_with_label(app->labels->tool_box.flow);
	g_object_set_data(G_OBJECT(check_button), "flag-id", GINT_TO_POINTER(1));
	gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(check_button), core->flags & BRUSH_FLAG_FLOW);
	(void)g_signal_connect(G_OBJECT(check_button), "toggled", G_CALLBACK(StampCoreSetFlags), core);
	gtk_box_pack_start(GTK_BOX(table), check_button, FALSE, TRUE, 0);
	gtk_box_pack_start(GTK_BOX(vbox), table, FALSE, FALSE, 0);
	check_button = gtk_check_button_new_with_label(app->labels->tool_box.random_size);
	g_object_set_data(G_OBJECT(check_button), "flag-value", GUINT_TO_POINTER(STAMP_RANDOM_SIZE));
	g_object_set_data(G_OBJECT(check_button), "application", app);
	gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(check_button), core->flags & STAMP_RANDOM_SIZE);
	(void)g_signal_connect(G_OBJECT(check_button), "toggled", G_CALLBACK(StampCoreSetFlag), core);
	gtk_box_pack_start(GTK_BOX(vbox), check_button, FALSE, TRUE, 0);

	// ブラシの移動方向へ回転
	check_button = gtk_check_button_new_with_label(app->labels->tool_box.rotate_to_brush_direction);
	gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(check_button),
		brush->core.flags & BRUSH_FLAG_ROTATE);
	(void)g_signal_connect(G_OBJECT(check_button), "toggled",
		G_CALLBACK(ImageBrushSetRotate2Direction), brush);
	gtk_box_pack_start(GTK_BOX(vbox), check_button, FALSE, FALSE, 0);

	// ランダムに回転
	check_button = gtk_check_button_new_with_label(app->labels->tool_box.random_rotate);
	gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(check_button), (core->flags & STAMP_RANDOM_ROTATE) != 0);
	g_object_set_data(G_OBJECT(check_button), "flag-value", GUINT_TO_POINTER(STAMP_RANDOM_ROTATE));
	g_object_set_data(G_OBJECT(check_button), "application", app);
	(void)g_signal_connect(G_OBJECT(check_button), "toggled", G_CALLBACK(StampCoreSetFlag), core);
	gtk_box_pack_start(GTK_BOX(vbox), check_button, FALSE, TRUE, 0);

	// 色調整
	scale_adjustment = GTK_ADJUSTMENT(gtk_adjustment_new(
		brush->add_h, -180.0, 180.0, 1.0, 1.0, 0.0));
	(void)g_signal_connect(G_OBJECT(scale_adjustment), "value_changed",
		G_CALLBACK(PickerImageBrushSetAddHue), brush);
	scale = SpinScaleNew(scale_adjustment, app->labels->tool_box.hue, 1);
	gtk_box_pack_start(GTK_BOX(vbox), scale, FALSE, FALSE, 0);

	scale_adjustment = GTK_ADJUSTMENT(gtk_adjustment_new(
		(brush->add_s/255.0)*100, 0.0, 100.0, 1.0, 1.0, 0.0));
	(void)g_signal_connect(G_OBJECT(scale_adjustment), "value_changed",
		G_CALLBACK(PickerImageBrushSetAddSaturation), brush);
	scale = SpinScaleNew(scale_adjustment, app->labels->tool_box.saturation, 1);
	gtk_box_pack_start(GTK_BOX(vbox), scale, FALSE, FALSE, 0);

	scale_adjustment = GTK_ADJUSTMENT(gtk_adjustment_new(
		(brush->add_h/255.0)*100, 0.0, 100.0, 1.0, 1.0, 0.0));
	(void)g_signal_connect(G_OBJECT(scale_adjustment), "value_changed",
		G_CALLBACK(PickerImageBrushSetAddVivid), brush);
	scale = SpinScaleNew(scale_adjustment, app->labels->tool_box.brightness, 1);
	gtk_box_pack_start(GTK_BOX(vbox), scale, FALSE, FALSE, 0);

	if(brush->add_h == 0 && brush->add_s == 0 && brush->add_v == 0)
	{
		brush->flags &= ~(PICKER_FLAG_CHANGE_HSV);
	}
	else
	{
		brush->flags |= PICKER_FLAG_CHANGE_HSV;
	}

	label = gtk_label_new("");
	(void)sprintf(mark_up_buff, "<span font_desc=\"%.2f\">%s : </span>",
		UI_FONT_SIZE * app->gui_scale, app->labels->unit.target);
	gtk_label_set_markup(GTK_LABEL(label), mark_up_buff);
	hbox = gtk_hbox_new(FALSE, 0);
	gtk_box_pack_start(GTK_BOX(hbox), label, FALSE, FALSE, 0);
	gtk_box_pack_start(GTK_BOX(vbox), hbox, FALSE, FALSE, 0);
	radio_buttons[0] = gtk_radio_button_new_with_label(NULL, app->labels->tool_box.select.active_layer);
	g_object_set_data(G_OBJECT(radio_buttons[0]), "pick_target", GINT_TO_POINTER(COLOR_PICKER_SOURCE_ACTIVE_LAYER));
	(void)g_signal_connect(G_OBJECT(radio_buttons[0]), "toggled", G_CALLBACK(PickerImageBrushSetPickTarget), brush);
	radio_buttons[1] = gtk_radio_button_new_with_label(gtk_radio_button_get_group(
		GTK_RADIO_BUTTON(radio_buttons[0])), app->labels->tool_box.select.canvas);
	g_object_set_data(G_OBJECT(radio_buttons[1]), "pick_target", GINT_TO_POINTER(COLOR_PICKER_SOURCE_CANVAS));
	(void)g_signal_connect(G_OBJECT(radio_buttons[1]), "toggled", G_CALLBACK(PickerImageBrushSetPickTarget), brush);
	gtk_box_pack_start(GTK_BOX(vbox), radio_buttons[0], FALSE, FALSE, 0);
	gtk_box_pack_start(GTK_BOX(vbox), radio_buttons[1], FALSE, FALSE, 0);
	gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(radio_buttons[brush->picker_source]), TRUE);

	label = gtk_label_new("");
	(void)sprintf(mark_up_buff, "<span font_desc=\"%.2f\">%s : </span>",
		UI_FONT_SIZE * app->gui_scale, app->labels->tool_box.pick_mode);
	gtk_label_set_markup(GTK_LABEL(label), mark_up_buff);
	hbox = gtk_hbox_new(FALSE, 0);
	gtk_box_pack_start(GTK_BOX(hbox), label, FALSE, FALSE, 0);
	gtk_box_pack_start(GTK_BOX(vbox), hbox, FALSE, FALSE, 0);
	radio_buttons[0] = gtk_radio_button_new_with_label(NULL, app->labels->tool_box.single_pixels);
	g_object_set_data(G_OBJECT(radio_buttons[0]), "pick_mode", GINT_TO_POINTER(PICKER_MODE_SINGLE_PIXEL));
	(void)g_signal_connect(G_OBJECT(radio_buttons[0]), "toggled", G_CALLBACK(PickerImageBrushSetPickMode), brush);
	radio_buttons[1] = gtk_radio_button_new_with_label(gtk_radio_button_get_group(
		GTK_RADIO_BUTTON(radio_buttons[0])), app->labels->tool_box.average_color);
	g_object_set_data(G_OBJECT(radio_buttons[1]), "pick_mode", GINT_TO_POINTER(PICKER_MODE_AVERAGE));
	(void)g_signal_connect(G_OBJECT(radio_buttons[1]), "toggled", G_CALLBACK(PickerImageBrushSetPickMode), brush);
	gtk_box_pack_start(GTK_BOX(vbox), radio_buttons[0], FALSE, FALSE, 0);
	gtk_box_pack_start(GTK_BOX(vbox), radio_buttons[1], FALSE, FALSE, 0);
	gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(radio_buttons[brush->picker_mode]), TRUE);

	scale_adjustment = GTK_ADJUSTMENT(gtk_adjustment_new(brush->size_range * 100, 0, 100, 1, 1, 0));
	scale = SpinScaleNew(scale_adjustment, app->labels->tool_box.size_range, 0);
	(void)g_signal_connect(G_OBJECT(scale_adjustment), "value_changed",
		G_CALLBACK(PickerImageBrushSetSizeRange), brush);
	gtk_box_pack_start(GTK_BOX(vbox), scale, FALSE, FALSE, 0);

	brush->rotate_range = brush->random_rotate_range * G_PI / 180;
	scale_adjustment = GTK_ADJUSTMENT(gtk_adjustment_new(brush->random_rotate_range, 0, 360, 1, 1, 0));
	scale = SpinScaleNew(scale_adjustment, app->labels->tool_box.rotate_range, 0);
	(void)g_signal_connect(G_OBJECT(scale_adjustment), "value_changed",
		G_CALLBACK(PickerImageBrushSetRotateRange), brush);
	gtk_box_pack_start(GTK_BOX(vbox), scale, FALSE, FALSE, 0);

#undef UI_FONT_SIZE
#undef ICON_SIZE

	return vbox;
}

static void EraserButtonPressCallBack(
	DRAW_WINDOW* window,
	FLOAT_T x,
	FLOAT_T y,
	FLOAT_T pressure,
	BRUSH_CORE *core,
	void* state
)
{
	if(((GdkEventButton*)state)->button == 1)
	{
		ERASER* eraser = (ERASER*)core->brush_data;
		cairo_t *update;
		cairo_surface_t *update_surface;
		cairo_matrix_t matrix;
		FLOAT_T r, alpha, zoom;
		FLOAT_T min_x, min_y, max_x, max_y;

		window->work_layer->layer_mode = LAYER_BLEND_ALPHA_MINUS;

		if((eraser->flags & BRUSH_FLAG_SIZE) == 0)
		{
			r = eraser->r;
			zoom = 1;
		}
		else
		{
			r = eraser->r * pressure;
			zoom = 1/pressure;
		}
		alpha = ((eraser->flags & BRUSH_FLAG_FLOW) == 0) ? 1 : pressure;

		min_x = x - r, min_y = y - r;
		max_x = x + r, max_y = y + r;

		eraser->before_x = x, eraser->before_y = y;

		if(min_x < 0.0)
		{
			min_x = 0.0;
		}
		if(min_y < 0.0)
		{
			min_y = 0.0;
		}
		if(max_x > window->work_layer->width)
		{
			max_x = window->work_layer->width;
		}
		if(max_y > window->work_layer->height)
		{
			max_y = window->work_layer->height;
		}

		window->update.x = (int)min_x, window->update.y = (int)min_y;
		window->update.width = (int)max_x - window->update.x;
		window->update.height = (int)max_y - window->update.y;

		update_surface = cairo_surface_create_for_rectangle(
			window->work_layer->surface_p, min_x, min_y, r*2+1, r*2+1);
		update = cairo_create(update_surface);

		core->min_x = min_x, core->min_y = min_y;
		core->max_x = max_x, core->max_y = max_y;

		cairo_set_operator(window->work_layer->cairo_p, CAIRO_OPERATOR_OVER);

		// テクスチャの有無で処理を切り替え
		if(window->app->textures.active_texture == 0)
		{
			// 選択範囲の有無を見る
			if((window->flags & DRAW_WINDOW_HAS_SELECTION_AREA) == 0)
			{	// 選択範囲無
					// ブラシの範囲を塗り潰す
				// ブラシの位置と拡大率をセット
				cairo_matrix_init_scale(&matrix, zoom, zoom);
				cairo_pattern_set_matrix(core->brush_pattern, &matrix);
				// ブラシをスタンバイ
				cairo_set_source(update, core->brush_pattern);
				// 筆圧を適用して描画
				cairo_paint_with_alpha(update, alpha);
			}
			else
			{	// 選択範囲有
					// 筆圧を適用したブラシパターンを作る
				cairo_matrix_init_scale(&matrix, zoom, zoom);
				cairo_pattern_set_matrix(core->brush_pattern, &matrix);
				cairo_set_source(core->temp_cairo, core->brush_pattern);
				cairo_paint_with_alpha(core->temp_cairo, alpha);
				// 選択範囲でマスク
				cairo_matrix_init_translate(&matrix, 0, 0);
				cairo_pattern_set_matrix(core->temp_pattern, &matrix);
				cairo_set_source(update, core->temp_pattern);
				cairo_mask_surface(update, window->selection->surface_p, - x + r, - y + r);
			}
		}
		else
		{
			cairo_surface_t *temp_surface = cairo_surface_create_for_rectangle(
				window->temp_layer->surface_p, min_x, min_y, r*2+1, r*2+1);
			cairo_t *update_temp = cairo_create(temp_surface);

			// 選択範囲の有無を見る
			if((window->flags & DRAW_WINDOW_HAS_SELECTION_AREA) == 0)
			{	// 選択範囲無
					// ブラシの範囲を塗り潰す
				// ブラシの位置と拡大率をセット
				cairo_matrix_init_scale(&matrix, zoom, zoom);
				cairo_pattern_set_matrix(core->brush_pattern, &matrix);
				// 一時保存レイヤーに一度描画
				(void)memset(window->temp_layer->pixels, 0, window->pixel_buf_size);
				// ブラシをスタンバイ
				cairo_set_source(update_temp, core->brush_pattern);
				// 筆圧を適用して描画
				cairo_paint_with_alpha(update_temp, alpha);

				// テクスチャを適用
				cairo_set_source_surface(update, temp_surface, 0, 0);
				cairo_mask_surface(update, window->texture->surface_p, - x + r, - y + r);
			}
			else
			{	// 選択範囲有
					// 筆圧を適用したブラシパターンを作る
				cairo_matrix_init_scale(&matrix, zoom, zoom);
				cairo_pattern_set_matrix(core->brush_pattern, &matrix);
				cairo_set_source(core->temp_cairo, core->brush_pattern);
				cairo_paint_with_alpha(core->temp_cairo, alpha);
				// 選択範囲でマスク
				cairo_matrix_init_translate(&matrix, 0, 0);
				cairo_pattern_set_matrix(core->temp_pattern, &matrix);
				// 一時保存のレイヤーに一度描画
				(void)memset(window->temp_layer->pixels, 0, window->pixel_buf_size);
				cairo_set_source(update_temp, core->temp_pattern);
				cairo_mask_surface(update_temp, window->selection->surface_p, - x + r, - y + r);

				// テクスチャを適用
				cairo_set_source_surface(update, temp_surface, 0, 0);
				cairo_mask_surface(update, window->texture->surface_p, - x + r, - y + r);
			}

			cairo_destroy(update_temp);
			cairo_surface_destroy(temp_surface);
		}

		cairo_destroy(update);
		cairo_surface_destroy(update_surface);

		window->flags |= DRAW_WINDOW_UPDATE_PART;
	}
}

static void EraserEditSelectionButtonPressCallBack(
	DRAW_WINDOW* window,
	FLOAT_T x,
	FLOAT_T y,
	FLOAT_T pressure,
	BRUSH_CORE *core,
	void* state
)
{
	if(((GdkEventButton*)state)->button == 1)
	{
		ERASER* eraser = (ERASER*)core->brush_data;
		FLOAT_T r, alpha, zoom;
		FLOAT_T min_x, min_y, max_x, max_y;
		cairo_matrix_t matrix;

		window->selection->layer_mode = SELECTION_BLEND_MINUS;

		if((eraser->flags & BRUSH_FLAG_SIZE) == 0)
		{
			r = eraser->r;
			zoom = 1;
		}
		else
		{
			r = eraser->r * pressure;
			zoom = 1/pressure;
		}
		alpha = ((eraser->flags & BRUSH_FLAG_FLOW) == 0) ? 1 : pressure;

		min_x = x - r, min_y = y - r;
		max_x = x + r, max_y = y + r;

		eraser->before_x = x, eraser->before_y = y;

		if(min_x < 0.0)
		{
			min_x = 0.0;
		}
		if(min_y < 0.0)
		{
			min_y = 0.0;
		}
		if(max_x > window->work_layer->width)
		{
			max_x = window->work_layer->width;
		}
		if(max_y > window->work_layer->height)
		{
			max_y = window->work_layer->height;
		}

		core->min_x = min_x, core->min_y = min_y;
		core->max_x = max_x, core->max_y = max_y;

		cairo_set_operator(window->work_layer->cairo_p, CAIRO_OPERATOR_OVER);
		// テクスチャの有無で処理を切り替え
		if(window->app->textures.active_texture == 0)
		{
			// 選択範囲の有無を見る
			if((window->flags & DRAW_WINDOW_HAS_SELECTION_AREA) == 0)
			{	// 選択範囲無
					// ブラシの範囲を塗り潰す
				// ブラシの位置と拡大率をセット
				cairo_matrix_init_scale(&matrix, zoom, zoom);
				cairo_matrix_translate(&matrix, - x + r, - y + r);
				cairo_pattern_set_matrix(core->brush_pattern, &matrix);
				// ブラシをスタンバイ
				cairo_set_source(window->work_layer->cairo_p, core->brush_pattern);
				// 筆圧を適用して描画
				cairo_paint_with_alpha(window->work_layer->cairo_p, alpha);
			}
			else
			{	// 選択範囲有
					// 筆圧を適用したブラシパターンを作る
				cairo_matrix_init_scale(&matrix, zoom, zoom);
				cairo_pattern_set_matrix(core->brush_pattern, &matrix);
				cairo_set_source(core->temp_cairo, core->brush_pattern);
				cairo_paint_with_alpha(core->temp_cairo, alpha);
				// 選択範囲でマスク
				cairo_matrix_init_translate(&matrix, - x + r, - y + r);
				cairo_pattern_set_matrix(core->temp_pattern, &matrix);
				cairo_set_source(window->work_layer->cairo_p, core->temp_pattern);
				cairo_mask_surface(window->work_layer->cairo_p, window->selection->surface_p, 0, 0);
			}
		}
		else
		{
			// 選択範囲の有無を見る
			if((window->flags & DRAW_WINDOW_HAS_SELECTION_AREA) == 0)
			{	// 選択範囲無
					// ブラシの範囲を塗り潰す
				// ブラシの位置と拡大率をセット
				cairo_matrix_init_scale(&matrix, zoom, zoom);
				cairo_matrix_translate(&matrix, - x + r, - y + r);
				cairo_pattern_set_matrix(core->brush_pattern, &matrix);
				// 一時保存レイヤーに一度描画
				(void)memset(window->temp_layer->pixels, 0, window->pixel_buf_size);
				// ブラシをスタンバイ
				cairo_set_source(window->temp_layer->cairo_p, core->brush_pattern);
				// 筆圧を適用して描画
				cairo_paint_with_alpha(window->temp_layer->cairo_p, alpha);

				// テクスチャを適用
				cairo_set_source_surface(window->work_layer->cairo_p, window->temp_layer->surface_p, 0, 0);
				cairo_mask_surface(window->work_layer->cairo_p, window->texture->surface_p, 0, 0);
			}
			else
			{	// 選択範囲有
					// 筆圧を適用したブラシパターンを作る
				cairo_matrix_init_scale(&matrix, zoom, zoom);
				cairo_pattern_set_matrix(core->brush_pattern, &matrix);
				cairo_set_source(core->temp_cairo, core->brush_pattern);
				cairo_paint_with_alpha(core->temp_cairo, alpha);
				// 選択範囲でマスク
				cairo_matrix_init_translate(&matrix, - x + r, - y + r);
				cairo_pattern_set_matrix(core->temp_pattern, &matrix);
				// 一時保存のレイヤーに一度描画
				(void)memset(window->temp_layer->pixels, 0, window->pixel_buf_size);
				cairo_set_source(window->temp_layer->cairo_p, core->temp_pattern);
				cairo_mask_surface(window->temp_layer->cairo_p, window->selection->surface_p, 0, 0);

				// テクスチャを適用
				cairo_set_source_surface(window->work_layer->cairo_p, window->temp_layer->surface_p, 0, 0);
				cairo_mask_surface(window->work_layer->cairo_p, window->texture->surface_p, 0, 0);
			}
		}
	}
}

static void EraserMotionCallBack(
	DRAW_WINDOW* window,
	FLOAT_T x,
	FLOAT_T y,
	FLOAT_T pressure,
	BRUSH_CORE *core,
	void* state
)
{
	if(((*(GdkModifierType*)state) & GDK_BUTTON1_MASK) != 0)
	{
		ERASER* eraser = (ERASER*)core->brush_data;
		cairo_t *update;
		cairo_surface_t *update_surface;
		cairo_matrix_t matrix;
		FLOAT_T r, step, alpha, d;
		FLOAT_T min_x, min_y, max_x, max_y;
		FLOAT_T draw_x = eraser->before_x, draw_y = eraser->before_y;
		FLOAT_T dx, dy, diff_x, diff_y;
		FLOAT_T zoom;
		int32 clear_x, clear_width, clear_y, clear_height;
		// 作業レイヤーの一行分のバイト数
		int layer_stride = window->work_layer->stride;
		// 作業レイヤーのピクセル
		uint8 *work_pixel = window->work_layer->pixels;
		// 一時保存レイヤーのピクセル
		uint8 *temp_pixel = window->temp_layer->pixels;
		uint8 *color = *core->color;
		int i;

		if((eraser->flags & BRUSH_FLAG_SIZE) == 0)
		{
			r = eraser->r;
			zoom = 1;
		}
		else
		{
			r = eraser->r * pressure;
			zoom = 1/pressure;
		}
		step = r * BRUSH_STEP;
		alpha = ((eraser->flags & BRUSH_FLAG_FLOW) == 0) ?
			1 : pressure;
		dx = x-eraser->before_x, dy = y-eraser->before_y;
		d = sqrt(dx*dx+dy*dy);
		diff_x = step * dx/d, diff_y = step * dy/d;
		if(step < 0.01)
		{
			dx = 0;
			goto skip_draw;
		}

		min_x = x - r*2, min_y = y - r*2;
		max_x = x + r*2, max_y = y + r*2;

		if(min_x < 0.0)
		{
			min_x = 0.0;
		}
		if(min_y < 0.0)
		{
			min_y = 0.0;
		}
		if(max_x > window->work_layer->width)
		{
			max_x = window->work_layer->width;
		}
		if(max_y > window->work_layer->height)
		{
			max_y = window->work_layer->height;
		}

		if(window->update.x > min_x)
		{
			window->update.width += window->update.x - (int)min_x;
			window->update.x = (int)min_x;
		}
		if(window->update.width + window->update.x < max_x)
		{
			window->update.width += (int)max_x - window->update.width + window->update.x;
		}
		if(window->update.y > min_y)
		{
			window->update.height += window->update.y - (int)min_y;
			window->update.y = (int)min_y;
		}
		if(window->update.height + window->update.y < max_y)
		{
			window->update.height += (int)max_y - window->update.height + window->update.y;
		}

		if(core->min_x > min_x)
		{
			core->min_x = min_x;
		}
		if(core->min_y > min_y)
		{
			core->min_y = min_y;
		}
		if(core->max_x < max_x)
		{
			core->max_x = max_x;
		}
		if(core->max_y < max_y)
		{
			core->max_y = max_y;
		}

		cairo_set_operator(window->work_layer->cairo_p, CAIRO_OPERATOR_OVER);
		dx = d;
		while(1)
		{
			clear_x = (int32)(draw_x - r - 1);
			clear_width = (int32)(draw_x + r + 1);
			clear_y = (int32)(draw_y - r - 1);
			clear_height = (int32)(draw_y + r + 1);

			if(clear_x < 0)
			{
				clear_x = 0;
			}
			else if(clear_width > window->width)
			{
				clear_width = window->width;
			}
			if(clear_y < 0)
			{
				clear_y = 0;
			}
			if(clear_height > window->height)
			{
				clear_height = window->height;
			}
			clear_width = clear_width - clear_x;
			clear_height = clear_height - clear_y;

			if(clear_width <= 0 || clear_height <= 0)
			{
				goto skip_draw;
			}

			update_surface = cairo_surface_create_for_rectangle(
				window->temp_layer->surface_p, draw_x - r, draw_y - r, r*2+1, r*2+1);
			update = cairo_create(update_surface);

			for(i=0; i<clear_height; i++)
			{
				(void)memset(&window->temp_layer->pixels[(i+clear_y)*window->work_layer->stride+clear_x*window->work_layer->channel],
					0x0, clear_width*window->work_layer->channel);
			}

			// テクスチャの有無で処理を切り替え
			if(window->app->textures.active_texture == 0)
			{
				// 選択範囲の有無を見る
				if((window->flags & DRAW_WINDOW_HAS_SELECTION_AREA) == 0)
				{	// 選択範囲無
						// ブラシの範囲を塗り潰す
					// ブラシの位置と拡大率をセット
					cairo_matrix_init_scale(&matrix, zoom, zoom);
					cairo_pattern_set_matrix(core->brush_pattern, &matrix);
					// ブラシをスタンバイ
					cairo_set_source(update, core->brush_pattern);
					// 筆圧を適用して描画
					cairo_paint_with_alpha(update, alpha);
				}
				else
				{	// 選択範囲有
						// 筆圧を適用したブラシパターンを作る
					cairo_matrix_init_scale(&matrix, zoom, zoom);
					cairo_pattern_set_matrix(core->brush_pattern, &matrix);
					cairo_set_source(core->temp_cairo, core->brush_pattern);
					cairo_paint_with_alpha(core->temp_cairo, alpha);
					// 選択範囲でマスク
					cairo_matrix_init_translate(&matrix, 0, 0);
					cairo_pattern_set_matrix(core->temp_pattern, &matrix);
					cairo_set_source(update, core->temp_pattern);
					cairo_mask_surface(update, window->selection->surface_p, - draw_x + r, - draw_y + r);
				}
			}
			else
			{
				cairo_surface_t *temp_surface = cairo_surface_create_for_rectangle(
					window->mask_temp->surface_p, draw_x - r, draw_y - r, r*2+1, r*2+1);
				cairo_t *update_temp = cairo_create(temp_surface);

				for(i=0; i<clear_height; i++)
				{
					(void)memset(&window->mask_temp->pixels[(i+clear_y)*window->work_layer->stride+clear_x*window->work_layer->channel],
						0x0, clear_width*window->work_layer->channel);
				}

				// 選択範囲の有無を見る
				if((window->flags & DRAW_WINDOW_HAS_SELECTION_AREA) == 0)
				{	// 選択範囲無
						// ブラシの範囲を塗り潰す
					// ブラシの位置と拡大率をセット
					cairo_matrix_init_scale(&matrix, zoom, zoom);
					cairo_pattern_set_matrix(core->brush_pattern, &matrix);
					// マスク用の一時保存に一度描画
						// ブラシをスタンバイ
					cairo_set_source(update_temp, core->brush_pattern);
						// 筆圧を適用して描画
					cairo_paint_with_alpha(update_temp, alpha);

					// テクスチャを適用
					cairo_set_source_surface(update, temp_surface, 0, 0);
					cairo_mask_surface(update, window->texture->surface_p, - draw_x + r, - draw_y + r);
				}
				else
				{	// 選択範囲有
						// 筆圧を適用したブラシパターンを作る
					cairo_matrix_init_scale(&matrix, zoom, zoom);
					cairo_pattern_set_matrix(core->brush_pattern, &matrix);
					cairo_set_source(core->temp_cairo, core->brush_pattern);
					cairo_paint_with_alpha(core->temp_cairo, alpha);
					// マスク用の一時保存に一度描画
						// 選択範囲でマスク
					cairo_matrix_init_translate(&matrix, 0, 0);
					cairo_pattern_set_matrix(core->temp_pattern, &matrix);
					cairo_set_source(update_temp, core->temp_pattern);
					cairo_mask_surface(update_temp, window->selection->surface_p, - draw_x + r, - draw_y + r);

					// テクスチャを適用
					cairo_set_source_surface(update, temp_surface, 0, 0);
					cairo_mask_surface(update, window->texture->surface_p, - draw_x + r, - draw_y + r);
				}

				cairo_destroy(update_temp);
				cairo_surface_destroy(temp_surface);
			}

			cairo_destroy(update);
			cairo_surface_destroy(update_surface);

#ifdef _OPENMP
#pragma omp parallel for firstprivate(clear_width, work_pixel, temp_pixel, layer_stride, clear_x, clear_y)
#endif
			for(i=0; i<clear_height; i++)
			{
				int j, k;
				for(j=0; j<clear_width; j++)
				{
					if(temp_pixel[(clear_y+i)*layer_stride+(clear_x+j)*4+3]
						> work_pixel[(clear_y+i)*layer_stride+(clear_x+j)*4+3])
					{
						for(k=0; k<4; k++)
						{
							work_pixel[(clear_y+i)*layer_stride+(clear_x+j)*4+k] =
								(uint32)(((int)temp_pixel[(clear_y+i)*layer_stride+(clear_x+j)*4+k]
								- (int)work_pixel[(clear_y+i)*layer_stride+(clear_x+j)*4+k])
									* temp_pixel[(clear_y+i)*layer_stride+(clear_x+j)*4+3] >> 8)
									+ work_pixel[(clear_y+i)*layer_stride+(clear_x+j)*4+k];
						}
					}
				}
			}


skip_draw:
			dx -= step;
			if(dx < 1)
			{
				break;
			}
			else if(dx >= step)
			{
				draw_x += diff_x, draw_y += diff_y;
			}
			else
			{
				draw_x = x, draw_y = y;
			}
		}

		eraser->before_x = x, eraser->before_y = y;

		window->flags |= DRAW_WINDOW_UPDATE_PART;
	}
}

#define EraserEditSelectionMotionCallBack EraserMotionCallBack

#define EraserReleaseCallBack PencilReleaseCallBack
#define EraserEditSelectionReleaseCallBack DefaultEditSelectionReleaseCallBack

static void EraserDrawCursor(
	DRAW_WINDOW* window,
	FLOAT_T x,
	FLOAT_T y,
	void* data
)
{
	ERASER* eraser = (ERASER*)data;
	FLOAT_T r = eraser->r * window->zoom_rate;
	cairo_set_line_width(window->disp_temp->cairo_p, 1.0);
	cairo_set_source_rgb(window->disp_temp->cairo_p, 1, 1, 1);
	cairo_arc(window->disp_temp->cairo_p, x, y, r, 0, 2*G_PI);
	cairo_stroke(window->disp_temp->cairo_p);

	cairo_rectangle(window->disp_layer->cairo_p, x - r, y - r,
		(r + BRUSH_UPDATE_MARGIN) * 2, (r + BRUSH_UPDATE_MARGIN) * 2);
	cairo_clip(window->disp_layer->cairo_p);
}

static void EraserButtonUpdate(DRAW_WINDOW* window, FLOAT_T x, FLOAT_T y, ERASER* eraser)
{
	FLOAT_T r = eraser->r * window->zoom_rate + 3;
	gtk_widget_queue_draw_area(window->window, (gint)(x - r - 1),
		(gint)(y - r - 1), (gint)(r * 2 + 3), (gint)(r * 2 + 3));
}

static void EraserMotionUpdate(DRAW_WINDOW* window, FLOAT_T x, FLOAT_T y, ERASER* eraser)
{
	FLOAT_T start_x, start_y;
	FLOAT_T width, height;
	FLOAT_T r = eraser->r * window->zoom_rate * 1.275 + BRUSH_UPDATE_MARGIN;

	if(window->before_cursor_x < x)
	{
		start_x = window->before_cursor_x - r;
		width = r * 2 + x - window->before_cursor_x;
	}
	else
	{
		start_x = x - r;
		width = r * 2 + window->before_cursor_x - x;
	}

	if(window->before_cursor_y < y)
	{
		start_y = window->before_cursor_y - r;
		height = r * 2 + y - window->before_cursor_y;
	}
	else
	{
		start_y = y - r;
		height = r * 2 + window->before_cursor_y - y;
	}

	gtk_widget_queue_draw_area(window->window,
		(gint)start_x, (gint)start_y, (gint)width + 2, (gint)height + 2);
}

static void EraserScaleChange(
	GtkAdjustment* slider,
	gpointer data
)
{
	ERASER* eraser = (ERASER*)data;
	const uint8 color[3] = {0, 0, 0};
	eraser->r = gtk_adjustment_get_value(slider) * 0.5;

	BrushCoreSetCirclePattern(eraser->core, eraser->r, eraser->outline_hardness * 0.01,
		eraser->blur * 0.01, eraser->alpha * 0.01, color);
}

static void EraserFlowChange(
	GtkAdjustment* slider,
	gpointer data
)
{
	ERASER* eraser = (ERASER*)data;
	const uint8 color[3] = {0, 0, 0};
	eraser->alpha = gtk_adjustment_get_value(slider);

	BrushCoreSetCirclePattern(eraser->core, eraser->r, eraser->outline_hardness * 0.01,
		eraser->blur * 0.01, eraser->alpha * 0.01, color);
}

static void EraserOutlineHardnessChange(GtkAdjustment* slider, ERASER* eraser)
{
	const uint8 color[3] = {0, 0, 0};
	eraser->outline_hardness = gtk_adjustment_get_value(slider);

	BrushCoreSetCirclePattern(eraser->core, eraser->r, eraser->outline_hardness * 0.01,
		eraser->blur * 0.01, eraser->alpha * 0.01, color);
}

static void EraserBlurChange(GtkAdjustment* slider, ERASER* eraser)
{
	const uint8 color[3] = {0, 0, 0};
	eraser->blur = gtk_adjustment_get_value(slider);

	BrushCoreSetCirclePattern(eraser->core, eraser->r, eraser->outline_hardness * 0.01,
		eraser->blur * 0.01, eraser->alpha * 0.01, color);
}

static void EraserPressureSizeChange(
	GtkWidget* widget,
	gpointer data
)
{
	ERASER* eraser = (ERASER*)data;
	if(gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(widget)) == FALSE)
	{
		eraser->flags &= ~(BRUSH_FLAG_SIZE);
	}
	else
	{
		eraser->flags |= BRUSH_FLAG_SIZE;
	}
}

static void EraserPressureFlowChange(
	GtkWidget* widget,
	gpointer data
)
{
	ERASER* eraser = (ERASER*)data;
	if(gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(widget)) == FALSE)
	{
		eraser->flags &= ~(BRUSH_FLAG_FLOW);
	}
	else
	{
		eraser->flags |= BRUSH_FLAG_FLOW;
	}
}

static GtkWidget* CreateEraserDetailUI(APPLICATION* app, BRUSH_CORE* core)
{
#define UI_FONT_SIZE 8.0
	ERASER* eraser = (ERASER*)core->brush_data;
	GtkWidget* vbox = gtk_vbox_new(FALSE, 2);
	GtkWidget* brush_scale;
	GtkWidget* table = gtk_table_new(1, 3, TRUE);
	GtkWidget* check_button;
	GtkWidget* base_scale;
	GtkWidget* hbox;
	GtkWidget* label;
	GtkAdjustment* brush_scale_adjustment;
	char mark_up_buff[256];
	const uint8 color[3] = {0, 0, 0};

	eraser->core = core;

	{
		const char *mag_str[] = {"x 0.1", "x 1", "x 10"};
		hbox = gtk_hbox_new(FALSE, 0);
		label = gtk_label_new("");
		(void)sprintf(mark_up_buff, "<span font_desc=\"%.2f\">%s : </span>",
			UI_FONT_SIZE * app->gui_scale, app->labels->tool_box.base_scale);
		gtk_label_set_markup(GTK_LABEL(label), mark_up_buff);
		gtk_box_pack_start(GTK_BOX(hbox), label, FALSE, FALSE, 0);
#if GTK_MAJOR_VERSION <= 2
		base_scale = gtk_combo_box_new_text();
		gtk_combo_box_append_text(GTK_COMBO_BOX(base_scale), mag_str[0]);
		gtk_combo_box_append_text(GTK_COMBO_BOX(base_scale), mag_str[1]);
		gtk_combo_box_append_text(GTK_COMBO_BOX(base_scale), mag_str[2]);
#else
		base_scale = gtk_combo_box_text_new();
		gtk_combo_box_text_append_text(GTK_COMBO_BOX_TEXT(base_scale), mag_str[0]);
		gtk_combo_box_text_append_text(GTK_COMBO_BOX_TEXT(base_scale), mag_str[1]);
		gtk_combo_box_text_append_text(GTK_COMBO_BOX_TEXT(base_scale), mag_str[2]);
#endif
		gtk_combo_box_set_active(GTK_COMBO_BOX(base_scale), eraser->base_scale);
		gtk_box_pack_start(GTK_BOX(hbox), base_scale, TRUE, TRUE, 0);
		gtk_box_pack_start(GTK_BOX(vbox), hbox, FALSE, FALSE, 0);
	}

	switch(eraser->base_scale)
	{
	case 0:
		brush_scale_adjustment =
			GTK_ADJUSTMENT(gtk_adjustment_new(eraser->r * 2, 0.1, 10.0, 0.1, 0.1, 0.0));
		break;
	case 1:
		brush_scale_adjustment =
			GTK_ADJUSTMENT(gtk_adjustment_new(eraser->r * 2, 1.0, 100.0, 1.0, 1.0, 0.0));
		break;
	default:
		brush_scale_adjustment =
			GTK_ADJUSTMENT(gtk_adjustment_new(eraser->r * 2, 5.0, 500.0, 1.0, 1.0, 0.0));
	}

	brush_scale = SpinScaleNew(brush_scale_adjustment,
		app->labels->tool_box.brush_scale, 1);
	(void)g_signal_connect(G_OBJECT(brush_scale_adjustment), "value_changed",
		G_CALLBACK(PencilScaleChange), core->brush_data);
	gtk_table_attach_defaults(GTK_TABLE(table), brush_scale, 0, 3, 0, 1);
	gtk_box_pack_start(GTK_BOX(vbox), table, FALSE, TRUE, 0);

	g_object_set_data(G_OBJECT(base_scale), "scale", brush_scale);
	(void)g_signal_connect(G_OBJECT(base_scale), "changed", G_CALLBACK(SetBrushBaseScale), &eraser->base_scale);

	brush_scale_adjustment =
		GTK_ADJUSTMENT(gtk_adjustment_new(eraser->alpha, 0.0, 100.0, 1.0, 1.0, 0.0));
	brush_scale = SpinScaleNew(brush_scale_adjustment,
		app->labels->tool_box.flow, 1);
	(void)g_signal_connect(G_OBJECT(brush_scale_adjustment), "value_changed",
		G_CALLBACK(EraserFlowChange), core->brush_data);
	table = gtk_table_new(1, 3, TRUE);
	gtk_table_attach_defaults(GTK_TABLE(table), brush_scale, 0, 3, 0, 1);
	gtk_box_pack_start(GTK_BOX(vbox), table, FALSE, TRUE, 0);

	brush_scale_adjustment =
		GTK_ADJUSTMENT(gtk_adjustment_new(eraser->outline_hardness, 0.0, 100.0, 1.0, 1.0, 0.0));
	brush_scale = SpinScaleNew(brush_scale_adjustment,
		app->labels->tool_box.outline_hardness, 1);
	(void)g_signal_connect(G_OBJECT(brush_scale_adjustment), "value_changed",
		G_CALLBACK(EraserOutlineHardnessChange), core->brush_data);
	gtk_box_pack_start(GTK_BOX(vbox), brush_scale, FALSE, TRUE, 0);

	brush_scale_adjustment =
		GTK_ADJUSTMENT(gtk_adjustment_new(eraser->blur, 0.0, 100.0, 1.0, 1.0, 0.0));
	brush_scale = SpinScaleNew(brush_scale_adjustment,
		app->labels->tool_box.blur, 1);
	(void)g_signal_connect(G_OBJECT(brush_scale_adjustment), "value_changed",
		G_CALLBACK(EraserBlurChange), core->brush_data);
	gtk_box_pack_start(GTK_BOX(vbox), brush_scale, FALSE, TRUE, 0);

	table = gtk_hbox_new(FALSE, 0);
	label = gtk_label_new("");
	(void)sprintf(mark_up_buff, "<span font_desc=\"%.2f\">%s : </span>",
		UI_FONT_SIZE * app->gui_scale, app->labels->tool_box.pressure);
	gtk_label_set_markup(GTK_LABEL(label), mark_up_buff);
	gtk_box_pack_start(GTK_BOX(table), label, FALSE, TRUE, 0);
	check_button = gtk_check_button_new_with_label(app->labels->tool_box.scale);
	(void)g_signal_connect(G_OBJECT(check_button), "toggled", G_CALLBACK(EraserPressureSizeChange), core->brush_data);
	gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(check_button), eraser->flags & BRUSH_FLAG_SIZE);
	gtk_box_pack_start(GTK_BOX(table), check_button, FALSE, TRUE, 0);
	check_button = gtk_check_button_new_with_label(app->labels->tool_box.flow);
	(void)g_signal_connect(G_OBJECT(check_button), "toggled", G_CALLBACK(EraserPressureFlowChange), core->brush_data);
	gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(check_button), eraser->flags & BRUSH_FLAG_FLOW);
	gtk_box_pack_start(GTK_BOX(table), check_button, FALSE, TRUE, 0);
	gtk_box_pack_start(GTK_BOX(vbox), table, FALSE, TRUE, 0);

	BrushCoreSetCirclePattern(eraser->core, eraser->r, eraser->outline_hardness * 0.01,
		eraser->blur * 0.01, eraser->alpha * 0.01, color);

	return vbox;
#undef UI_FONT_SIZE
}

static void BucketPressCallBack(
	DRAW_WINDOW* window,
	FLOAT_T x,
	FLOAT_T y,
	FLOAT_T pressure,
	BRUSH_CORE *core,
	void* state
)
{
	// 描画領域外のクリックなら終了
	if(x < 0 || x > window->width || y < 0 || y > window->height)
	{
		return;
	}

	if(((GdkEventButton*)state)->button == 1)
	{
		BUCKET* bucket = (BUCKET*)core->brush_data;
		LAYER* target;
		uint8* buff = &window->temp_layer->pixels[window->width*window->height];
		int32 min_x, min_y, max_x, max_y;
		uint8 channel = (bucket->mode == BUCKET_RGB) ? 3 :
			(bucket->mode == BUCKET_ALPHA) ? 1 : 4;
		int i;

		if((window->flags & DRAW_WINDOW_HAS_SELECTION_AREA) != 0)
		{
			if(window->selection->pixels[(int)y*window->selection->width+(int)x] < 0x80)
			{
				return;
			}
		}

		if((window->active_layer->flags & LAYER_LOCK_OPACITY) == 0)
		{
			window->work_layer->layer_mode = LAYER_BLEND_NORMAL;
		}
		else
		{
			window->work_layer->layer_mode = LAYER_BLEND_ATOP;
		}

		switch(bucket->target)
		{
		case BUCKET_TARGET_ACTIVE_LAYER:
			target = window->active_layer;
			break;
		case BUCKET_TARGET_CANVAS:
			target = MixLayerForSave(window);
			break;
		default:
			target = NULL;
		}

		(void)memset(window->mask_temp->pixels, 0, window->pixel_buf_size);
		(void)memset(window->temp_layer->pixels, 0, window->pixel_buf_size);

		if(bucket->mode != BUCKET_ALPHA)
		{
			DetectSameColorArea(
				target,
				buff,
				&window->temp_layer->pixels[window->width*window->height*2],
				(int32)x, (int32)y,
				&target->pixels[(int32)y*target->stride + (int32)x*target->channel],
				channel, bucket->threshold, &min_x, &min_y, &max_x, &max_y,
				(eSELECT_FUZZY_DIRECTION)bucket->select_direction
			);
		}
		else
		{
			LAYER* local_target = CreateLayer(0, 0, target->width, target->height,
				1, TYPE_NORMAL_LAYER, NULL, NULL, NULL, window);

			for(i=0; i<target->width*target->height; i++)
			{
				local_target->pixels[i] = target->pixels[i*4+3];
			}

			DetectSameColorArea(
				local_target,
				buff,
				&window->temp_layer->pixels[window->width*window->height*2],
				(int32)x, (int32)y,
				&target->pixels[(int32)y*target->stride + (int32)x*target->channel + 3],
				channel, bucket->threshold, &min_x, &min_y, &max_x, &max_y,
				(eSELECT_FUZZY_DIRECTION)bucket->select_direction
			);

			DeleteLayer(&local_target);
		}

		if((bucket->flags & BUCKET_FLAG_ANTI_ALIAS) != 0)
		{
			(void)memcpy(&window->temp_layer->pixels[window->width*window->height*2],
				buff, window->active_layer->width*window->active_layer->height);
			AntiAlias(&window->temp_layer->pixels[window->width*window->height*2],
				buff, window->active_layer->width, window->active_layer->height, window->active_layer->width, 1);
		}

		core->min_x = min_x - 1, core->min_y = min_y - 1;
		core->max_x = max_x + 1, core->max_y = max_y + 1;

		for(i=0; i<window->mask_temp->width*window->mask->height; i++)
		{
			window->mask_temp->pixels[i*4] = buff[i];
			window->mask_temp->pixels[i*4+1] = buff[i];
			window->mask_temp->pixels[i*4+2] = buff[i];
			window->mask_temp->pixels[i*4+3] = buff[i];
		}

		if(bucket->extend > 0)
		{
			(void)memcpy(window->mask_temp->pixels, buff,
				window->mask_temp->height * window->mask_temp->width);
			for(i=0; i<bucket->extend; i++)
			{
				ExtendSelectionAreaOneStep(window->mask_temp, window->temp_layer);
				(void)memcpy(window->mask_temp->pixels, window->temp_layer->pixels,
					window->mask_temp->width*window->mask_temp->height);
				core->min_x -= 1, core->min_y -= 1;
				core->max_x += 1, core->max_y += 1;
			}

			for(i=0; i<window->mask_temp->width*window->mask_temp->height; i++)
			{
				window->mask_temp->pixels[i*4] = window->temp_layer->pixels[i];
				window->mask_temp->pixels[i*4+1] = window->temp_layer->pixels[i];
				window->mask_temp->pixels[i*4+2] = window->temp_layer->pixels[i];
				window->mask_temp->pixels[i*4+3] = window->temp_layer->pixels[i];
			}
		}
		else
		{
			int end = abs(bucket->extend);

			(void)memcpy(window->mask_temp->pixels, buff,
				window->mask_temp->height * window->mask_temp->width);
			for(i=0; i<end; i++)
			{
				ReductSelectionAreaOneStep(window->mask_temp, window->temp_layer);
				(void)memcpy(window->mask_temp->pixels, window->temp_layer->pixels,
					window->mask_temp->width*window->mask_temp->height);
			}

			for(i=0; i<window->mask_temp->width*window->mask_temp->height; i++)
			{
				window->mask_temp->pixels[i*4] = buff[i];
				window->mask_temp->pixels[i*4+1] = buff[i];
				window->mask_temp->pixels[i*4+2] = buff[i];
				window->mask_temp->pixels[i*4+3] = buff[i];
			}
		}

		cairo_set_operator(window->work_layer->cairo_p, CAIRO_OPERATOR_OVER);
		if(window->app->textures.active_texture == 0)
		{
			if((window->flags & DRAW_WINDOW_HAS_SELECTION_AREA) == 0)
			{
				cairo_set_source_rgb(window->work_layer->cairo_p, (*core->color)[0]*DIV_PIXEL, (*core->color)[1]*DIV_PIXEL, (*core->color)[2]*DIV_PIXEL);
				cairo_rectangle(window->work_layer->cairo_p, 0, 0,
					window->work_layer->width, window->work_layer->height);
				cairo_mask_surface(window->work_layer->cairo_p, window->mask_temp->surface_p, 0, 0);
			}
			else
			{
				cairo_set_source_rgb(window->temp_layer->cairo_p, (*core->color)[0]*DIV_PIXEL, (*core->color)[1]*DIV_PIXEL, (*core->color)[2]*DIV_PIXEL);
				(void)memset(window->temp_layer->pixels, 0, window->pixel_buf_size);
				cairo_set_operator(window->temp_layer->cairo_p, CAIRO_OPERATOR_OVER);
				cairo_rectangle(window->temp_layer->cairo_p, 0, 0, window->width, window->height);
				cairo_mask_surface(window->temp_layer->cairo_p, window->mask_temp->surface_p, 0, 0);
				cairo_set_source_surface(window->work_layer->cairo_p, window->temp_layer->surface_p, 0, 0);
				cairo_mask_surface(window->work_layer->cairo_p, window->selection->surface_p, 0, 0);
			}
		}
		else
		{
			(void)memset(window->mask->pixels, 0, window->pixel_buf_size);
			if((window->flags & DRAW_WINDOW_HAS_SELECTION_AREA) == 0)
			{
				cairo_set_source_rgb(window->mask->cairo_p, (*core->color)[0]*DIV_PIXEL, (*core->color)[1]*DIV_PIXEL, (*core->color)[2]*DIV_PIXEL);
				cairo_rectangle(window->mask->cairo_p, 0, 0,
					window->mask->width, window->work_layer->height);
				cairo_mask_surface(window->mask->cairo_p, window->mask_temp->surface_p, 0, 0);
				cairo_set_source_surface(window->work_layer->cairo_p, window->mask->surface_p, 0, 0);
				cairo_mask_surface(window->work_layer->cairo_p, window->texture->surface_p, 0, 0);
			}
			else
			{
				cairo_set_source_rgb(window->temp_layer->cairo_p, (*core->color)[0]*DIV_PIXEL, (*core->color)[1]*DIV_PIXEL, (*core->color)[2]*DIV_PIXEL);
				(void)memset(window->temp_layer->pixels, 0, window->pixel_buf_size);
				cairo_set_operator(window->temp_layer->cairo_p, CAIRO_OPERATOR_OVER);
				cairo_rectangle(window->temp_layer->cairo_p, 0, 0, window->width, window->height);
				cairo_mask_surface(window->temp_layer->cairo_p, window->mask_temp->surface_p, 0, 0);
				cairo_set_source_surface(window->mask->cairo_p, window->temp_layer->surface_p, 0, 0);
				cairo_mask_surface(window->mask->cairo_p, window->selection->surface_p, 0, 0);
				cairo_set_source_surface(window->work_layer->cairo_p, window->mask->surface_p, 0, 0);
				cairo_mask_surface(window->work_layer->cairo_p, window->texture->surface_p, 0, 0);
			}
		}

		AddBrushHistory(core, window->active_layer);

		window->layer_blend_functions[window->work_layer->layer_mode](window->work_layer, window->active_layer);

		(void)memset(window->work_layer->pixels, 0, window->work_layer->stride*window->work_layer->height);

		if(bucket->target == BUCKET_TARGET_CANVAS)
		{
			DeleteLayer(&target);
		}

		window->work_layer->layer_mode = LAYER_BLEND_NORMAL;
	}
}

static void BucketEditSelectionPressCallBack(
	DRAW_WINDOW* window,
	FLOAT_T x,
	FLOAT_T y,
	FLOAT_T pressure,
	BRUSH_CORE *core,
	void* state
)
{
	if(((GdkEventButton*)state)->button == 1)
	{
		BUCKET* bucket = (BUCKET*)core->brush_data;
		LAYER* target = window->mask;
		uint8* buff = &window->temp_layer->pixels[window->width*window->height];
		int32 min_x, min_y, max_x, max_y;
		int32 before_stride = target->stride;
		uint8 before_channel = target->channel;
		uint8 channel = 1;
		int i;

		window->selection->layer_mode = SELECTION_BLEND_NORMAL;

		(void)memcpy(window->mask->pixels, window->selection->pixels, window->width * window->height);
		(void)memset(window->mask_temp->pixels, 0, window->pixel_buf_size);
		(void)memset(window->temp_layer->pixels, 0, window->pixel_buf_size);

		target->channel = 1;
		target->stride = target->width;
		DetectSameColorArea(
			target,
			buff,
			&window->temp_layer->pixels[window->width*window->height*2],
			(int32)x, (int32)y,
			&target->pixels[(int32)y*target->stride + (int32)x*target->channel],
			channel, bucket->threshold, &min_x, &min_y, &max_x, &max_y,
			(eSELECT_FUZZY_DIRECTION)bucket->select_direction
		);
		target->stride = before_stride;
		target->channel = before_channel;

		if((bucket->flags & BUCKET_FLAG_ANTI_ALIAS) != 0)
		{
			(void)memcpy(&window->temp_layer->pixels[window->width*window->height*2],
				buff, window->active_layer->width*window->active_layer->height);
			AntiAlias(&window->temp_layer->pixels[window->width*window->height*2],
				buff, window->active_layer->width, window->active_layer->height, window->active_layer->width, 1);
		}

		core->min_x = min_x - 1, core->min_y = min_y - 1;
		core->max_x = max_x + 1, core->max_y = max_y + 1;

		for(i=0; i<window->mask_temp->width*window->mask->height; i++)
		{
			window->mask_temp->pixels[i*4] = buff[i];
			window->mask_temp->pixels[i*4+1] = buff[i];
			window->mask_temp->pixels[i*4+2] = buff[i];
			window->mask_temp->pixels[i*4+3] = buff[i];
		}

		if(bucket->extend > 0)
		{
			(void)memcpy(window->mask_temp->pixels, buff,
				window->mask_temp->height * window->mask_temp->width);
			for(i=0; i<bucket->extend; i++)
			{
				ExtendSelectionAreaOneStep(window->mask_temp, window->temp_layer);
				(void)memcpy(window->mask_temp->pixels, window->temp_layer->pixels,
					window->mask_temp->width*window->mask_temp->height);
				core->min_x -= 1, core->min_y -= 1;
				core->max_x += 1, core->max_y += 1;
			}

			for(i=0; i<window->mask_temp->width*window->mask->height; i++)
			{
				window->mask_temp->pixels[i*4] = buff[i];
				window->mask_temp->pixels[i*4+1] = buff[i];
				window->mask_temp->pixels[i*4+2] = buff[i];
				window->mask_temp->pixels[i*4+3] = buff[i];
			}
		}
		else
		{
			int end = abs(bucket->extend);

			(void)memcpy(window->mask_temp->pixels, buff,
				window->mask_temp->height * window->mask_temp->width);
			for(i=0; i<end; i++)
			{
				ReductSelectionAreaOneStep(window->mask_temp, window->temp_layer);
				(void)memcpy(window->mask_temp->pixels, window->temp_layer->pixels,
					window->mask_temp->width*window->mask_temp->height);
			}

			for(i=0; i<window->mask_temp->width*window->mask->height; i++)
			{
				window->mask_temp->pixels[i*4] = buff[i];
				window->mask_temp->pixels[i*4+1] = buff[i];
				window->mask_temp->pixels[i*4+2] = buff[i];
				window->mask_temp->pixels[i*4+3] = buff[i];
			}
		}

		cairo_set_operator(window->work_layer->cairo_p, CAIRO_OPERATOR_OVER);
		cairo_set_source_rgb(window->work_layer->cairo_p, 0, 0, 0);
		cairo_rectangle(window->work_layer->cairo_p, 0, 0,
			window->work_layer->width, window->work_layer->height);
		cairo_mask_surface(window->work_layer->cairo_p, window->mask_temp->surface_p, 0, 0);

		AddSelectionEditHistory(core, window->selection);

		g_blend_selection_funcs[SELECTION_BLEND_NORMAL](window->work_layer, window->selection);

		(void)memset(window->work_layer->pixels, 0, window->work_layer->stride*window->work_layer->height);

		window->work_layer->layer_mode = LAYER_BLEND_NORMAL;
	}
}

#define BucketMotionCallBack DummyBrushCallBack
#define BucketEditSelectionMotionCallBack DummyBrushCallBack
#define BucketReleaseCallBack DummyBrushCallBack
#define BucketEditSelectionReleaseCallBack DummyBrushCallBack
#define BucketDrawCursor DummyBrushDrawCursor

static void BucketSetModeRGB(GtkWidget* widget, gpointer data)
{
	((BUCKET*)data)->mode = BUCKET_RGB;
}

static void BucketSetModeRGBA(GtkWidget* widget, gpointer data)
{
	((BUCKET*)data)->mode = BUCKET_RGBA;
}

static void BucketSetModeAlpha(GtkWidget* widget, gpointer data)
{
	((BUCKET*)data)->mode = BUCKET_ALPHA;
}

static void BucketChangeThreshold(GtkWidget* widget, gpointer data)
{
	BUCKET* bucket = (BUCKET*)data;
	bucket->threshold = (uint16)gtk_adjustment_get_value(GTK_ADJUSTMENT(widget));
	gtk_adjustment_set_value(GTK_ADJUSTMENT(widget), bucket->threshold);
}

static void BucketSetTargetActiveLayer(GtkWidget* widget, gpointer data)
{
	((BUCKET*)data)->target = BUCKET_TARGET_ACTIVE_LAYER;
}

static void BucketSetTargetCanvas(GtkWidget* widget, gpointer data)
{
	((BUCKET*)data)->target = BUCKET_TARGET_CANVAS;
}

static void BucketSetSelectDirection(GtkWidget* widget, gpointer data)
{
	((BUCKET*)data)->select_direction =
		(uint8)g_object_get_data(G_OBJECT(widget), "direction");
}

static void BucketChangeAntiAlias(GtkToggleButton* button, BUCKET* bucket)
{
	if(gtk_toggle_button_get_active(button) == FALSE)
	{
		bucket->flags &= ~(BUCKET_FLAG_ANTI_ALIAS);
	}
	else
	{
		bucket->flags |= BUCKET_FLAG_ANTI_ALIAS;
	}
}

static void BucketChangeExtend(GtkAdjustment* spin, BUCKET* bucket)
{
	bucket->extend = (int16)gtk_adjustment_get_value(spin);
}

static GtkWidget* CreateBucketDetailUI(APPLICATION* app, BRUSH_CORE* core)
{
#define UI_FONT_SIZE 8.0
	BUCKET* bucket = (BUCKET*)core->brush_data;
	GtkWidget* vbox = gtk_vbox_new(FALSE, 0);
	GtkWidget* label;
	GtkWidget* table;
	GtkWidget* buttons[3];
	GtkWidget* threshold_scale;
	GtkAdjustment* threshold_adjustment;
	gchar mark_up_buff[256];

	label = gtk_label_new("");
	(void)sprintf(mark_up_buff, "<span font_desc=\"%.2f\">%s</span>",
		UI_FONT_SIZE * app->gui_scale, app->labels->tool_box.select.target);
	gtk_label_set_markup(GTK_LABEL(label), mark_up_buff);
	buttons[0] = gtk_radio_button_new_with_label(NULL, app->labels->tool_box.select.rgb);
	buttons[1] = gtk_radio_button_new_with_label(gtk_radio_button_get_group(GTK_RADIO_BUTTON(buttons[0])),
		app->labels->tool_box.select.rgba);
	buttons[2] = gtk_radio_button_new_with_label(gtk_radio_button_get_group(GTK_RADIO_BUTTON(buttons[0])),
		app->labels->tool_box.select.alpha);
	gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(buttons[bucket->mode]), TRUE);
	(void)g_signal_connect(G_OBJECT(buttons[0]), "toggled", G_CALLBACK(BucketSetModeRGB), core->brush_data);
	(void)g_signal_connect(G_OBJECT(buttons[1]), "toggled", G_CALLBACK(BucketSetModeRGBA), core->brush_data);
	(void)g_signal_connect(G_OBJECT(buttons[2]), "toggled", G_CALLBACK(BucketSetModeAlpha), core->brush_data);

	gtk_box_pack_start(GTK_BOX(vbox), label, FALSE, FALSE, 0);
	gtk_box_pack_start(GTK_BOX(vbox), buttons[0], FALSE, TRUE, 0);
	gtk_box_pack_start(GTK_BOX(vbox), buttons[1], FALSE, TRUE, 0);
	gtk_box_pack_start(GTK_BOX(vbox), buttons[2], FALSE, TRUE, 0);

	threshold_adjustment = GTK_ADJUSTMENT(gtk_adjustment_new(
		bucket->threshold, 0, 255, 1, 1, 0));
	g_signal_connect(G_OBJECT(threshold_adjustment), "value_changed",
		G_CALLBACK(BucketChangeThreshold), core->brush_data);
	threshold_scale = SpinScaleNew(threshold_adjustment,
		app->labels->tool_box.select.threshold, 0);
	table = gtk_table_new(1, 3, FALSE);
	gtk_table_attach_defaults(GTK_TABLE(table), threshold_scale, 0, 3, 0, 1);
	gtk_box_pack_start(GTK_BOX(vbox), table, FALSE, TRUE, 0);

	label = gtk_label_new("");
	(void)sprintf(mark_up_buff, "<span font_desc=\"%.2f\">%s</span>",
		UI_FONT_SIZE * app->gui_scale, app->labels->tool_box.select.area);
	gtk_label_set_markup(GTK_LABEL(label), mark_up_buff);
	buttons[0] = gtk_radio_button_new_with_label(NULL, app->labels->tool_box.select.active_layer);
	buttons[1] = gtk_radio_button_new_with_label(gtk_radio_button_get_group(GTK_RADIO_BUTTON(buttons[0])),
		app->labels->tool_box.select.canvas);
	gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(buttons[bucket->target]), TRUE);
	g_signal_connect(G_OBJECT(buttons[0]), "toggled", G_CALLBACK(BucketSetTargetActiveLayer), core->brush_data);
	g_signal_connect(G_OBJECT(buttons[1]), "toggled", G_CALLBACK(BucketSetTargetCanvas), core->brush_data);

	gtk_box_pack_start(GTK_BOX(vbox), label, FALSE, FALSE, 3);
	gtk_box_pack_start(GTK_BOX(vbox), buttons[0], FALSE, TRUE, 0);
	gtk_box_pack_start(GTK_BOX(vbox), buttons[1], FALSE, TRUE, 0);

	label = gtk_label_new("");
	(void)sprintf(mark_up_buff, "<span font_desc=\"%.2f\">%s</span>",
		UI_FONT_SIZE * app->gui_scale, app->labels->tool_box.select.detect_area);
	gtk_label_set_markup(GTK_LABEL(label), mark_up_buff);
	buttons[0] = gtk_radio_button_new_with_label(NULL, app->labels->tool_box.select.area_normal);
	buttons[1] = gtk_radio_button_new_with_label(gtk_radio_button_get_group(GTK_RADIO_BUTTON(buttons[0])),
		app->labels->tool_box.select.area_large);
	gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(buttons[bucket->select_direction]), TRUE);
	g_object_set_data(G_OBJECT(buttons[0]), "direction", GINT_TO_POINTER(FUZZY_SELECT_DIRECTION_QUAD));
	(void)g_signal_connect(G_OBJECT(buttons[0]), "toggled", G_CALLBACK(BucketSetSelectDirection), core->brush_data);
	g_object_set_data(G_OBJECT(buttons[1]), "direction", GINT_TO_POINTER(FUZZY_SELECT_DIRECTION_OCT));
	(void)g_signal_connect(G_OBJECT(buttons[1]), "toggled", G_CALLBACK(BucketSetSelectDirection), core->brush_data);

	gtk_box_pack_start(GTK_BOX(vbox), label, FALSE, FALSE, 3);
	gtk_box_pack_start(GTK_BOX(vbox), buttons[0], FALSE, TRUE, 0);
	gtk_box_pack_start(GTK_BOX(vbox), buttons[1], FALSE, TRUE, 0);

	buttons[0] = gtk_check_button_new_with_label(app->labels->tool_box.anti_alias);
	gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(buttons[0]), bucket->flags & BUCKET_FLAG_ANTI_ALIAS);
	g_signal_connect(G_OBJECT(buttons[0]), "toggled", G_CALLBACK(BucketChangeAntiAlias), core->brush_data);
	gtk_box_pack_start(GTK_BOX(vbox), buttons[0], FALSE, TRUE, 3);

	threshold_adjustment = GTK_ADJUSTMENT(gtk_adjustment_new(bucket->extend, -50, 50, 1, 1, 0));
	threshold_scale = SpinScaleNew(threshold_adjustment, app->labels->tool_box.extend, 0);
	(void)g_signal_connect(G_OBJECT(threshold_adjustment), "value_changed",
		G_CALLBACK(BucketChangeExtend), bucket);
	gtk_box_pack_start(GTK_BOX(vbox), threshold_scale, FALSE, FALSE, 2);

	return vbox;
#undef UI_FONT_SIZE
}

/*********************************************************************
* PaternFillPressCallBack関数                                        *
* パターン塗り潰しツールでマウスクリックされたときのコールバック関数 *
* 引数                                                               *
* window	: 描画領域の情報                                         *
* x			: マウスのX座標                                          *
* y			: マウスのY座標                                          *
* pressure	: 筆圧                                                   *
* core		: ツールの基本情報                                       *
* state		: マウスの状態                                           *
*********************************************************************/
static void PatternFillPressCallBack(
	DRAW_WINDOW* window,
	FLOAT_T x,
	FLOAT_T y,
	FLOAT_T pressure,
	BRUSH_CORE *core,
	void* state
)
{
	// 描画領域外のクリックなら終了
	if(x < 0 || x > window->width || y < 0 || y > window->height)
	{
		return;
	}

	// 左クリックなら
	if(((GdkEventButton*)state)->button == 1)
	{
		// パターンツールの詳細データにキャスト
		PATTERN_FILL* fill = (PATTERN_FILL*)core->brush_data;
		// 塗り潰すレイヤー
		LAYER* target;
		// 塗り潰す範囲のバッファ
		uint8* buff = &window->temp_layer->pixels[window->width*window->height];
		// 塗り潰した座標の最小最大値
		int32 min_x, min_y, max_x, max_y;
		// 塗り潰し範囲を決定するためのチャンネル数
		uint8 channel = (fill->mode == PATTERN_FILL_RGB) ? 3 : 4;
		// 塗り潰しに使用するパターンのサーフェース
		cairo_surface_t* pattern_surface = CreatePatternSurface(
			&window->app->patterns, *core->color, *core->back_color, fill->pattern_flags,
			fill->pattern_mode, fill->flow);
		// 塗り潰しパターン
		cairo_pattern_t* pattern;
		// 拡大縮小率
		FLOAT_T zoom = 1 / (fill->scale * 0.01);
		// パターンに拡大縮小率セットするための行列
		cairo_matrix_t matrix;
		// for文用のカウンタ
		int i;

		// パターンサーフェース作成に失敗したら終了
		if(pattern_surface == NULL)
		{
			return;
		}

		// 選択範囲があるときはクリックされた位置が選択範囲内であることを確認
		if((window->flags & DRAW_WINDOW_HAS_SELECTION_AREA) != 0)
		{
			if(window->selection->pixels[(int)y*window->selection->width+(int)x] < 0x80)
			{
				return;
			}
		}

		if((window->active_layer->flags & LAYER_LOCK_OPACITY) == 0)
		{
			window->work_layer->layer_mode = LAYER_BLEND_NORMAL;
		}
		else
		{
			window->work_layer->layer_mode = LAYER_BLEND_ATOP;
		}

		// 塗り潰すターゲットを決定
		switch(fill->target)
		{
		case PATTERN_FILL_TARGET_ACTIVE_LAYER:
			target = window->active_layer;
			break;
		case PATTERN_FILL_TARGET_CANVAS:
			target = MixLayerForSave(window);
			break;
		default:
			target = NULL;
		}

		// 塗り潰す範囲を決定
		(void)memset(window->mask_temp->pixels, 0, window->pixel_buf_size);
		(void)memset(window->temp_layer->pixels, 0, window->pixel_buf_size);

		if(fill->mode != PATTERN_FILL_ALPHA)
		{	// 不透明度以外での塗りつぶし範囲決定ならば
			DetectSameColorArea(
				target,
				buff,
				&window->temp_layer->pixels[window->width*window->height*2],
				(int32)x, (int32)y,
				&target->pixels[(int32)y*target->stride + (int32)x*target->channel],
				channel, fill->threshold, &min_x, &min_y, &max_x, &max_y,
				(eSELECT_FUZZY_DIRECTION)fill->area_detect_direction
			);
		}
		else
		{	// それ以外は一度不透明度情報のみのレイヤーを作成する
			LAYER *local_target = CreateLayer(0, 0, target->width, target->height, 1,
				TYPE_NORMAL_LAYER, NULL, NULL, NULL, window);

			for(i=0; i<target->width*target->height; i++)
			{
				local_target->pixels[i] = target->pixels[i*4+3];
			}

			DetectSameColorArea(
				local_target,
				buff,
				&window->temp_layer->pixels[window->width*window->height*2],
				(int32)x, (int32)y,
				&target->pixels[(int32)y*target->stride + (int32)x*target->channel],
				channel, fill->threshold, &min_x, &min_y, &max_x, &max_y,
				(eSELECT_FUZZY_DIRECTION)fill->area_detect_direction
			);

			DeleteLayer(&local_target);
		}

		if((fill->flags & PATTERN_FILL_FLAG_ANTI_ALIAS) != 0)
		{
			(void)memcpy(&window->temp_layer->pixels[window->width*window->height*2],
				buff, window->width*window->height);
			AntiAlias(&window->temp_layer->pixels[window->width*window->height*2],
				buff, window->width, window->height, window->width, 1);
		}

		core->min_x = min_x - 1, core->min_y = min_y - 1;
		core->max_x = max_x + 1, core->max_y = max_y + 1;

#ifdef _OPENMP
#pragma omp parallel for
#endif
		for(i=0; i<window->mask_temp->width*window->mask->height; i++)
		{
			window->mask_temp->pixels[i*4] = buff[i];
			window->mask_temp->pixels[i*4+1] = buff[i];
			window->mask_temp->pixels[i*4+2] = buff[i];
			window->mask_temp->pixels[i*4+3] = buff[i];
		}

		if(fill->extend > 0)
		{
			(void)memcpy(window->mask_temp->pixels, buff,
				window->mask_temp->height * window->mask_temp->width);

			for(i=0; i<fill->extend; i++)
			{
				ExtendSelectionAreaOneStep(window->mask_temp, window->temp_layer);
				(void)memcpy(window->mask_temp->pixels, window->temp_layer->pixels,
					window->mask_temp->width*window->mask_temp->height);
				core->min_x -= 1, core->min_y -= 1;
				core->max_x += 1, core->max_y += 1;
			}

			for(i=0; i<window->mask_temp->width*window->mask->height; i++)
			{
				window->mask_temp->pixels[i*4] = buff[i];
				window->mask_temp->pixels[i*4+1] = buff[i];
				window->mask_temp->pixels[i*4+2] = buff[i];
				window->mask_temp->pixels[i*4+3] = buff[i];
			}
		}
		else
		{
			int end = abs(fill->extend);

			(void)memcpy(window->mask_temp->pixels, buff,
				window->mask_temp->height * window->mask_temp->width);

			for(i=0; i<end; i++)
			{
				ReductSelectionAreaOneStep(window->mask_temp, window->temp_layer);
				(void)memcpy(window->mask_temp->pixels, window->temp_layer->pixels,
					window->mask_temp->width*window->mask_temp->height);
			}

#ifdef _OPENMP
#pragma omp parallel for
#endif
			for(i=0; i<window->mask_temp->width*window->mask->height; i++)
			{
				window->mask_temp->pixels[i*4] = buff[i];
				window->mask_temp->pixels[i*4+1] = buff[i];
				window->mask_temp->pixels[i*4+2] = buff[i];
				window->mask_temp->pixels[i*4+3] = buff[i];
			}
		}

		// 塗り潰し実行
		cairo_set_operator(window->work_layer->cairo_p, CAIRO_OPERATOR_OVER);
		pattern = cairo_pattern_create_for_surface(pattern_surface);
		cairo_matrix_init_scale(&matrix, zoom, zoom);
		cairo_pattern_set_matrix(pattern, &matrix);
		cairo_pattern_set_extend(pattern, CAIRO_EXTEND_REPEAT);

		if((window->flags & DRAW_WINDOW_HAS_SELECTION_AREA) == 0)
		{	// 選択範囲なし
			cairo_set_source(window->work_layer->cairo_p, pattern);
			cairo_rectangle(window->work_layer->cairo_p, 0, 0,
				window->work_layer->width, window->work_layer->height);
			cairo_mask_surface(window->work_layer->cairo_p, window->mask_temp->surface_p, 0, 0);
		}
		else
		{	// 選択範囲あり
			cairo_set_source(window->temp_layer->cairo_p, pattern);
			(void)memset(window->temp_layer->pixels, 0, window->pixel_buf_size);
			cairo_set_operator(window->temp_layer->cairo_p, CAIRO_OPERATOR_OVER);
			cairo_rectangle(window->temp_layer->cairo_p, 0, 0, window->width, window->height);
			cairo_mask_surface(window->temp_layer->cairo_p, window->mask_temp->surface_p, 0, 0);
			cairo_set_source_surface(window->work_layer->cairo_p, window->temp_layer->surface_p, 0, 0);
			cairo_mask_surface(window->work_layer->cairo_p, window->selection->surface_p, 0, 0);
		}

		cairo_pattern_destroy(pattern);
		cairo_surface_destroy(pattern_surface);

		AddBrushHistory(core, window->active_layer);

		window->layer_blend_functions[window->work_layer->layer_mode](window->work_layer, window->active_layer);

		(void)memset(window->work_layer->pixels, 0, window->work_layer->stride*window->work_layer->height);

		if(fill->target == PATTERN_FILL_TARGET_CANVAS)
		{
			DeleteLayer(&target);
		}

		window->work_layer->layer_mode = LAYER_BLEND_NORMAL;
	}
}

/*************************************************************************************
* PaternFillEditSelectionPressCallBack関数                                           *
* 選択範囲編集中にパターン塗り潰しツールでマウスクリックされたときのコールバック関数 *
* 引数                                                                               *
* window	: 描画領域の情報                                                         *
* x			: マウスのX座標                                                          *
* y			: マウスのY座標                                                          *
* pressure	: 筆圧                                                                   *
* core		: ツールの基本情報                                                       *
* state		: マウスの状態                                                           *
*************************************************************************************/
static void PatternFillEditSelectionPressCallBack(
	DRAW_WINDOW* window,
	FLOAT_T x,
	FLOAT_T y,
	FLOAT_T pressure,
	BRUSH_CORE *core,
	void* state
)
{
	// 左クリックなら
	if(((GdkEventButton*)state)->button == 1)
	{
		// パターンツールの詳細データにキャスト
		PATTERN_FILL* fill = (PATTERN_FILL*)core->brush_data;
		// 塗り潰すレイヤー
		LAYER* target = window->mask;
		// 塗り潰す範囲のバッファ
		uint8* buff = &window->temp_layer->pixels[window->width*window->height];
		// 塗り潰した座標の最小最大値
		int32 min_x, min_y, max_x, max_y;
		// 塗り潰し範囲を決定するためのチャンネル数
		uint8 channel = 1;
		// 塗り潰しに使用するパターンのサーフェース
		cairo_surface_t* pattern_surface = CreatePatternSurface(
			&window->app->patterns, *core->color, *core->back_color, fill->pattern_flags,
			fill->pattern_mode, fill->flow);
		// 塗り潰しパターン
		cairo_pattern_t* pattern;
		// 拡大縮小率
		FLOAT_T zoom = 1 / (fill->scale * 0.01);
		// パターンに拡大縮小率セットするための行列
		cairo_matrix_t matrix;
		// 現在のマスクレイヤーのチャンネルと1行分のバイト数を記憶
		uint8 before_channel = target->channel;
		int32 before_stride = target->stride;
		// for文用のカウンタ
		int i;

		// パターンサーフェース作成に失敗したら終了
		if(pattern_surface == NULL)
		{
			return;
		}

		// 塗り潰す範囲を決定
		(void)memcpy(window->mask->pixels, window->selection->pixels, window->width*window->height);
		(void)memset(window->mask_temp->pixels, 0, window->pixel_buf_size);
		(void)memset(window->temp_layer->pixels, 0, window->pixel_buf_size);

		target->channel = 1;
		target->stride = target->width;
		DetectSameColorArea(
			target,
			buff,
			&window->temp_layer->pixels[window->width*window->height*2],
			(int32)x, (int32)y,
			&target->pixels[(int32)y*target->stride + (int32)x*target->channel],
			channel, fill->threshold, &min_x, &min_y, &max_x, &max_y,
			(eSELECT_FUZZY_DIRECTION)fill->area_detect_direction
		);
		target->channel = before_channel;
		target->stride = before_stride;

		if((fill->flags & PATTERN_FILL_FLAG_ANTI_ALIAS) != 0)
		{
			(void)memcpy(&window->temp_layer->pixels[window->width*window->height*2],
				buff, window->width*window->height);
			AntiAlias(&window->temp_layer->pixels[window->width*window->height*2],
				buff, window->width, window->height, window->width, 1);
		}

		core->min_x = min_x - 1, core->min_y = min_y - 1;
		core->max_x = max_x + 1, core->max_y = max_y + 1;

		for(i=0; i<window->mask_temp->width*window->mask->height; i++)
		{
			window->mask_temp->pixels[i*4] = buff[i];
			window->mask_temp->pixels[i*4+1] = buff[i];
			window->mask_temp->pixels[i*4+2] = buff[i];
			window->mask_temp->pixels[i*4+3] = buff[i];
		}

		if(fill->extend > 0)
		{
			for(i=0; i<fill->extend; i++)
			{
				ExtendSelectionAreaOneStep(window->mask_temp, window->temp_layer);
				(void)memcpy(window->mask_temp->pixels, window->temp_layer->pixels,
					window->mask_temp->width*window->mask_temp->height);
				core->min_x -= 1, core->min_y -= 1;
				core->max_x += 1, core->max_y += 1;
			}
		}
		else
		{
			int end = abs(fill->extend);

			for(i=0; i<end; i++)
			{
				ReductSelectionAreaOneStep(window->mask_temp, window->temp_layer);
				(void)memcpy(window->mask_temp->pixels, window->temp_layer->pixels,
					window->mask_temp->width*window->mask_temp->height);
			}
		}

		// 塗り潰し実行
		cairo_set_operator(window->work_layer->cairo_p, CAIRO_OPERATOR_OVER);
		pattern = cairo_pattern_create_for_surface(pattern_surface);
		cairo_matrix_init_scale(&matrix, zoom, zoom);
		cairo_pattern_set_matrix(pattern, &matrix);
		cairo_pattern_set_extend(pattern, CAIRO_EXTEND_REPEAT);

		cairo_set_source(window->work_layer->cairo_p, pattern);
		cairo_rectangle(window->work_layer->cairo_p, 0, 0,
			window->work_layer->width, window->work_layer->height);
		cairo_mask_surface(window->work_layer->cairo_p, window->mask_temp->surface_p, 0, 0);

		cairo_pattern_destroy(pattern);
		cairo_surface_destroy(pattern_surface);

		AddSelectionEditHistory(core, window->selection);

		g_blend_selection_funcs[SELECTION_BLEND_NORMAL](window->work_layer, window->selection);

		(void)memset(window->work_layer->pixels, 0, window->work_layer->stride*window->work_layer->height);

		window->work_layer->layer_mode = LAYER_BLEND_NORMAL;
	}
}

#define PatternFillMotionCallBack DummyBrushCallBack
#define PatternFillEditSelectionMotionCallBack DummyBrushCallBack
#define PatternFillReleaseCallBack DummyBrushCallBack
#define PatternFillEditSelectionReleaseCallBack DummyBrushCallBack
#define PatternFillDrawCursor DummyBrushDrawCursor

static void PatternFillSetMode(GtkWidget* widget, PATTERN_FILL* fill)
{
	fill->mode = (uint8)GPOINTER_TO_INT(g_object_get_data(G_OBJECT(widget), "fill-mode"));
}

static void PatternFillChangeThreshold(GtkWidget* widget, PATTERN_FILL* fill)
{
	fill->threshold = (uint16)gtk_adjustment_get_value(GTK_ADJUSTMENT(widget));
	gtk_adjustment_set_value(GTK_ADJUSTMENT(widget), fill->threshold);
}

static void PatternFillSetTarget(GtkWidget* widget, PATTERN_FILL* fill)
{
	fill->target = (uint8)GPOINTER_TO_INT(g_object_get_data(G_OBJECT(widget), "fill-target"));
}

static void PatternFillChangeScale(GtkAdjustment* slider, PATTERN_FILL* fill)
{
	fill->scale = gtk_adjustment_get_value(slider);
	fill->app->patterns.scale = fill->scale;
}

static void PatternFillChangeFlow(GtkAdjustment* slider, PATTERN_FILL* fill)
{
	fill->flow = gtk_adjustment_get_value(slider) * 0.01f;
}

static void PatternFillSetPatternFlag(GtkWidget* widget, PATTERN_FILL* fill)
{
	int flag_id = GPOINTER_TO_INT(g_object_get_data(G_OBJECT(widget), "flag-id"));

	if(gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(widget)) == FALSE)
	{
		fill->pattern_flags &= ~(1 << flag_id);
	}
	else
	{
		fill->pattern_flags |= (1 << flag_id);
	}
}

static void PatternFillSetBlendMode(GtkWidget* widget, PATTERN_FILL* fill)
{
	fill->pattern_mode = (uint8)GPOINTER_TO_INT(g_object_get_data(G_OBJECT(widget), "blend-mode"));
}

static void PatternFillChangeAntiAlias(GtkToggleButton* button, PATTERN_FILL* fill)
{
	if(gtk_toggle_button_get_active(button) == FALSE)
	{
		fill->flags &= ~(PATTERN_FILL_FLAG_ANTI_ALIAS);
	}
	else
	{
		fill->flags |= PATTERN_FILL_FLAG_ANTI_ALIAS;
	}
}

/***************************************************************
* PatternSelectButtonClicked関数                               *
* パターン選択用のボタンがクリックされたときのコールバック関数 *
* 引数                                                         *
* button	: ボタンウィジェット                               *
* fill		: パターン塗り潰しの詳細データ                     *
***************************************************************/
static void PatternSelectButtonClicked(GtkWidget* button, PATTERN_FILL* fill)
{
	// パターンIDをウィジェットに登録されたデータから取得
	int pattern_id = GPOINTER_TO_INT(g_object_get_data(G_OBJECT(button), "pattern-id"));
	// ボタンID調整用
	int button_add = (fill->app->patterns.has_clip_board_pattern == FALSE) ? 0 : -1;
	// for文用のカウンタ
	int i;

	// 使用パターンと押されたボタンが一致していたらボタンをアクティブにして終了
	if(pattern_id == fill->pattern_id)
	{
		if(gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(button)) == FALSE)
		{
			gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(button), TRUE);
		}
		return;
	}
	else if(gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(button)) == FALSE)
	{	// 使用パターンと不一致でボタンが非アクティブなら終了
		return;
	}

	// 使用パターンを設定
	fill->pattern_id = pattern_id;
	if(fill->app->patterns.has_clip_board_pattern != FALSE && fill->pattern_id == 0)
	{
		fill->app->patterns.active_pattern =
			&fill->app->patterns.clip_board;
	}
	else
	{
		fill->app->patterns.active_pattern =
			&fill->app->patterns.patterns[pattern_id + button_add];
	}

	// アクティブなパターンがチャンネル数2以外ならば合成モードは無効
	gtk_widget_set_sensitive(fill->mode_select[0], fill->app->patterns.active_pattern->channel == 2);
	gtk_widget_set_sensitive(fill->mode_select[1], fill->app->patterns.active_pattern->channel == 2);

	// 他のボタンを非アクティブにする
	for(i=0; i<fill->num_button; i++)
	{
		if(i == fill->pattern_id)
		{
			if(gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(fill->buttons[i])) == FALSE)
			{
				gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(fill->buttons[i]), TRUE);
			}
		}
		else
		{
			if(gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(fill->buttons[i])) != FALSE)
			{
				gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(fill->buttons[i]), FALSE);
			}
		}
	}
}

// パターン選択用テーブルの幅
#define PATTERN_SELECT_TABLE_WIDTH 4

/*********************************************
* CreatePatternSelectTable関数               *
* パターン選択用のボタンテーブルを作成する   *
* 引数                                       *
* fill	: パターン塗り潰しツールの詳細データ *
* 返り値                                     *
*	作成したボタンテーブルのウィジェット     *
*********************************************/
static GtkWidget* CreatePatternSelectTable(PATTERN_FILL* fill)
{
// ボタンに表示するアイコンのサイズ
#define ICON_SIZE 32
	// 返り値
	GtkWidget *table;
	// ボタンに登録するイメージウィジェット
	GtkWidget *image;
	// テーブルの高さ
	int height;
	// ボタンのイメージ作成用ピクセルバッファ
	GdkPixbuf *pixbuf;
	// チャンネル数が1のときに使用するピクセルデータ
	uint8 *pixels;
	// イメージの拡大率
	FLOAT_T zoom;
	// ボタンID調整用
	int button_add = 0;
	// テーブルの座標
	int x = 0, y = 0;
	// for文用のカウンタ
	int i = 0, j;

	// ボタン配列作成
	fill->buttons = (GtkWidget**)MEM_ALLOC_FUNC(
		sizeof(*fill->buttons)*(fill->app->patterns.num_pattern+1));
	fill->num_button = fill->app->patterns.num_pattern;

	// テーブルの高さを決定して作成
	height = fill->num_button / PATTERN_SELECT_TABLE_WIDTH;
	if(fill->num_button % PATTERN_SELECT_TABLE_WIDTH != 0)
	{
		height++;
	}
	table = gtk_table_new(height, PATTERN_SELECT_TABLE_WIDTH, TRUE);

	// クリップボードのパターンがあるならば
	if(fill->app->patterns.has_clip_board_pattern != FALSE)
	{
		PATTERN* pattern = &fill->app->patterns.clip_board;

		pixbuf = gdk_pixbuf_new_from_data(pattern->pixels,
			GDK_COLORSPACE_RGB, TRUE, 8, pattern->width, pattern->height,
			pattern->stride, NULL, NULL
		);

		// 拡大率を計算
		if(pattern->width > pattern->height)
		{
			zoom = ICON_SIZE / (FLOAT_T)pattern->width;
		}
		else
		{
			zoom = ICON_SIZE / (FLOAT_T)pattern->height;
		}

		// ピクセルバッファを拡大縮小してイメージウィジェット作成
		image = gtk_image_new_from_pixbuf(
			gdk_pixbuf_scale_simple(pixbuf, (int)(pattern->width*zoom),
			(int)(pattern->height*zoom), GDK_INTERP_BILINEAR)
		);

		// ボタン作成
		fill->buttons[i] = gtk_toggle_button_new();
		// 現在の使用パターンと一致していたらアクティブに
		if(i == fill->pattern_id + button_add)
		{
			gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(fill->buttons[i]), TRUE);
		}

		// コールバック関数とデータをセット
		(void)g_signal_connect(G_OBJECT(fill->buttons[i]), "toggled", G_CALLBACK(PatternSelectButtonClicked), fill);
		g_object_set_data(G_OBJECT(fill->buttons[i]), "pattern-id", GINT_TO_POINTER(i));

		// テーブルにボタン追加
		gtk_table_attach(GTK_TABLE(table), fill->buttons[i], x, x+1, y, y+1, GTK_SHRINK, GTK_SHRINK, 0, 0);

		// イメージウィジェットをボタンに登録
		gtk_container_add(GTK_CONTAINER(fill->buttons[i]), image);

		g_object_unref(pixbuf);
		fill->num_button++;
		button_add = -1;
		i++, x++;
	}

	// ボタンを作成してテーブルに入れる
	for( ; i<fill->num_button; i++, x++)
	{
		// ボタンに入れるパターン
		PATTERN* pattern = &fill->app->patterns.patterns[i+button_add];

		// 一行分埋まったら次の行へ
		if(x == PATTERN_SELECT_TABLE_WIDTH)
		{
			x = 0;
			y++;
		}

		pixels = NULL;
		// グレースケールならRGBにする
		if(pattern->channel == 1)
		{
			uint8 pixel_value;
			pixels = (uint8*)MEM_ALLOC_FUNC(pattern->width*pattern->height*3);
			for(j=0; j<pattern->width*pattern->height; j++)
			{
				pixel_value = 0xff - pattern->pixels[j];
				pixels[j*3] = pixel_value;
				pixels[j*3+1] = pixel_value;
				pixels[j*3+2] = pixel_value;
			}
			pixbuf = gdk_pixbuf_new_from_data(
				pixels, GDK_COLORSPACE_RGB, FALSE, 8,
				pattern->width, pattern->height, pattern->width*3, NULL, NULL
			);
		}
		else if(pattern->channel == 2)
		{
			uint8 pixel_value;
			pixels = (uint8*)MEM_ALLOC_FUNC(pattern->width*pattern->height*4);
			for(j=0; j<pattern->width*pattern->height; j++)
			{
				pixel_value = pattern->pixels[j*2];
				pixels[j*4] = pixel_value;
				pixels[j*4+1] = pixel_value;
				pixels[j*4+2] = pixel_value;
				pixels[j*4+3] = pattern->pixels[j*2+1];
			}
			pixbuf = gdk_pixbuf_new_from_data(
				pixels, GDK_COLORSPACE_RGB, TRUE, 8,
				pattern->width, pattern->height, pattern->width*4, NULL, NULL
			);
		}
		else
		{
			// パターンのピクセルデータからピクセルバッファ作成
			pixbuf = gdk_pixbuf_new_from_data(pattern->pixels, GDK_COLORSPACE_RGB,
				pattern->channel == 4, 8, pattern->width, pattern->height, pattern->width*pattern->channel,
				NULL, NULL
			);
		}

		// 拡大率を計算
		if(pattern->width > pattern->height)
		{
			zoom = ICON_SIZE / (FLOAT_T)pattern->width;
		}
		else
		{
			zoom = ICON_SIZE / (FLOAT_T)pattern->height;
		}

		// ピクセルバッファを拡大縮小してイメージウィジェット作成
		image = gtk_image_new_from_pixbuf(
			gdk_pixbuf_scale_simple(pixbuf, (int)(pattern->width*zoom),
			(int)(pattern->height*zoom), GDK_INTERP_BILINEAR)
		);

		// ボタン作成
		fill->buttons[i] = gtk_toggle_button_new();
		// 現在の使用パターンと一致していたらアクティブに
		if(i == fill->pattern_id + button_add)
		{
			gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(fill->buttons[i]), TRUE);
		}

		// コールバック関数とデータをセット
		(void)g_signal_connect(G_OBJECT(fill->buttons[i]), "toggled", G_CALLBACK(PatternSelectButtonClicked), fill);
		g_object_set_data(G_OBJECT(fill->buttons[i]), "pattern-id", GINT_TO_POINTER(i));

		// テーブルにボタン追加
		gtk_table_attach(GTK_TABLE(table), fill->buttons[i], x, x+1, y, y+1, GTK_SHRINK, GTK_SHRINK, 0, 0);

		// イメージウィジェットをボタンに登録
		gtk_container_add(GTK_CONTAINER(fill->buttons[i]), image);

		g_object_unref(pixbuf);
		MEM_FREE_FUNC(pixels);
	}

	return table;
}

static void OnPatternFillDetailUIDestroy(GtkWidget* widget, PATTERN_FILL* fill)
{
	MEM_FREE_FUNC(fill->buttons);
}

static void PatternFillSetDetectDirection(GtkWidget* widget, PATTERN_FILL* fill)
{
	fill->area_detect_direction = (uint8)g_object_get_data(G_OBJECT(widget), "direction");
}

static void PatternFillSetExtend(GtkAdjustment* slider, PATTERN_FILL* fill)
{
	fill->extend = (int16)gtk_adjustment_get_value(slider);
}

/*****************************************************
* CreatePatternFillDetailUI関数                      *
* パターン塗り潰しの詳細設定ウィジェットを作成       *
* 引数                                               *
* app	: アプリケーションを管理する構造体のアドレス *
* data	: ツールの詳細データ                         *
* 返り値                                             *
*	作成したウィジェット                             *
*****************************************************/
static GtkWidget* CreatePatternFillDetailUI(APPLICATION* app, BRUSH_CORE* core)
{
#define UI_FONT_SIZE 8.0
	// パターン塗り潰しの詳細データにキャスト
	PATTERN_FILL* fill = (PATTERN_FILL*)core->brush_data;
	// ウィジェットを整列するためのパッキングボックス、テーブル
	GtkWidget* vbox = gtk_vbox_new(FALSE, 2);
	GtkWidget* table;
	// パターン選択用のテーブルスクロール用
	GtkWidget* scrolled_window = gtk_scrolled_window_new(NULL, NULL);
	// 塗り潰しモード、ターゲットを決定するためのラジオボタン
	GtkWidget* buttons[3], *label;
	// 塗り潰し範囲決定用の閾値、拡大率設定のためのスライダ
	GtkWidget* scale;
	// スライダ用のアジャスタ
	GtkAdjustment* adjustment;
	// 左右反転、上下反転用のチェックボックス
	GtkWidget* check_button;
	// ラベル文字サイズ決定用のマークアップバッファ
	char mark_up_buff[256];

	// アプリケーションの情報管理アドレスを登録
	fill->app = app;

	// クリップボードからパターンを取得
	UpdateClipBoardPattern(&app->patterns);

	// 塗り潰しモード決定用のラジオボタン作成とデータ、コールバック関数のセット
	label = gtk_label_new("");
	(void)sprintf(mark_up_buff, "<span font_desc=\"%.2f\">%s</span>",
		UI_FONT_SIZE * app->gui_scale, app->labels->tool_box.select.target);
	gtk_label_set_markup(GTK_LABEL(label), mark_up_buff);
	buttons[0] = gtk_radio_button_new_with_label(NULL, app->labels->tool_box.select.rgb);
	buttons[1] = gtk_radio_button_new_with_label(gtk_radio_button_get_group(GTK_RADIO_BUTTON(buttons[0])),
		app->labels->tool_box.select.rgba);
	buttons[2] = gtk_radio_button_new_with_label(gtk_radio_button_get_group(GTK_RADIO_BUTTON(buttons[0])),
		app->labels->tool_box.select.alpha);
	gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(buttons[fill->mode]), TRUE);
	g_object_set_data(G_OBJECT(buttons[0]), "fill-mode", GINT_TO_POINTER(0));
	(void)g_signal_connect(G_OBJECT(buttons[0]), "toggled", G_CALLBACK(PatternFillSetMode), core->brush_data);
	g_object_set_data(G_OBJECT(buttons[1]), "fill-mode", GINT_TO_POINTER(1));
	(void)g_signal_connect(G_OBJECT(buttons[1]), "toggled", G_CALLBACK(PatternFillSetMode), core->brush_data);
	g_object_set_data(G_OBJECT(buttons[2]), "fill-mode", GINT_TO_POINTER(2));
	(void)g_signal_connect(G_OBJECT(buttons[2]), "toggled", G_CALLBACK(PatternFillSetMode), core->brush_data);

	// 作成したラベルとラジオボタンをボックスに追加
	gtk_box_pack_start(GTK_BOX(vbox), label, FALSE, FALSE, 0);
	gtk_box_pack_start(GTK_BOX(vbox), buttons[0], FALSE, TRUE, 0);
	gtk_box_pack_start(GTK_BOX(vbox), buttons[1], FALSE, TRUE, 0);
	gtk_box_pack_start(GTK_BOX(vbox), buttons[2], FALSE, TRUE, 0);

	// 閾値決定用のスライダを作成
	adjustment = GTK_ADJUSTMENT(gtk_adjustment_new(
		fill->threshold, 0, 255, 1, 1, 0));
	(void)g_signal_connect(G_OBJECT(adjustment), "value_changed",
		G_CALLBACK(PatternFillChangeThreshold), core->brush_data);
	scale = SpinScaleNew(adjustment,
		app->labels->tool_box.select.threshold, 0);
	table = gtk_table_new(1, 3, FALSE);
	gtk_table_attach_defaults(GTK_TABLE(table), scale, 0, 3, 0, 1);
	gtk_box_pack_start(GTK_BOX(vbox), table, FALSE, TRUE, 0);

	// 塗り潰しターゲット決定用のラジオボタン作成とデータ、コールバック関数をセット
	label = gtk_label_new("");
	(void)sprintf(mark_up_buff, "<span font_desc=\"%.2f\">%s</span>",
		UI_FONT_SIZE * app->gui_scale, app->labels->tool_box.select.area);
	gtk_label_set_markup(GTK_LABEL(label), mark_up_buff);
	buttons[0] = gtk_radio_button_new_with_label(NULL, app->labels->tool_box.select.active_layer);
	buttons[1] = gtk_radio_button_new_with_label(gtk_radio_button_get_group(GTK_RADIO_BUTTON(buttons[0])),
		app->labels->tool_box.select.canvas);
	gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(buttons[fill->target]), TRUE);
	(void)g_signal_connect(G_OBJECT(buttons[0]), "toggled", G_CALLBACK(PatternFillSetTarget), core->brush_data);
	(void)g_signal_connect(G_OBJECT(buttons[1]), "toggled", G_CALLBACK(PatternFillSetTarget), core->brush_data);

	// 作成したラベルとラジオボタンをボックスに追加
	gtk_box_pack_start(GTK_BOX(vbox), label, FALSE, FALSE, 3);
	gtk_box_pack_start(GTK_BOX(vbox), buttons[0], FALSE, TRUE, 0);
	gtk_box_pack_start(GTK_BOX(vbox), buttons[1], FALSE, TRUE, 0);

	// パターンの拡大率決定用スライダ
	adjustment = GTK_ADJUSTMENT(gtk_adjustment_new(
		fill->scale, 10, 400, 1, 10, 0));
	(void)g_signal_connect(G_OBJECT(adjustment), "value_changed",
		G_CALLBACK(PatternFillChangeScale), core->brush_data);
	scale = SpinScaleNew(adjustment,
		app->labels->tool_box.scale, 1);
	// ボックスに追加
	gtk_box_pack_start(GTK_BOX(vbox), scale, FALSE, TRUE, 0);

	// 塗り潰し濃度設定用スライダ
	adjustment = GTK_ADJUSTMENT(gtk_adjustment_new(
		fill->flow*100, 0, 100, 1, 10, 0));
	g_signal_connect(G_OBJECT(adjustment), "value_changed",
		G_CALLBACK(PatternFillChangeFlow), core->brush_data);
	scale = SpinScaleNew(adjustment,
		app->labels->tool_box.flow, 1);
	table = gtk_table_new(1, 3, FALSE);
	gtk_table_attach_defaults(GTK_TABLE(table), scale, 0, 3, 0, 1);
	gtk_box_pack_start(GTK_BOX(vbox), table, FALSE, TRUE, 0);

	// 左右反転、上下反転選択用チェックボックス
	table = gtk_hbox_new(FALSE, 0);
	label = gtk_label_new("");
	(void)sprintf(mark_up_buff, "<span font_desc=\"%.2f\">%s : </span>",
		UI_FONT_SIZE * app->gui_scale, app->labels->tool_box.reverse);
	gtk_label_set_markup(GTK_LABEL(label), mark_up_buff);
	gtk_box_pack_start(GTK_BOX(table), label, FALSE, FALSE, 0);
	check_button = gtk_check_button_new_with_label(app->labels->tool_box.reverse_horizontally);
	g_object_set_data(G_OBJECT(check_button), "flag-id", GINT_TO_POINTER(0));
	gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(check_button),
		fill->pattern_flags & PATTERN_FLIP_HORIZONTALLY);
	(void)g_signal_connect(G_OBJECT(check_button), "toggled", G_CALLBACK(PatternFillSetPatternFlag), core->brush_data);
	gtk_box_pack_start(GTK_BOX(table), check_button, FALSE, TRUE, 0);
	check_button = gtk_check_button_new_with_label(app->labels->tool_box.reverse_vertically);
	g_object_set_data(G_OBJECT(check_button), "flag-id", GINT_TO_POINTER(1));
	gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(check_button),
		fill->pattern_flags & PATTERN_FLIP_VERTICALLY);
	(void)g_signal_connect(G_OBJECT(check_button), "toggled", G_CALLBACK(PatternFillSetPatternFlag), core->brush_data);
	gtk_box_pack_start(GTK_BOX(table), check_button, FALSE, TRUE, 0);
	gtk_box_pack_start(GTK_BOX(vbox), table, FALSE, TRUE, 0);

	// 合成モード選択ラジオボタン
	table = gtk_hbox_new(FALSE, 0);
	label = gtk_label_new("");
	(void)sprintf(mark_up_buff, "<span font_desc=\"%.2f\">%s : </span>",
		UI_FONT_SIZE * app->gui_scale, app->labels->tool_box.blend_mode);
	gtk_label_set_markup(GTK_LABEL(label), mark_up_buff);
	fill->mode_select[0] = gtk_radio_button_new_with_label(NULL, app->labels->tool_box.saturation);
	g_object_set_data(G_OBJECT(fill->mode_select[0]), "blend-mode", GINT_TO_POINTER(0));
	(void)g_signal_connect(G_OBJECT(fill->mode_select[0]), "toggled", G_CALLBACK(PatternFillSetBlendMode), core->brush_data);
	fill->mode_select[1] = gtk_radio_button_new_with_label(gtk_radio_button_get_group(GTK_RADIO_BUTTON(fill->mode_select[0])),
		app->labels->tool_box.brightness);
	g_object_set_data(G_OBJECT(fill->mode_select[1]), "blend-mode", GINT_TO_POINTER(1));
	(void)g_signal_connect(G_OBJECT(fill->mode_select[1]), "toggled", G_CALLBACK(PatternFillSetBlendMode), core->brush_data);
	gtk_box_pack_start(GTK_BOX(table), fill->mode_select[0], FALSE, TRUE, 0);
	gtk_box_pack_start(GTK_BOX(table), fill->mode_select[1], FALSE, TRUE, 0);
	gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(fill->mode_select[fill->mode]), TRUE);
	gtk_box_pack_start(GTK_BOX(vbox), table, FALSE, FALSE, 0);

	// パターン選択テーブルを作成してスクロールドウィンドウに入れる
	gtk_widget_set_size_request(scrolled_window,
		ICON_SIZE*PATTERN_SELECT_TABLE_WIDTH+4, ICON_SIZE*4+4);
	gtk_scrolled_window_set_policy(GTK_SCROLLED_WINDOW(scrolled_window),
		GTK_POLICY_NEVER, GTK_POLICY_AUTOMATIC);
	gtk_scrolled_window_add_with_viewport(GTK_SCROLLED_WINDOW(scrolled_window),
		CreatePatternSelectTable(fill));
	gtk_box_pack_start(GTK_BOX(vbox), scrolled_window, FALSE, FALSE, 0);

	// 詳細設定のUIが閉じられるときにボタン配列を開放する
	(void)g_signal_connect(G_OBJECT(vbox), "destroy", G_CALLBACK(OnPatternFillDetailUIDestroy), fill);

	// クリップボードのパターンがアクティブならばセット
	if(app->patterns.has_clip_board_pattern != FALSE)
	{
		if(fill->pattern_id == 0)
		{
			app->patterns.active_pattern =
				&app->patterns.clip_board;
		}
		else
		{
			app->patterns.active_pattern =
				&app->patterns.patterns[fill->pattern_id-1];
		}
	}

	// アクティブなパターンがチャンネル数2以外ならば合成モードは無効
	gtk_widget_set_sensitive(fill->mode_select[0], app->patterns.active_pattern->channel == 2);
	gtk_widget_set_sensitive(fill->mode_select[1], app->patterns.active_pattern->channel == 2);

	// 検出方向選択用ラジオボタン
	table = gtk_hbox_new(FALSE, 0);
	label = gtk_label_new("");
	(void)sprintf(mark_up_buff, "<span font_desc=\"%.2f\">%s</span>",
		UI_FONT_SIZE * app->gui_scale, app->labels->tool_box.select.detect_area);
	gtk_label_set_markup(GTK_LABEL(label), mark_up_buff);
	gtk_box_pack_start(GTK_BOX(vbox), label, FALSE, FALSE, 5);
	buttons[0] = gtk_radio_button_new_with_label(NULL, app->labels->tool_box.select.area_normal);
	g_object_set_data(G_OBJECT(buttons[0]), "direction", GINT_TO_POINTER(FUZZY_SELECT_DIRECTION_QUAD));
	(void)g_signal_connect(G_OBJECT(buttons[0]), "toggled", G_CALLBACK(PatternFillSetDetectDirection), core->brush_data);
	buttons[1] = gtk_radio_button_new_with_label(gtk_radio_button_get_group(GTK_RADIO_BUTTON(buttons[0])),
		app->labels->tool_box.select.area_large);
	g_object_set_data(G_OBJECT(buttons[1]), "direction", GINT_TO_POINTER(FUZZY_SELECT_DIRECTION_OCT));
	(void)g_signal_connect(G_OBJECT(buttons[1]), "toggled", G_CALLBACK(PatternFillSetDetectDirection), core->brush_data);
	gtk_box_pack_start(GTK_BOX(table), buttons[0], FALSE, TRUE, 0);
	gtk_box_pack_start(GTK_BOX(table), buttons[1], FALSE, TRUE, 0);
	gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(buttons[fill->area_detect_direction]), TRUE);
	gtk_box_pack_start(GTK_BOX(vbox), table, FALSE, FALSE, 0);

	buttons[0] = gtk_check_button_new_with_label(app->labels->tool_box.anti_alias);
	gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(buttons[0]), fill->flags & PATTERN_FILL_FLAG_ANTI_ALIAS);
	(void)g_signal_connect(GTK_BOX(vbox), "toggled", G_CALLBACK(PatternFillChangeAntiAlias), core->brush_data);
	gtk_box_pack_start(GTK_BOX(vbox), buttons[0], FALSE, FALSE, 3);

	// 塗りつぶし範囲の拡大縮小スライダ
	adjustment = GTK_ADJUSTMENT(gtk_adjustment_new(fill->extend, -50, 50, 1, 1, 0));
	scale = SpinScaleNew(adjustment, app->labels->tool_box.extend, 0);
	(void)g_signal_connect(G_OBJECT(scale), "value_changed", G_CALLBACK(PatternFillSetExtend), fill);
	gtk_box_pack_start(GTK_BOX(vbox), scale, FALSE, FALSE, 2);

	return vbox;
#undef UI_FONT_SIZE
#undef ICON_SIZE
}

static void GradationPressCallBack(
	DRAW_WINDOW* window,
	FLOAT_T x,
	FLOAT_T y,
	FLOAT_T pressure,
	BRUSH_CORE *core,
	void* state
)
{
	if(((GdkEventButton*)state)->button == 1)
	{
		GRADATION* gradation = (GRADATION*)core->brush_data;
		gradation->start_x = x;
		gradation->start_y = y;
		gradation->end_x = x;
		gradation->end_y = y;
		gradation->flags |= GRADATION_STARTED;
	}
}

#define GradationEditSelectionPressCallBack GradationPressCallBack

static void GradationMotionCallBack(
	DRAW_WINDOW* window,
	FLOAT_T x,
	FLOAT_T y,
	FLOAT_T pressure,
	BRUSH_CORE *core,
	void* state
)
{
	if(((*(GdkModifierType*)state) & GDK_BUTTON1_MASK) != 0)
	{
		GRADATION* gradation = (GRADATION*)core->brush_data;
		if((gradation->flags & GRADATION_STARTED) != 0)
		{
			gradation->end_x = x;
			gradation->end_y = y;
		}
	}
}

#define GradationEditSelectionMotionCallBack GradationMotionCallBack

static void GradationReleaseCallBack(
	DRAW_WINDOW* window,
	FLOAT_T x,
	FLOAT_T y,
	FLOAT_T pressure,
	BRUSH_CORE *core,
	void* state
)
{
	if(((GdkEventButton*)state)->button == 1)
	{
		GRADATION* gradation = (GRADATION*)core->brush_data;
		cairo_pattern_t *pattern;
		uint8 (*start_color)[3];
		uint8 (*end_color)[3];
		FLOAT_T start_alpha = 1, end_alpha;
		int i;

		if((gradation->flags & GRADATION_STARTED) == 0)
		{
			return;
		}

		gradation->flags &= ~(GRADATION_STARTED);

		if((gradation->flags & GRADATION_COLOR_REVERSE) == 0)
		{
			start_color = &window->app->tool_window.color_chooser->rgb;

			switch(gradation->mode)
			{
			case GRADATION_DRAW_RGB_TO_BACK_RGB:
			case GRADATION_DRAW_RGB_TO_BACK_RGB_RADIALLY:
			case GRADATION_DRAW_RGB_TO_BACK_RGB_BILINEAR:
			case GRADATION_DRAW_RGB_TO_BACK_RGB_RADIALLY_BILINEAR:
			case GRADATION_DRAW_RGB_TO_BACK_RGB_REPEAT:
			case GRADATION_DRAW_RGB_TO_BACK_RGB_RADIALLY_REPEAT:
				end_color = &window->app->tool_window.color_chooser->back_rgb;
				end_alpha = 1;
				break;
			case GRADATION_DRAW_RGB_TO_TRANSPARENT:
			case GRADATION_DRAW_RGB_TO_TRANSPARENT_RADIALLY:
			case GRADATION_DRAW_RGB_TO_TRANSPARENT_BILINEAR:
			case GRADATION_DRAW_RGB_TO_TRANSPARENT_RADIALLY_BILINEAR:
			case GRADATION_DRAW_RGB_TO_TRANSPARENT_REPEAT:
			case GRADATION_DRAW_RGB_TO_TRANSPARENT_RADIALLY_REPEAT:
				end_color = &window->app->tool_window.color_chooser->rgb;
				end_alpha = 0;
				break;
			}
		}
		else
		{
			start_color = &window->app->tool_window.color_chooser->back_rgb;

			switch(gradation->mode)
			{
			case GRADATION_DRAW_RGB_TO_BACK_RGB:
			case GRADATION_DRAW_RGB_TO_BACK_RGB_RADIALLY:
			case GRADATION_DRAW_RGB_TO_BACK_RGB_BILINEAR:
			case GRADATION_DRAW_RGB_TO_BACK_RGB_RADIALLY_BILINEAR:
			case GRADATION_DRAW_RGB_TO_BACK_RGB_REPEAT:
			case GRADATION_DRAW_RGB_TO_BACK_RGB_RADIALLY_REPEAT:
				end_color = &window->app->tool_window.color_chooser->rgb;
				end_alpha = 1;
				break;
			case GRADATION_DRAW_RGB_TO_TRANSPARENT:
			case GRADATION_DRAW_RGB_TO_TRANSPARENT_RADIALLY:
			case GRADATION_DRAW_RGB_TO_TRANSPARENT_BILINEAR:
			case GRADATION_DRAW_RGB_TO_TRANSPARENT_RADIALLY_BILINEAR:
			case GRADATION_DRAW_RGB_TO_TRANSPARENT_REPEAT:
			case GRADATION_DRAW_RGB_TO_TRANSPARENT_RADIALLY_REPEAT:
				end_color = &window->app->tool_window.color_chooser->rgb;
				start_alpha = 0;
				end_alpha = 1;
			}
		}

		switch(gradation->mode)
		{
		case GRADATION_DRAW_RGB_TO_BACK_RGB:
		case GRADATION_DRAW_RGB_TO_TRANSPARENT:
			pattern = cairo_pattern_create_linear(
				gradation->start_x, gradation->start_y, gradation->end_x, gradation->end_y
			);
			cairo_pattern_add_color_stop_rgba(pattern, 0,
				(*start_color)[0]*DIV_PIXEL, (*start_color)[1]*DIV_PIXEL, (*start_color)[2]*DIV_PIXEL, start_alpha
			);
			cairo_pattern_add_color_stop_rgba(pattern, 1,
				(*end_color)[0]*DIV_PIXEL, (*end_color)[1]*DIV_PIXEL, (*end_color)[2]*DIV_PIXEL, end_alpha
			);
			break;
		case GRADATION_DRAW_RGB_TO_BACK_RGB_BILINEAR:
		case GRADATION_DRAW_RGB_TO_TRANSPARENT_BILINEAR:
		case GRADATION_DRAW_RGB_TO_BACK_RGB_REPEAT:
		case GRADATION_DRAW_RGB_TO_TRANSPARENT_REPEAT:
			pattern = cairo_pattern_create_linear(
				gradation->start_x, gradation->start_y, gradation->end_x, gradation->end_y
			);
			cairo_pattern_add_color_stop_rgba(pattern, 0,
				(*end_color)[0]*DIV_PIXEL, (*end_color)[1]*DIV_PIXEL, (*end_color)[2]*DIV_PIXEL, end_alpha
			);
			cairo_pattern_add_color_stop_rgba(pattern, 0.5,
				(*start_color)[0]*DIV_PIXEL, (*start_color)[1]*DIV_PIXEL, (*start_color)[2]*DIV_PIXEL, start_alpha
			);
			cairo_pattern_add_color_stop_rgba(pattern, 1,
				(*end_color)[0]*DIV_PIXEL, (*end_color)[1]*DIV_PIXEL, (*end_color)[2]*DIV_PIXEL, end_alpha
			);
			break;
		case GRADATION_DRAW_RGB_TO_BACK_RGB_RADIALLY:
		case GRADATION_DRAW_RGB_TO_TRANSPARENT_RADIALLY:
			{
				FLOAT_T d = sqrt((gradation->end_x-gradation->start_x)*(gradation->end_x-gradation->start_x)
					+ (gradation->end_y-gradation->start_y)*(gradation->end_y-gradation->start_y));
				pattern = cairo_pattern_create_radial(gradation->start_x, gradation->start_y,
					0, gradation->start_x, gradation->start_y, d);
				cairo_pattern_add_color_stop_rgba(pattern, 0,
				(*start_color)[0]*DIV_PIXEL, (*start_color)[1]*DIV_PIXEL, (*start_color)[2]*DIV_PIXEL, start_alpha
				);
				cairo_pattern_add_color_stop_rgba(pattern, 1,
					(*end_color)[0]*DIV_PIXEL, (*end_color)[1]*DIV_PIXEL, (*end_color)[2]*DIV_PIXEL, end_alpha
				);
			}
			break;
		case GRADATION_DRAW_RGB_TO_BACK_RGB_RADIALLY_BILINEAR:
		case GRADATION_DRAW_RGB_TO_TRANSPARENT_RADIALLY_BILINEAR:
		case GRADATION_DRAW_RGB_TO_BACK_RGB_RADIALLY_REPEAT:
		case GRADATION_DRAW_RGB_TO_TRANSPARENT_RADIALLY_REPEAT:
			{
				FLOAT_T d = sqrt((gradation->end_x-gradation->start_x)*(gradation->end_x-gradation->start_x)
					+ (gradation->end_y-gradation->start_y)*(gradation->end_y-gradation->start_y));
				pattern = cairo_pattern_create_radial(gradation->start_x, gradation->start_y,
					0, gradation->start_x, gradation->start_y, d);
				cairo_pattern_add_color_stop_rgba(pattern, 0,
					(*end_color)[0]*DIV_PIXEL, (*end_color)[1]*DIV_PIXEL, (*end_color)[2]*DIV_PIXEL, end_alpha
				);
				cairo_pattern_add_color_stop_rgba(pattern, 0.5,
				(*start_color)[0]*DIV_PIXEL, (*start_color)[1]*DIV_PIXEL, (*start_color)[2]*DIV_PIXEL, start_alpha
				);
				cairo_pattern_add_color_stop_rgba(pattern, 1,
					(*end_color)[0]*DIV_PIXEL, (*end_color)[1]*DIV_PIXEL, (*end_color)[2]*DIV_PIXEL, end_alpha
				);
			}
			break;
		case GRADATION_DRAW_IRIDESCENE_LINEAR:
		case GRADATION_DRAW_IRIDESCENE_RADIALLY:
			{
				const color[][3] = {
					{0xFF, 0x00, 0x00},
					{0xFF, 0x2F, 0x00},
					{0xFF, 0x62, 0x00},
					{0xFF, 0x90, 0x00},
					{0xFF, 0xBF, 0x00},
					{0xFF, 0xEE, 0x00},
					{0xDD, 0xFF, 0x00},
					{0xAE, 0xFF, 0x00},
					{0x80, 0xFF, 0x00},
					{0x51, 0xFF, 0x00},
					{0x1E, 0xFF, 0x00},
					{0x00, 0xFF, 0x11},
					{0x00, 0xFF, 0x40},
					{0x00, 0xFF, 0x6F},
					{0x00, 0xFF, 0xA1},
					{0x00, 0xFF, 0xD0},
					{0x00, 0xFF, 0xFF},
					{0x00, 0xD0, 0xFF},
					{0x00, 0x9D, 0xFF},
					{0x00, 0x6F, 0xFF},
					{0x00, 0x40, 0xFF},
					{0x00, 0x11, 0xFF},
					{0x22, 0x00, 0xFF},
					{0x51, 0x00, 0xFF},
					{0x80, 0x00, 0xFF},
					{0xAE, 0x00, 0xFF},
					{0xE1, 0x00, 0xFF},
					{0xFF, 0x00, 0xEE},
					{0xFF, 0x00, 0xBF},
					{0xFF, 0x00, 0x90},
					{0xFF, 0x00, 0x5E},
					{0xFF, 0x00, 0x2F}
				};
				const int num_color = sizeof(color)/sizeof(color[0]);

				FLOAT_T d = sqrt((gradation->end_x-gradation->start_x)*(gradation->end_x-gradation->start_x)
					+ (gradation->end_y-gradation->start_y)*(gradation->end_y-gradation->start_y));
				if(gradation->mode == GRADATION_DRAW_IRIDESCENE_LINEAR)
				{
					pattern = cairo_pattern_create_linear(
						gradation->start_x, gradation->start_y, gradation->end_x, gradation->end_y
					);
				}
				else
				{
					pattern = cairo_pattern_create_radial(gradation->start_x, gradation->start_y,
						0, gradation->start_x, gradation->start_y, d);
				}

				if((gradation->flags & GRADATION_COLOR_REVERSE) == 0)
				{
					for(i=0; i<num_color; i++)
					{
						cairo_pattern_add_color_stop_rgb(pattern, (FLOAT_T)i/num_color,
#if !defined(USE_BGR_COLOR_SPACE) || USE_BGR_COLOR_SPACE == 0
							color[i][2] * DIV_PIXEL, color[i][1] * DIV_PIXEL, color[i][0] * DIV_PIXEL
#else
							color[i][0] * DIV_PIXEL, color[i][1] * DIV_PIXEL, color[i][2] * DIV_PIXEL
#endif
						);
					}
				}
				else
				{
					for(i=0; i<num_color; i++)
					{
						cairo_pattern_add_color_stop_rgb(pattern, (FLOAT_T)i/num_color,
#if !defined(USE_BGR_COLOR_SPACE) || USE_BGR_COLOR_SPACE == 0
							color[num_color-i-1][2] * DIV_PIXEL, color[num_color-i-1][1] * DIV_PIXEL, color[num_color-i-1][0] * DIV_PIXEL
#else
							color[num_color-i-1][0] * DIV_PIXEL, color[num_color-i-1][1] * DIV_PIXEL, color[num_color-i-1][2] * DIV_PIXEL
#endif
						);
					}
				}
			}
			break;
		}

		if(gradation->mode == GRADATION_DRAW_RGB_TO_BACK_RGB_REPEAT || gradation->mode == GRADATION_DRAW_RGB_TO_TRANSPARENT_REPEAT
			|| gradation->mode == GRADATION_DRAW_RGB_TO_BACK_RGB_RADIALLY_REPEAT || gradation->mode == GRADATION_DRAW_RGB_TO_TRANSPARENT_RADIALLY_REPEAT
			|| gradation->mode == GRADATION_DRAW_IRIDESCENE_LINEAR || gradation->mode == GRADATION_DRAW_IRIDESCENE_RADIALLY)
		{
			cairo_pattern_set_extend(pattern, CAIRO_EXTEND_REPEAT);
		}
		else
		{
			cairo_pattern_set_extend(pattern, CAIRO_EXTEND_PAD);
		}

		cairo_set_operator(window->work_layer->cairo_p, CAIRO_OPERATOR_OVER);
		if((window->flags & DRAW_WINDOW_HAS_SELECTION_AREA) == 0)
		{
			cairo_set_source(window->work_layer->cairo_p, pattern);
			cairo_rectangle(window->work_layer->cairo_p, 0, 0,
				window->work_layer->width, window->work_layer->height);
			cairo_fill(window->work_layer->cairo_p);
		}
		else
		{
			cairo_set_source(window->work_layer->cairo_p, pattern);
			cairo_rectangle(window->work_layer->cairo_p, 0, 0,
				window->work_layer->width, window->work_layer->height);
			cairo_mask_surface(window->work_layer->cairo_p, window->selection->surface_p, 0, 0);
		}
		
		cairo_pattern_destroy(pattern);

		if((window->flags & DRAW_WINDOW_HAS_SELECTION_AREA) != 0)
		{
			core->min_x = window->selection_area.min_x;
			core->min_y = window->selection_area.min_y;
			core->max_x = window->selection_area.max_x;
			core->max_y = window->selection_area.max_y;
		}
		else
		{
			core->min_x = core->min_y = 0;
			core->max_x = window->active_layer->width;
			core->max_y = window->active_layer->height;
		}

		if((window->active_layer->flags & LAYER_LOCK_OPACITY) == 0)
		{
			window->work_layer->layer_mode = LAYER_BLEND_NORMAL;
		}
		else
		{
			window->work_layer->layer_mode = LAYER_BLEND_ATOP;
		}

		AddBrushHistory(core, window->active_layer);

		window->layer_blend_functions[window->work_layer->layer_mode](window->work_layer, window->active_layer);

		(void)memset(window->work_layer->pixels, 0, window->work_layer->stride*window->work_layer->height);

		window->work_layer->layer_mode = LAYER_BLEND_NORMAL;
	}
}

static void GradationEditSelectionReleaseCallBack(
	DRAW_WINDOW* window,
	FLOAT_T x,
	FLOAT_T y,
	FLOAT_T pressure,
	BRUSH_CORE *core,
	void* state
)
{
	if(((GdkEventButton*)state)->button == 1)
	{
		GRADATION* gradation = (GRADATION*)core->brush_data;
		cairo_pattern_t *pattern;
		uint8 (*start_color)[3];
		uint8 (*end_color)[3];
		FLOAT_T start_alpha = 1, end_alpha;
		int i;

		if((gradation->flags & GRADATION_STARTED) == 0)
		{
			return;
		}

		gradation->flags &= ~(GRADATION_STARTED);

		if((gradation->flags & GRADATION_COLOR_REVERSE) == 0)
		{
			start_color = &window->app->tool_window.color_chooser->back_rgb;

			switch(gradation->mode)
			{
			case GRADATION_DRAW_RGB_TO_BACK_RGB:
			case GRADATION_DRAW_RGB_TO_BACK_RGB_RADIALLY:
			case GRADATION_DRAW_RGB_TO_BACK_RGB_BILINEAR:
			case GRADATION_DRAW_RGB_TO_BACK_RGB_RADIALLY_BILINEAR:
			case GRADATION_DRAW_RGB_TO_BACK_RGB_REPEAT:
			case GRADATION_DRAW_RGB_TO_BACK_RGB_RADIALLY_REPEAT:
				end_color = &window->app->tool_window.color_chooser->rgb;
				end_alpha = 1;
				break;
			case GRADATION_DRAW_RGB_TO_TRANSPARENT:
			case GRADATION_DRAW_RGB_TO_TRANSPARENT_RADIALLY:
			case GRADATION_DRAW_RGB_TO_TRANSPARENT_BILINEAR:
			case GRADATION_DRAW_RGB_TO_TRANSPARENT_RADIALLY_BILINEAR:
			case GRADATION_DRAW_RGB_TO_TRANSPARENT_REPEAT:
			case GRADATION_DRAW_RGB_TO_TRANSPARENT_RADIALLY_REPEAT:
				end_color = &window->app->tool_window.color_chooser->back_rgb;
				start_alpha = 0;
				end_alpha = 1;
				break;
			}
		}
		else
		{
			start_color = &window->app->tool_window.color_chooser->rgb;

			switch(gradation->mode)
			{
			case GRADATION_DRAW_RGB_TO_BACK_RGB:
			case GRADATION_DRAW_RGB_TO_BACK_RGB_RADIALLY:
			case GRADATION_DRAW_RGB_TO_BACK_RGB_BILINEAR:
			case GRADATION_DRAW_RGB_TO_BACK_RGB_RADIALLY_BILINEAR:
			case GRADATION_DRAW_RGB_TO_BACK_RGB_REPEAT:
			case GRADATION_DRAW_RGB_TO_BACK_RGB_RADIALLY_REPEAT:
				end_color = &window->app->tool_window.color_chooser->back_rgb;
				end_alpha = 1;
				break;
			case GRADATION_DRAW_RGB_TO_TRANSPARENT:
			case GRADATION_DRAW_RGB_TO_TRANSPARENT_RADIALLY:
			case GRADATION_DRAW_RGB_TO_TRANSPARENT_BILINEAR:
			case GRADATION_DRAW_RGB_TO_TRANSPARENT_RADIALLY_BILINEAR:
			case GRADATION_DRAW_RGB_TO_TRANSPARENT_REPEAT:
			case GRADATION_DRAW_RGB_TO_TRANSPARENT_RADIALLY_REPEAT:
				end_color = &window->app->tool_window.color_chooser->rgb;
				end_alpha = 0;
			}
		}

		switch(gradation->mode)
		{
		case GRADATION_DRAW_RGB_TO_BACK_RGB:
		case GRADATION_DRAW_RGB_TO_TRANSPARENT:
			pattern = cairo_pattern_create_linear(
				gradation->start_x, gradation->start_y, gradation->end_x, gradation->end_y
			);
			cairo_pattern_add_color_stop_rgba(pattern, 0,
				(*start_color)[0]*DIV_PIXEL, (*start_color)[1]*DIV_PIXEL, (*start_color)[2]*DIV_PIXEL, start_alpha
			);
			cairo_pattern_add_color_stop_rgba(pattern, 1,
				(*end_color)[0]*DIV_PIXEL, (*end_color)[1]*DIV_PIXEL, (*end_color)[2]*DIV_PIXEL, end_alpha
			);
			break;
		case GRADATION_DRAW_RGB_TO_BACK_RGB_BILINEAR:
		case GRADATION_DRAW_RGB_TO_TRANSPARENT_BILINEAR:
		case GRADATION_DRAW_RGB_TO_BACK_RGB_REPEAT:
		case GRADATION_DRAW_RGB_TO_TRANSPARENT_REPEAT:
			pattern = cairo_pattern_create_linear(
				gradation->start_x, gradation->start_y, gradation->end_x, gradation->end_y
			);
			cairo_pattern_add_color_stop_rgba(pattern, 0,
				(*end_color)[0]*DIV_PIXEL, (*end_color)[1]*DIV_PIXEL, (*end_color)[2]*DIV_PIXEL, end_alpha
			);
			cairo_pattern_add_color_stop_rgba(pattern, 0.5,
				(*start_color)[0]*DIV_PIXEL, (*start_color)[1]*DIV_PIXEL, (*start_color)[2]*DIV_PIXEL, start_alpha
			);
			cairo_pattern_add_color_stop_rgba(pattern, 1,
				(*end_color)[0]*DIV_PIXEL, (*end_color)[1]*DIV_PIXEL, (*end_color)[2]*DIV_PIXEL, end_alpha
			);
			break;
		case GRADATION_DRAW_RGB_TO_BACK_RGB_RADIALLY:
		case GRADATION_DRAW_RGB_TO_TRANSPARENT_RADIALLY:
			{
				FLOAT_T d = sqrt((gradation->end_x-gradation->start_x)*(gradation->end_x-gradation->start_x)
					+ (gradation->end_y-gradation->start_y)*(gradation->end_y-gradation->start_y));
				pattern = cairo_pattern_create_radial(gradation->start_x, gradation->start_y,
					0, gradation->start_x, gradation->start_y, d);
				cairo_pattern_add_color_stop_rgba(pattern, 0,
				(*start_color)[0]*DIV_PIXEL, (*start_color)[1]*DIV_PIXEL, (*start_color)[2]*DIV_PIXEL, start_alpha
				);
				cairo_pattern_add_color_stop_rgba(pattern, 1,
					(*end_color)[0]*DIV_PIXEL, (*end_color)[1]*DIV_PIXEL, (*end_color)[2]*DIV_PIXEL, end_alpha
				);
			}
			break;
		case GRADATION_DRAW_RGB_TO_BACK_RGB_RADIALLY_BILINEAR:
		case GRADATION_DRAW_RGB_TO_TRANSPARENT_RADIALLY_BILINEAR:
		case GRADATION_DRAW_RGB_TO_BACK_RGB_RADIALLY_REPEAT:
		case GRADATION_DRAW_RGB_TO_TRANSPARENT_RADIALLY_REPEAT:
			{
				FLOAT_T d = sqrt((gradation->end_x-gradation->start_x)*(gradation->end_x-gradation->start_x)
					+ (gradation->end_y-gradation->start_y)*(gradation->end_y-gradation->start_y));
				pattern = cairo_pattern_create_radial(gradation->start_x, gradation->start_y,
					0, gradation->start_x, gradation->start_y, d);
				cairo_pattern_add_color_stop_rgba(pattern, 0,
					(*end_color)[0]*DIV_PIXEL, (*end_color)[1]*DIV_PIXEL, (*end_color)[2]*DIV_PIXEL, end_alpha
				);
				cairo_pattern_add_color_stop_rgba(pattern, 0.5,
				(*start_color)[0]*DIV_PIXEL, (*start_color)[1]*DIV_PIXEL, (*start_color)[2]*DIV_PIXEL, start_alpha
				);
				cairo_pattern_add_color_stop_rgba(pattern, 1,
					(*end_color)[0]*DIV_PIXEL, (*end_color)[1]*DIV_PIXEL, (*end_color)[2]*DIV_PIXEL, end_alpha
				);
			}
			break;
		case GRADATION_DRAW_IRIDESCENE_LINEAR:
		case GRADATION_DRAW_IRIDESCENE_RADIALLY:
			{
				const color[][3] = {
					{0xFF, 0x00, 0x00},
					{0xFF, 0x2F, 0x00},
					{0xFF, 0x62, 0x00},
					{0xFF, 0x90, 0x00},
					{0xFF, 0xBF, 0x00},
					{0xFF, 0xEE, 0x00},
					{0xDD, 0xFF, 0x00},
					{0xAE, 0xFF, 0x00},
					{0x80, 0xFF, 0x00},
					{0x51, 0xFF, 0x00},
					{0x1E, 0xFF, 0x00},
					{0x00, 0xFF, 0x11},
					{0x00, 0xFF, 0x40},
					{0x00, 0xFF, 0x6F},
					{0x00, 0xFF, 0xA1},
					{0x00, 0xFF, 0xD0},
					{0x00, 0xFF, 0xFF},
					{0x00, 0xD0, 0xFF},
					{0x00, 0x9D, 0xFF},
					{0x00, 0x6F, 0xFF},
					{0x00, 0x40, 0xFF},
					{0x00, 0x11, 0xFF},
					{0x22, 0x00, 0xFF},
					{0x51, 0x00, 0xFF},
					{0x80, 0x00, 0xFF},
					{0xAE, 0x00, 0xFF},
					{0xE1, 0x00, 0xFF},
					{0xFF, 0x00, 0xEE},
					{0xFF, 0x00, 0xBF},
					{0xFF, 0x00, 0x90},
					{0xFF, 0x00, 0x5E},
					{0xFF, 0x00, 0x2F}
				};
				const int num_color = sizeof(color)/sizeof(color[0]);

				FLOAT_T d = sqrt((gradation->end_x-gradation->start_x)*(gradation->end_x-gradation->start_x)
					+ (gradation->end_y-gradation->start_y)*(gradation->end_y-gradation->start_y));
				if(gradation->mode == GRADATION_DRAW_IRIDESCENE_LINEAR)
				{
					pattern = cairo_pattern_create_linear(
						gradation->start_x, gradation->start_y, gradation->end_x, gradation->end_y
					);
				}
				else
				{
					pattern = cairo_pattern_create_radial(gradation->start_x, gradation->start_y,
						0, gradation->start_x, gradation->start_y, d);
				}

				if((gradation->flags & GRADATION_COLOR_REVERSE) == 0)
				{
					for(i=0; i<num_color; i++)
					{
						cairo_pattern_add_color_stop_rgb(pattern, (FLOAT_T)i/num_color,
#if !defined(USE_BGR_COLOR_SPACE) || USE_BGR_COLOR_SPACE == 0
							color[i][2] * DIV_PIXEL, color[i][1] * DIV_PIXEL, color[i][0] * DIV_PIXEL
#else
							color[i][0] * DIV_PIXEL, color[i][1] * DIV_PIXEL, color[i][2] * DIV_PIXEL
#endif
						);
					}
				}
				else
				{
					for(i=0; i<num_color; i++)
					{
						cairo_pattern_add_color_stop_rgb(pattern, (FLOAT_T)i/num_color,
#if !defined(USE_BGR_COLOR_SPACE) || USE_BGR_COLOR_SPACE == 0
							color[num_color-i-1][2] * DIV_PIXEL, color[num_color-i-1][1] * DIV_PIXEL, color[num_color-i-1][0] * DIV_PIXEL
#else
							color[num_color-i-1][0] * DIV_PIXEL, color[num_color-i-1][1] * DIV_PIXEL, color[num_color-i-1][2] * DIV_PIXEL
#endif
						);
					}
				}
			}
			break;
		}

		if(gradation->mode == GRADATION_DRAW_RGB_TO_BACK_RGB_REPEAT || gradation->mode == GRADATION_DRAW_RGB_TO_TRANSPARENT_REPEAT
			|| gradation->mode == GRADATION_DRAW_RGB_TO_BACK_RGB_RADIALLY_REPEAT || gradation->mode == GRADATION_DRAW_RGB_TO_TRANSPARENT_RADIALLY_REPEAT
			|| gradation->mode == GRADATION_DRAW_IRIDESCENE_LINEAR || gradation->mode == GRADATION_DRAW_IRIDESCENE_RADIALLY)
		{
			cairo_pattern_set_extend(pattern, CAIRO_EXTEND_REPEAT);
		}
		else
		{
			cairo_pattern_set_extend(pattern, CAIRO_EXTEND_PAD);
		}

		cairo_set_operator(window->work_layer->cairo_p, CAIRO_OPERATOR_OVER);
		cairo_set_source(window->work_layer->cairo_p, pattern);
		cairo_rectangle(window->work_layer->cairo_p, 0, 0,
			window->work_layer->width, window->work_layer->height);
		cairo_fill(window->work_layer->cairo_p);
		
		cairo_pattern_destroy(pattern);

		core->min_x = core->min_y = 0;
		core->max_x = window->active_layer->width;
		core->max_y = window->active_layer->height;

		AddSelectionEditHistory(core, window->selection);

		g_blend_selection_funcs[SELECTION_BLEND_NORMAL](window->work_layer, window->selection);

		(void)memset(window->work_layer->pixels, 0, window->work_layer->stride*window->work_layer->height);

		window->work_layer->layer_mode = LAYER_BLEND_NORMAL;
	}
}

static void DrawGradationCursor(
	DRAW_WINDOW* window,
	FLOAT_T x,
	FLOAT_T y,
	void* data
)
{
	GRADATION* gradation = (GRADATION*)data;
	if((gradation->flags & GRADATION_STARTED) != 0)
	{
		FLOAT_T zoom = window->zoom * 0.01;
		cairo_set_line_width(window->disp_temp->cairo_p, 1.0);
		cairo_set_source_rgb(window->disp_temp->cairo_p, 1, 1, 1);
		cairo_move_to(window->disp_temp->cairo_p, gradation->start_x * zoom, gradation->start_y * zoom);
		cairo_line_to(window->disp_temp->cairo_p, gradation->end_x * zoom, gradation->end_y * zoom);
		cairo_stroke(window->disp_temp->cairo_p);
	}
}

static int IsGradationHasAlpha(int index)
{
	if(index == GRADATION_DRAW_RGB_TO_BACK_RGB
		|| index == GRADATION_DRAW_RGB_TO_BACK_RGB_BILINEAR
		|| index == GRADATION_DRAW_RGB_TO_BACK_RGB_REPEAT
		|| index == GRADATION_DRAW_RGB_TO_BACK_RGB_RADIALLY
		|| index == GRADATION_DRAW_RGB_TO_BACK_RGB_RADIALLY_BILINEAR
		|| index == GRADATION_DRAW_RGB_TO_BACK_RGB_RADIALLY_REPEAT
		|| index == GRADATION_DRAW_IRIDESCENE_LINEAR
		|| index == GRADATION_DRAW_IRIDESCENE_RADIALLY
	)
	{
		return FALSE;
	}

	return TRUE;
}

static void GradationOnChangeEditSelection(void* data, int is_editting)
{
	GRADATION *gradation = (GRADATION*)data;
	int index = 0;
	int i, j;

	if(IsGradationHasAlpha(gradation->mode) == FALSE)
	{
		gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(
			gradation->button_table[0][GRADATION_DRAW_RGB_TO_TRANSPARENT]), TRUE);
	}

	for(i=0; i<GRADATION_PATTERN_TABLE_HEIGHT; i++)
	{
		for(j=0; j<GRADATION_PATTERN_TABLE_WIDTH; j++)
		{
			if(IsGradationHasAlpha(index) == FALSE)
			{
				gtk_widget_set_sensitive(gradation->button_table[i][j], !is_editting);
			}
			index++;
		}
	}
}

static void GradationPatternButtonClicked(GtkWidget* widget, GRADATION* gradation)
{
	int button_mode = GPOINTER_TO_INT(g_object_get_data(G_OBJECT(widget), "gradation-mode"));
	int i, j;

	if(button_mode == gradation->mode)
	{
		if(gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(widget)) == FALSE)
		{
			gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(widget), TRUE);
		}
		return;
	}
	else if(gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(widget)) == FALSE)
	{
		return;
	}

	gradation->mode = (uint16)button_mode;

	for(i=0; i<GRADATION_PATTERN_TABLE_HEIGHT; i++)
	{
		for(j=0; j<GRADATION_PATTERN_TABLE_WIDTH; j++)
		{
			if(gradation->button_table[i][j] != NULL)
			{
				if(i*GRADATION_PATTERN_TABLE_HEIGHT+j == gradation->mode)
				{
					if(gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(
						gradation->button_table[i][j])) == FALSE)
					{
						gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(gradation->button_table[i][j]), TRUE);
					}
				}
				else
				{
					if(gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(
						gradation->button_table[i][j])) != FALSE)
					{
						gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(gradation->button_table[i][j]), FALSE);
					}
				}
			}
		}
	}	
}

static GtkWidget* CreateGradationPatternTable(GRADATION* gradation)
{
#define ICON_SIZE 32
	GtkWidget* table = gtk_table_new(
		GRADATION_PATTERN_TABLE_WIDTH, GRADATION_PATTERN_TABLE_HEIGHT, TRUE);
	GtkWidget* button, *image;
	GdkPixbuf* pixbuf;
	cairo_t *cairo_p;
	cairo_surface_t* surface_p;
	cairo_pattern_t *pattern;
	uint8 *pixels;
	gboolean is_editting_selection = FALSE;
	int stride;
	int i, j, k;
	int x, y;

	if(gradation->app->window_num > 0)
	{
		if((gradation->app->draw_window[gradation->app->active_window]->flags
			& DRAW_WINDOW_EDIT_SELECTION) != 0)
		{
			is_editting_selection = TRUE;
		}
	}

	for(i=0, x=0, y=0; i<GRADATION_MODE_NUM; i++, x++)
	{
		if(x == GRADATION_PATTERN_TABLE_WIDTH)
		{
			x = 0;
			y++;
		}

		pixbuf = gdk_pixbuf_new(GDK_COLORSPACE_RGB, TRUE, 8, ICON_SIZE, ICON_SIZE);
		gdk_pixbuf_composite_color(pixbuf, pixbuf, 0, 0, ICON_SIZE, ICON_SIZE,
			0, 0, 1, 1, GDK_INTERP_BILINEAR, 255, 0, 0, 4, 0xFFFFFF, 0x888888
		);
		pixels = gdk_pixbuf_get_pixels(pixbuf);
		stride = gdk_pixbuf_get_rowstride(pixbuf);
		for(j=0; j<ICON_SIZE; j++)
		{
			for(k=0; k<ICON_SIZE; k++)
			{
				uint8 pixel_value = pixels[j*stride+k*4] * 3;
				pixels[j*stride+k*4] = pixel_value;
				pixels[j*stride+k*4+1] = pixel_value;
				pixels[j*stride+k*4+2] = pixel_value;
				pixels[j*stride+k*4+3] = 0xff;
			}
		}

		surface_p = cairo_image_surface_create_for_data(
			pixels, CAIRO_FORMAT_ARGB32, ICON_SIZE, ICON_SIZE, stride
		);
		cairo_p = cairo_create(surface_p);
		switch(i)
		{
		case GRADATION_DRAW_RGB_TO_BACK_RGB:
			pattern = cairo_pattern_create_linear(0, 0, ICON_SIZE, ICON_SIZE);
			cairo_pattern_add_color_stop_rgb(pattern, 0, 0, 0, 0);
			cairo_pattern_add_color_stop_rgb(pattern, 1, 1, 1, 1);
			cairo_set_source(cairo_p, pattern);
			cairo_rectangle(cairo_p, 0, 0, ICON_SIZE, ICON_SIZE);
			cairo_fill(cairo_p);
			break;
		case GRADATION_DRAW_RGB_TO_TRANSPARENT:
			pattern = cairo_pattern_create_linear(0, 0, ICON_SIZE, ICON_SIZE);
			cairo_pattern_add_color_stop_rgba(pattern, 0, 0, 0, 0, 1);
			cairo_pattern_add_color_stop_rgba(pattern, 1, 0, 0, 0, 0);
			cairo_set_source(cairo_p, pattern);
			cairo_rectangle(cairo_p, 0, 0, ICON_SIZE, ICON_SIZE);
			cairo_fill(cairo_p);
			break;
		case GRADATION_DRAW_RGB_TO_BACK_RGB_BILINEAR:
			pattern = cairo_pattern_create_linear(0, 0, ICON_SIZE, ICON_SIZE);
			cairo_pattern_add_color_stop_rgb(pattern, 0, 1, 1, 1);
			cairo_pattern_add_color_stop_rgb(pattern, 0.5, 0, 0, 0);
			cairo_pattern_add_color_stop_rgb(pattern, 1, 1, 1, 1);
			cairo_set_source(cairo_p, pattern);
			cairo_rectangle(cairo_p, 0, 0, ICON_SIZE, ICON_SIZE);
			cairo_fill(cairo_p);
			break;
		case GRADATION_DRAW_RGB_TO_TRANSPARENT_BILINEAR:
			pattern = cairo_pattern_create_linear(0, 0, ICON_SIZE, ICON_SIZE);
			cairo_pattern_add_color_stop_rgba(pattern, 0, 0, 0, 0, 0);
			cairo_pattern_add_color_stop_rgba(pattern, 0.5, 0, 0, 0, 1);
			cairo_pattern_add_color_stop_rgba(pattern, 1, 0, 0, 0, 0);
			cairo_set_source(cairo_p, pattern);
			cairo_rectangle(cairo_p, 0, 0, ICON_SIZE, ICON_SIZE);
			cairo_fill(cairo_p);
			break;
		case GRADATION_DRAW_RGB_TO_BACK_RGB_REPEAT:
			pattern = cairo_pattern_create_linear(0, 0, ICON_SIZE, ICON_SIZE);
			cairo_pattern_add_color_stop_rgb(pattern, 0, 1, 1, 1);
			cairo_pattern_add_color_stop_rgb(pattern, 0.2f, 0, 0, 0);
			cairo_pattern_add_color_stop_rgb(pattern, 0.4f, 1, 1, 1);
			cairo_pattern_add_color_stop_rgb(pattern, 0.6f, 0, 0, 0);
			cairo_pattern_add_color_stop_rgb(pattern, 0.8f, 1, 1, 1);
			cairo_pattern_add_color_stop_rgb(pattern, 1, 0, 0, 0);
			cairo_set_source(cairo_p, pattern);
			cairo_rectangle(cairo_p, 0, 0, ICON_SIZE, ICON_SIZE);
			cairo_fill(cairo_p);
			break;
		case GRADATION_DRAW_RGB_TO_TRANSPARENT_REPEAT:
			pattern = cairo_pattern_create_linear(0, 0, ICON_SIZE, ICON_SIZE);
			cairo_pattern_add_color_stop_rgba(pattern, 0, 0, 0, 0, 0);
			cairo_pattern_add_color_stop_rgba(pattern, 0.2f, 0, 0, 0, 1);
			cairo_pattern_add_color_stop_rgba(pattern, 0.4f, 0, 0, 0, 0);
			cairo_pattern_add_color_stop_rgba(pattern, 0.6f, 0, 0, 0, 1);
			cairo_pattern_add_color_stop_rgba(pattern, 0.8f, 0, 0, 0, 0);
			cairo_pattern_add_color_stop_rgba(pattern, 1, 0, 0, 0, 1);
			cairo_set_source(cairo_p, pattern);
			cairo_rectangle(cairo_p, 0, 0, ICON_SIZE, ICON_SIZE);
			cairo_fill(cairo_p);
			break;
		case GRADATION_DRAW_RGB_TO_BACK_RGB_RADIALLY:
			pattern = cairo_pattern_create_radial(
				ICON_SIZE/2, ICON_SIZE/2, 0, ICON_SIZE/2, ICON_SIZE/2, ICON_SIZE/2
			);
			cairo_pattern_add_color_stop_rgb(pattern, 0, 0, 0, 0);
			cairo_pattern_add_color_stop_rgb(pattern, 1, 1, 1, 1);
			cairo_set_source(cairo_p, pattern);
			cairo_rectangle(cairo_p, 0, 0, ICON_SIZE, ICON_SIZE);
			cairo_fill(cairo_p);
			break;
		case GRADATION_DRAW_RGB_TO_TRANSPARENT_RADIALLY:
			pattern = cairo_pattern_create_radial(
				ICON_SIZE/2, ICON_SIZE/2, 0, ICON_SIZE/2, ICON_SIZE/2, ICON_SIZE/2
			);
			cairo_pattern_add_color_stop_rgba(pattern, 0, 0, 0, 0, 1);
			cairo_pattern_add_color_stop_rgba(pattern, 1, 0, 0, 0, 0);
			cairo_set_source(cairo_p, pattern);
			cairo_rectangle(cairo_p, 0, 0, ICON_SIZE, ICON_SIZE);
			cairo_fill(cairo_p);
			break;
		case GRADATION_DRAW_RGB_TO_BACK_RGB_RADIALLY_BILINEAR:
			pattern = cairo_pattern_create_radial(
				ICON_SIZE/2, ICON_SIZE/2, 0, ICON_SIZE/2, ICON_SIZE/2, ICON_SIZE/2
			);
			cairo_pattern_add_color_stop_rgb(pattern, 0, 1, 1, 1);
			cairo_pattern_add_color_stop_rgb(pattern, 0.5, 0, 0, 0);
			cairo_pattern_add_color_stop_rgb(pattern, 1, 1, 1, 1);
			cairo_set_source(cairo_p, pattern);
			cairo_rectangle(cairo_p, 0, 0, ICON_SIZE, ICON_SIZE);
			cairo_fill(cairo_p);
			break;
		case GRADATION_DRAW_RGB_TO_TRANSPARENT_RADIALLY_BILINEAR:
			pattern = cairo_pattern_create_radial(
				ICON_SIZE/2, ICON_SIZE/2, 0, ICON_SIZE/2, ICON_SIZE/2, ICON_SIZE/2
			);
			cairo_pattern_add_color_stop_rgba(pattern, 0, 0, 0, 0, 0);
			cairo_pattern_add_color_stop_rgba(pattern, 0.5, 0, 0, 0, 1);
			cairo_pattern_add_color_stop_rgba(pattern, 1, 0, 0, 0, 0);
			cairo_set_source(cairo_p, pattern);
			cairo_rectangle(cairo_p, 0, 0, ICON_SIZE, ICON_SIZE);
			cairo_fill(cairo_p);
			break;
		case GRADATION_DRAW_RGB_TO_BACK_RGB_RADIALLY_REPEAT:
			pattern = cairo_pattern_create_radial(
				ICON_SIZE/2, ICON_SIZE/2, 0, ICON_SIZE/2, ICON_SIZE/2, ICON_SIZE/2
			);
			cairo_pattern_add_color_stop_rgb(pattern, 0, 1, 1, 1);
			cairo_pattern_add_color_stop_rgb(pattern, 0.2f, 0, 0, 0);
			cairo_pattern_add_color_stop_rgb(pattern, 0.4f, 1, 1, 1);
			cairo_pattern_add_color_stop_rgb(pattern, 0.6f, 0, 0, 0);
			cairo_pattern_add_color_stop_rgb(pattern, 0.8f, 1, 1, 1);
			cairo_pattern_add_color_stop_rgb(pattern, 1, 0, 0, 0);
			cairo_set_source(cairo_p, pattern);
			cairo_rectangle(cairo_p, 0, 0, ICON_SIZE, ICON_SIZE);
			cairo_fill(cairo_p);
			break;
		case GRADATION_DRAW_RGB_TO_TRANSPARENT_RADIALLY_REPEAT:
			pattern = cairo_pattern_create_radial(
				ICON_SIZE/2, ICON_SIZE/2, 0, ICON_SIZE/2, ICON_SIZE/2, ICON_SIZE/2
			);
			cairo_pattern_add_color_stop_rgba(pattern, 0, 0, 0, 0, 0);
			cairo_pattern_add_color_stop_rgba(pattern, 0.2f, 0, 0, 0, 1);
			cairo_pattern_add_color_stop_rgba(pattern, 0.4f, 0, 0, 0, 0);
			cairo_pattern_add_color_stop_rgba(pattern, 0.6f, 0, 0, 0, 1);
			cairo_pattern_add_color_stop_rgba(pattern, 0.8f, 0, 0, 0, 0);
			cairo_pattern_add_color_stop_rgba(pattern, 1, 0, 0, 0, 1);
			cairo_set_source(cairo_p, pattern);
			cairo_rectangle(cairo_p, 0, 0, ICON_SIZE, ICON_SIZE);
			cairo_fill(cairo_p);
			break;
		case GRADATION_DRAW_IRIDESCENE_LINEAR:
			{
				const color[][3] = {
					{0xFF, 0x00, 0x00},
					{0xFF, 0x2F, 0x00},
					{0xFF, 0x62, 0x00},
					{0xFF, 0x90, 0x00},
					{0xFF, 0xBF, 0x00},
					{0xFF, 0xEE, 0x00},
					{0xDD, 0xFF, 0x00},
					{0xAE, 0xFF, 0x00},
					{0x80, 0xFF, 0x00},
					{0x51, 0xFF, 0x00},
					{0x1E, 0xFF, 0x00},
					{0x00, 0xFF, 0x11},
					{0x00, 0xFF, 0x40},
					{0x00, 0xFF, 0x6F},
					{0x00, 0xFF, 0xA1},
					{0x00, 0xFF, 0xD0},
					{0x00, 0xFF, 0xFF},
					{0x00, 0xD0, 0xFF},
					{0x00, 0x9D, 0xFF},
					{0x00, 0x6F, 0xFF},
					{0x00, 0x40, 0xFF},
					{0x00, 0x11, 0xFF},
					{0x22, 0x00, 0xFF},
					{0x51, 0x00, 0xFF},
					{0x80, 0x00, 0xFF},
					{0xAE, 0x00, 0xFF},
					{0xE1, 0x00, 0xFF},
					{0xFF, 0x00, 0xEE},
					{0xFF, 0x00, 0xBF},
					{0xFF, 0x00, 0x90},
					{0xFF, 0x00, 0x5E},
					{0xFF, 0x00, 0x2F}
				};
				const int num_color = sizeof(color)/sizeof(color[0]);

				pattern = cairo_pattern_create_linear(0, 0, ICON_SIZE, ICON_SIZE);
				cairo_pattern_set_extend(pattern, CAIRO_EXTEND_REPEAT);
				for(j=0; j<num_color; j++)
				{
					cairo_pattern_add_color_stop_rgb(pattern, (FLOAT_T)j/num_color,
#if !defined(USE_BGR_COLOR_SPACE) || USE_BGR_COLOR_SPACE == 0
						color[j][2] * DIV_PIXEL, color[j][1] * DIV_PIXEL, color[j][0] * DIV_PIXEL
#else
						color[j][0] * DIV_PIXEL, color[j][1] * DIV_PIXEL, color[j][2] * DIV_PIXEL
#endif
					);
				}
				cairo_set_source(cairo_p, pattern);
				cairo_rectangle(cairo_p, 0, 0, ICON_SIZE, ICON_SIZE);
				cairo_fill(cairo_p);
			}
			break;
		case GRADATION_DRAW_IRIDESCENE_RADIALLY:
			{
				const color[][3] = {
					{0xFF, 0x00, 0x00},
					{0xFF, 0x2F, 0x00},
					{0xFF, 0x62, 0x00},
					{0xFF, 0x90, 0x00},
					{0xFF, 0xBF, 0x00},
					{0xFF, 0xEE, 0x00},
					{0xDD, 0xFF, 0x00},
					{0xAE, 0xFF, 0x00},
					{0x80, 0xFF, 0x00},
					{0x51, 0xFF, 0x00},
					{0x1E, 0xFF, 0x00},
					{0x00, 0xFF, 0x11},
					{0x00, 0xFF, 0x40},
					{0x00, 0xFF, 0x6F},
					{0x00, 0xFF, 0xA1},
					{0x00, 0xFF, 0xD0},
					{0x00, 0xFF, 0xFF},
					{0x00, 0xD0, 0xFF},
					{0x00, 0x9D, 0xFF},
					{0x00, 0x6F, 0xFF},
					{0x00, 0x40, 0xFF},
					{0x00, 0x11, 0xFF},
					{0x22, 0x00, 0xFF},
					{0x51, 0x00, 0xFF},
					{0x80, 0x00, 0xFF},
					{0xAE, 0x00, 0xFF},
					{0xE1, 0x00, 0xFF},
					{0xFF, 0x00, 0xEE},
					{0xFF, 0x00, 0xBF},
					{0xFF, 0x00, 0x90},
					{0xFF, 0x00, 0x5E},
					{0xFF, 0x00, 0x2F}
				};
				const int num_color = sizeof(color)/sizeof(color[0]);

				pattern = cairo_pattern_create_radial(
					ICON_SIZE/2, ICON_SIZE/2, 0, ICON_SIZE/2, ICON_SIZE/2, ICON_SIZE/2
				);
				cairo_pattern_set_extend(pattern, CAIRO_EXTEND_REPEAT);
				for(j=0; j<num_color; j++)
				{
					cairo_pattern_add_color_stop_rgb(pattern, (FLOAT_T)j/num_color,
#if !defined(USE_BGR_COLOR_SPACE) || USE_BGR_COLOR_SPACE == 0
						color[j][2] * DIV_PIXEL, color[j][1] * DIV_PIXEL, color[j][0] * DIV_PIXEL
#else
						color[j][0] * DIV_PIXEL, color[j][1] * DIV_PIXEL, color[j][2] * DIV_PIXEL
#endif
					);
				}
				cairo_set_source(cairo_p, pattern);
				cairo_rectangle(cairo_p, 0, 0, ICON_SIZE, ICON_SIZE);
				cairo_fill(cairo_p);
			}
			break;
		}
		cairo_pattern_destroy(pattern);

		image = gtk_image_new_from_pixbuf(pixbuf);

		button = gtk_toggle_button_new();
		if(gradation->mode == i)
		{
			gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(button), TRUE);
		}
		if(is_editting_selection != FALSE)
		{
			if(IsGradationHasAlpha(i) == FALSE)
			{
				gtk_widget_set_sensitive(button, FALSE);
			}
		}
		(void)g_signal_connect(G_OBJECT(button), "toggled",
			G_CALLBACK(GradationPatternButtonClicked), gradation);
		gtk_table_attach(GTK_TABLE(table), button, x, x+1, y, y+1, GTK_SHRINK, GTK_SHRINK, 0, 0);
		g_object_set_data(G_OBJECT(button), "gradation-mode", GINT_TO_POINTER(i));
		gradation->button_table[y][x] = button;
		gtk_container_add(GTK_CONTAINER(button), image);

		cairo_surface_destroy(surface_p);
		cairo_destroy(cairo_p);
	}

	return table;
#undef ICON_SIZE
}

static void ChangeGradationReverse(GtkWidget* widget, GRADATION* gradation)
{
	if(gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(widget)) == FALSE)
	{
		gradation->flags &= ~(GRADATION_COLOR_REVERSE);
	}
	else
	{
		gradation->flags |= GRADATION_COLOR_REVERSE;
	}
}

static GtkWidget* CreateGrationDetailUI(APPLICATION* app, BRUSH_CORE* core)
{
#define ICON_SIZE 32
	GRADATION* gradation = (GRADATION*)core->brush_data;
	GtkWidget* vbox = gtk_vbox_new(FALSE, 0);
	GtkWidget* check_button;
	GtkWidget* scrolled_window = gtk_scrolled_window_new(NULL, NULL);

	check_button = gtk_check_button_new_with_label(app->labels->tool_box.gradation_reverse);
	(void)g_signal_connect(G_OBJECT(check_button), "toggled",
		G_CALLBACK(ChangeGradationReverse), core->brush_data);
	gtk_box_pack_start(GTK_BOX(vbox), check_button, FALSE, TRUE, 0);

	gtk_widget_set_size_request(scrolled_window, ICON_SIZE*4+4, ICON_SIZE*6+4);
	gtk_scrolled_window_set_policy(GTK_SCROLLED_WINDOW(scrolled_window),
		GTK_POLICY_NEVER, GTK_POLICY_AUTOMATIC);
	gtk_scrolled_window_add_with_viewport(GTK_SCROLLED_WINDOW(scrolled_window),
		CreateGradationPatternTable(gradation));
	gtk_box_pack_start(GTK_BOX(vbox), scrolled_window, FALSE, FALSE, 0);

	return vbox;
#undef ICON_SIZE
}

static void BlurToolPressCallBack(
	DRAW_WINDOW* window,
	FLOAT_T x,
	FLOAT_T y,
	FLOAT_T pressure,
	BRUSH_CORE *core,
	void* state
)
{
	if(((GdkEventButton*)state)->button == 1)
	{
		BLUR_TOOL* blur = (BLUR_TOOL*)core->brush_data;
		FLOAT_T r, alpha;
		FLOAT_T zoom;
		cairo_matrix_t matrix;
		int extends;
		int num_samples;
		FLOAT_T min_x, min_y, max_x, max_y;
		int sum_color0 = 0, sum_color1 = 0, sum_color2 = 0, sum_color3 = 0;
		int before_y_color[4];
		int stride = window->work_layer->stride;
		uint8 *work_pixels = window->work_layer->pixels;
		uint8 *temp_pixels = window->temp_layer->pixels;
		uint8 *add_pixel, *temp_pixel, *mask;
		int layer_width = window->work_layer->width;
		int layer_stride = window->work_layer->width;
		int counter_x, counter_y, start_x, start_y, width, height;
		int start_i, start_j, end_i, end_j;
		int left;
		int top;
		int temp_stride;
		gboolean skip_loop = FALSE;
		int i, j;

		window->work_layer->layer_mode = LAYER_BLEND_SOURCE;

		(void)memcpy(window->work_layer->pixels, window->active_layer->pixels,
			window->pixel_buf_size);

		if((blur->flags & BRUSH_FLAG_SIZE) != 0)
		{
			r = blur->r * pressure;
			zoom = 1/pressure;
		}
		else
		{
			r = blur->r;
			zoom = 1;
		}

		r = ((blur->flags & BRUSH_FLAG_SIZE) == 0) ?
			blur->r : blur->r * pressure;
		alpha = ((blur->flags & BRUSH_FLAG_FLOW) == 0) ? 1 : pressure;
		extends = (int)(r * (blur->color_extend * 0.01))/2;
		if(extends == 0)
		{
			return;
		}

		min_x = x - r, min_y = y - r;
		max_x = x + r, max_y = y + r;

		blur->before_x = x, blur->before_y = y;

		if(min_x < 0.0)
		{
			min_x = 0.0;
		}
		if(min_y < 0.0)
		{
			min_y = 0.0;
		}
		if(max_x > window->work_layer->width)
		{
			max_x = window->work_layer->width;
		}
		if(max_y > window->work_layer->height)
		{
			max_y = window->work_layer->height;
		}

		window->update.x = (int)min_x, window->update.y = (int)min_y;
		window->update.width = (int)max_x - window->update.x;
		window->update.height = (int)max_y - window->update.y;

		window->flags |= DRAW_WINDOW_UPDATE_PART;

		core->min_x = min_x, core->min_y = min_y;
		core->max_x = max_x, core->max_y = max_y;
		start_x = (int32)core->min_x, start_y = (int32)core->min_y;
		width = (int32)(core->max_x-core->min_x);
		height = (int32)(core->max_y-core->min_y);
		temp_stride = width*5;

		for(counter_y=0; counter_y<height; counter_y++)
		{
			(void)memset(&window->mask->pixels[(start_y+counter_y)*window->width
				+ start_x], 0, width);
		}

		cairo_set_operator(window->mask->cairo_p, CAIRO_OPERATOR_OVER);
		mask = window->mask->pixels;
		cairo_set_operator(window->alpha_cairo, CAIRO_OPERATOR_OVER);
		if((window->flags & DRAW_WINDOW_HAS_SELECTION_AREA) == 0)
		{
			if((window->active_layer->flags & LAYER_LOCK_OPACITY) == 0)
			{
				cairo_matrix_init_scale(&matrix, zoom, zoom);
				cairo_matrix_translate(&matrix, - x + r, - y + r);
				cairo_pattern_set_matrix(core->brush_pattern, &matrix);
				cairo_set_source(window->alpha_cairo, core->brush_pattern);
				cairo_paint_with_alpha(window->alpha_cairo, alpha);
			}
			else
			{
				cairo_matrix_init_scale(&matrix, zoom, zoom);
				cairo_pattern_set_matrix(core->brush_pattern, &matrix);
				cairo_set_source(core->temp_cairo, core->brush_pattern);
				cairo_paint_with_alpha(core->temp_cairo, alpha);
				cairo_matrix_init_translate(&matrix, - x + r, - y + r);
				cairo_pattern_set_matrix(core->temp_pattern, &matrix);
				cairo_set_source(window->alpha_cairo, core->temp_pattern);
				cairo_mask_surface(window->alpha_cairo,
					window->active_layer->surface_p, 0, 0);
			}
		}
		else
		{
			if((window->active_layer->flags & LAYER_LOCK_OPACITY) == 0)
			{
				cairo_matrix_init_scale(&matrix, zoom, zoom);
				cairo_pattern_set_matrix(core->brush_pattern, &matrix);
				cairo_set_source(core->temp_cairo, core->brush_pattern);
				cairo_paint_with_alpha(core->temp_cairo, alpha);
				cairo_matrix_init_translate(&matrix, - x + r, - y + r);
				cairo_pattern_set_matrix(core->temp_pattern, &matrix);
				cairo_set_source(window->alpha_cairo, core->temp_pattern);
				cairo_mask_surface(window->alpha_cairo,
					window->selection->surface_p, 0, 0);
			}
			else
			{
				cairo_matrix_init_scale(&matrix, zoom, zoom);
				cairo_pattern_set_matrix(core->brush_pattern, &matrix);
				cairo_set_source(core->temp_cairo, core->brush_pattern);
				cairo_paint_with_alpha(core->temp_cairo, alpha);
				cairo_matrix_init_translate(&matrix, - x + r, - y + r);
				cairo_pattern_set_matrix(core->temp_pattern, &matrix);
				cairo_set_source(window->alpha_cairo, core->temp_pattern);

				for(counter_y=0; counter_y<height; counter_y++)
				{
					(void)memset(&window->mask_temp->pixels[(start_y+counter_y)*window->width
						+ start_x], 0, width);
				}

				cairo_mask_surface(window->alpha_cairo,
					window->selection->surface_p, 0, 0);
				cairo_set_source_surface(window->gray_mask_cairo,
					window->alpha_surface, 0, 0);
				cairo_mask_surface(window->gray_mask_cairo,
					window->active_layer->surface_p, 0, 0);

				mask = window->mask_temp->pixels;
			}
		}

#ifdef _OPENMP
		if(height <= MINIMUM_PARALLEL_SIZE)
		{
			omp_set_dynamic(FALSE);
			omp_set_num_threads(1);
		}
#pragma omp parallel for firstprivate(width, temp_stride, temp_pixels, mask, layer_width, start_x, start_y)
#endif
		for(counter_y=0; counter_y<height; counter_y++)
		{
			int counter_x;
			for(counter_x=0; counter_x<width; counter_x++)
			{
				temp_pixels[temp_stride*counter_y+counter_x*5+4] =
					mask[layer_width*(counter_y+start_y)+(counter_x+start_x)];
			}
		}
	#ifdef _OPENMP
		omp_set_dynamic(TRUE);
		omp_set_num_threads(window->app->max_threads);
#endif

		top = start_i = start_y-extends, left = start_j=start_x-extends;
		end_i = start_y+extends, end_j=start_x+extends;
		if(start_i < 0)
		{
			start_i = 0;
		}
		if(start_j < 0)
		{
			start_j = 0;
		}
		if(end_i > window->work_layer->height)
		{
			if(start_i >= window->work_layer->height)
			{
				skip_loop = TRUE;
			}
			end_i = window->work_layer->height;
		}
		if(end_j > window->work_layer->width)
		{
			if(start_j >= window->work_layer->width)
			{
				skip_loop = TRUE;
			}
			end_j = window->work_layer->width;
		}

		sum_color0 = sum_color1 = sum_color2 = sum_color3 = 0;

		if(skip_loop == FALSE)
		{
			for(i=start_i ; i<end_i; i++)
			{
				int j;
				for(j=start_j; j<end_j; j++)
				{
					uint8 *add_pixel = &work_pixels[i*stride+j*4];
					sum_color0 += add_pixel[0];
					sum_color1 += add_pixel[1];
					sum_color2 += add_pixel[2];
					sum_color3 += add_pixel[3];
				}
			}

			before_y_color[0] = sum_color0;
			before_y_color[1] = sum_color1;
			before_y_color[2] = sum_color2;
			before_y_color[3] = sum_color3;

			for(counter_y=0; counter_y<height; counter_y++)
			{
				left = start_j = start_x-extends, end_j = start_x+extends;
				i = counter_y+start_y-extends, end_i = counter_y+start_y+extends;
				if(i < 0)
				{
					i = 0;
				}
				if(end_i >= window->work_layer->height)
				{
					if(i >= window->work_layer->height-1)
					{
						i = -1;
						counter_y = height;
					}
					end_i = window->work_layer->height-1;
				}

				if(i >= 0)
				{
					if(start_j < 0)
					{
						start_j = 0;
					}
					if(end_j > window->work_layer->width)
					{
						end_j = window->work_layer->width;
					}
					num_samples = (end_i-i)*(end_j-start_j);

					for(counter_x=0; counter_x<width; counter_x++, start_j++, end_j++)
					{
						temp_pixel = &window->temp_layer->pixels[counter_y*temp_stride+counter_x*5];
						temp_pixel[0] = sum_color0 / num_samples;
						temp_pixel[1] = sum_color1 / num_samples;
						temp_pixel[2] = sum_color2 / num_samples;
						temp_pixel[3] = sum_color3 / num_samples;

						if(left >= 0)
						{
							for(j=i; j<end_i; j++)
							{
								uint8 *add_pixel = &work_pixels[j*stride+start_j*4];
								sum_color0 -= add_pixel[0];
								sum_color1 -= add_pixel[1];
								sum_color2 -= add_pixel[2];
								sum_color3 -= add_pixel[3];
							}
						}
						else
						{
							left++;
						}

						for(j=i; j<end_i; j++)
						{
							uint8 *add_pixel = &work_pixels[j*stride+(end_j)*4];
							sum_color0 += add_pixel[0];
							sum_color1 += add_pixel[1];
							sum_color2 += add_pixel[2];
							sum_color3 += add_pixel[3];
						}
					}

					start_j = start_x-extends, end_j = start_x+extends;
					sum_color0 = before_y_color[0];
					sum_color1 = before_y_color[1];
					sum_color2 = before_y_color[2];
					sum_color3 = before_y_color[3];

					if(top >= 0)
					{
						for(j=start_j; j<end_j; j++)
						{
							uint8 *add_pixel = &work_pixels[i*stride+j*4];
							sum_color0 -= add_pixel[0];
							sum_color1 -= add_pixel[1];
							sum_color2 -= add_pixel[2];
							sum_color3 -= add_pixel[3];
						}
					}
					else
					{
						top++;
					}

					for(j=start_j; j<end_j; j++)
					{
						add_pixel = &work_pixels[(end_i)*stride+j*4];
						sum_color0 += add_pixel[0];
						sum_color1 += add_pixel[1];
						sum_color2 += add_pixel[2];
						sum_color3 += add_pixel[3];
					}

					before_y_color[0] = sum_color0;
					before_y_color[1] = sum_color1;
					before_y_color[2] = sum_color2;
					before_y_color[3] = sum_color3;
				}
			}

			if(i >= 0)
			{
#ifdef _OPENMP
				if(height <= MINIMUM_PARALLEL_SIZE)
				{
					omp_set_dynamic(FALSE);
					omp_set_num_threads(1);
				}
#pragma omp parallel for firstprivate(width, temp_stride, temp_pixels, start_x, start_y, work_pixels)
#endif
				for(counter_y=0; counter_y<height; counter_y++)
				{
					int counter_x;
					for(counter_x=0; counter_x<width; counter_x++)
					{
						uint8 *temp_pixel = &temp_pixels[counter_y*temp_stride+counter_x*5];
						uint8 t = temp_pixel[4];
						uint8 *add_pixel = &work_pixels[stride*(counter_y+start_y)+(counter_x+start_x)*4];

						add_pixel[0] = ((0xff - t) * add_pixel[0] + t * temp_pixel[0]) / 255;
						add_pixel[1] = ((0xff - t) * add_pixel[1] + t * temp_pixel[1]) / 255;
						add_pixel[2] = ((0xff - t) * add_pixel[2] + t * temp_pixel[2]) / 255;
						add_pixel[3] = ((0xff - t) * add_pixel[3] + t * temp_pixel[3]) / 255;
					}
				}
			}
		}
	}
}

static void BlurToolEditSelectionPressCallBack(
	DRAW_WINDOW* window,
	FLOAT_T x,
	FLOAT_T y,
	FLOAT_T pressure,
	BRUSH_CORE *core,
	void* state
)
{
	if(((GdkEventButton*)state)->button == 1)
	{
		BLUR_TOOL* blur = (BLUR_TOOL*)core->brush_data;
		FLOAT_T r, alpha;
		FLOAT_T zoom;
		cairo_matrix_t matrix;
		int extends;
		int num_samples;
		FLOAT_T min_x, min_y, max_x, max_y;
		int sum_color[2], before_y_color[2];
		int stride = window->work_layer->width;
		uint8* work_pixels = window->work_layer->pixels;
		uint8 *add_pixel, *temp_pixel, *mask;
		uint8 t;
		int counter_x, counter_y, start_x, start_y, width, height;
		int start_j, end_i, end_j;
		int temp_stride;
		int i, j;

		window->selection->layer_mode = SELECTION_BLEND_COPY;

		(void)memcpy(window->work_layer->pixels, window->selection->pixels,
			window->width * window->height);

		if((blur->flags & BRUSH_FLAG_SIZE) != 0)
		{
			r = blur->r * pressure;
			zoom = 1/pressure;
		}
		else
		{
			r = blur->r;
			zoom = 1;
		}
		alpha = ((blur->flags & BRUSH_FLAG_FLOW) == 0) ? 1 : pressure;
		extends = (int)(r * (blur->color_extend * 0.01))/2;
		if(extends == 0)
		{
			return;
		}

		min_x = x - r, min_y = y - r;
		max_x = x + r, max_y = y + r;

		blur->before_x = x, blur->before_y = y;

		if(min_x < 0.0)
		{
			min_x = 0.0;
		}
		if(min_y < 0.0)
		{
			min_y = 0.0;
		}
		if(max_x > window->work_layer->width)
		{
			max_x = window->work_layer->width;
		}
		if(max_y > window->work_layer->height)
		{
			max_y = window->work_layer->height;
		}

		core->min_x = min_x, core->min_y = min_y;
		core->max_x = max_x, core->max_y = max_y;
		start_x = (int32)core->min_x, start_y = (int32)core->min_y;
		width = (int32)(core->max_x-core->min_x);
		height = (int32)(core->max_y-core->min_y);
		temp_stride = width*2;

		for(counter_y=0; counter_y<height; counter_y++)
		{
			(void)memset(&window->mask->pixels[(start_y+counter_y)*window->width
				+ start_x], 0, width);
		}

		cairo_set_operator(window->mask_temp->cairo_p, CAIRO_OPERATOR_OVER);
		mask = window->mask->pixels;
		cairo_set_operator(window->alpha_cairo, CAIRO_OPERATOR_OVER);
		if((window->flags & DRAW_WINDOW_HAS_SELECTION_AREA) == 0)
		{
			if((window->active_layer->flags & LAYER_LOCK_OPACITY) == 0)
			{
				cairo_matrix_init_scale(&matrix, zoom, zoom);
				cairo_matrix_translate(&matrix, - x + r, - y + r);
				cairo_pattern_set_matrix(core->brush_pattern, &matrix);
				cairo_set_source(window->alpha_cairo, core->brush_pattern);
				cairo_paint_with_alpha(window->alpha_cairo, alpha);
			}
			else
			{
				cairo_matrix_init_scale(&matrix, zoom, zoom);
				cairo_pattern_set_matrix(core->brush_pattern, &matrix);
				cairo_set_source(core->temp_cairo, core->brush_pattern);
				cairo_paint_with_alpha(core->temp_cairo, alpha);
				cairo_matrix_init_translate(&matrix, - x + r, - y + r);
				cairo_pattern_set_matrix(core->temp_pattern, &matrix);
				cairo_set_source(window->alpha_cairo, core->temp_pattern);
				cairo_mask_surface(window->alpha_cairo,
					window->active_layer->surface_p, 0, 0);
			}
		}
		else
		{
			if((window->active_layer->flags & LAYER_LOCK_OPACITY) == 0)
			{
				cairo_matrix_init_scale(&matrix, zoom, zoom);
				cairo_pattern_set_matrix(core->brush_pattern, &matrix);
				cairo_set_source(core->temp_cairo, core->brush_pattern);
				cairo_paint_with_alpha(core->temp_cairo, alpha);
				cairo_matrix_init_translate(&matrix, - x + r, - y + r);
				cairo_pattern_set_matrix(core->temp_pattern, &matrix);
				cairo_set_source(window->alpha_cairo, core->temp_pattern);
				cairo_mask_surface(window->alpha_cairo,
					window->selection->surface_p, 0, 0);
			}
			else
			{
				cairo_matrix_init_scale(&matrix, zoom, zoom);
				cairo_pattern_set_matrix(core->brush_pattern, &matrix);
				cairo_set_source(core->temp_cairo, core->brush_pattern);
				cairo_paint_with_alpha(core->temp_cairo, alpha);
				cairo_matrix_init_translate(&matrix, - x + r, - y + r);
				cairo_pattern_set_matrix(core->temp_pattern, &matrix);
				cairo_set_source(window->alpha_cairo, core->temp_pattern);

				for(counter_y=0; counter_y<height; counter_y++)
				{
					(void)memset(&window->mask_temp->pixels[(start_y+counter_y)*window->width
						+ start_x], 0, width);
				}

				cairo_mask_surface(window->alpha_cairo,
					window->selection->surface_p, 0, 0);
				cairo_set_source_surface(window->gray_mask_cairo,
					window->alpha_surface, 0, 0);
				cairo_mask_surface(window->gray_mask_cairo,
					window->active_layer->surface_p, 0, 0);

				mask = window->mask_temp->pixels;
			}
		}

		for(counter_y=0; counter_y<height; counter_y++)
		{
			for(counter_x=0; counter_x<width; counter_x++)
			{
				window->temp_layer->pixels[temp_stride*counter_y+counter_x*2+1] =
					mask[window->width*(counter_y+start_y)+(counter_x+start_x)];
			}
		}

		i = start_y-extends, start_j=start_x-extends;
		end_i = start_y+extends, end_j=start_x+extends;
		if(i < 0)
		{
			i = 0;
		}
		if(start_j < 0)
		{
			start_j = 0;
		}
		if(end_i > window->work_layer->height)
		{
			if(i >= window->work_layer->height-1)
			{
				return;
			}
			end_i = window->work_layer->height-1;
		}
		if(end_j > window->work_layer->width)
		{
			if(start_j >= window->work_layer->width)
			{
				return;
			}
			end_j = window->work_layer->width;
		}

		sum_color[0] = 0;
		for( ; i<end_i; i++)
		{
			for(j=start_j; j<end_j; j++)
			{
				add_pixel = &work_pixels[i*stride+j];
				sum_color[0] += add_pixel[0];
			}
		}
		before_y_color[0] = sum_color[0];

		for(counter_y=0; counter_y<height; counter_y++)
		{
			start_j = start_x-extends, end_j = start_x+extends;
			i = counter_y+start_y-extends, end_i = counter_y+start_y+extends;
			if(i < 0)
			{
				i = 0;
			}
			if(end_i > window->work_layer->height)
			{
				end_i = window->work_layer->height;
			}
			if(start_j < 0)
			{
				start_j = 0;
			}
			if(end_j > window->work_layer->width)
			{
				end_j = window->work_layer->width;
			}
			num_samples = (end_i-i)*(end_j-start_j);

			for(counter_x=0; counter_x<width; counter_x++, start_j++, end_j++)
			{
				temp_pixel = &window->temp_layer->pixels[counter_y*temp_stride+counter_x*2];
				temp_pixel[0] = sum_color[0] / num_samples;
				
				for(j=i; j<end_i; j++)
				{
					add_pixel = &work_pixels[j*stride+start_j];
					sum_color[0] -= add_pixel[0];
					
				}
				for(j=i; j<end_i; j++)
				{
					add_pixel = &work_pixels[j*stride+(end_j)];
					sum_color[0] += add_pixel[0];
				}
			}

			start_j = start_x-extends, end_j = start_x+extends;
			sum_color[0] = before_y_color[0];
			for(j=start_j; j<end_j; j++)
			{
				add_pixel = &work_pixels[i*stride+j];
				sum_color[0] -= add_pixel[0];
			}
				
			for(j=start_j; j<end_j; j++)
			{
				add_pixel = &work_pixels[(end_i)*stride+j];
				sum_color[0] += add_pixel[0];
			}
			before_y_color[0] = sum_color[0];
		}

		for(counter_y=0; counter_y<height; counter_y++)
		{
			for(counter_x=0; counter_x<width; counter_x++)
			{
				temp_pixel = &window->temp_layer->pixels[counter_y*temp_stride+counter_x*2];
				t = temp_pixel[1];
				add_pixel = &work_pixels[stride*(counter_y+start_y)+(counter_x+start_x)];

				add_pixel[0] = ((0xff - t) * add_pixel[0] + t * temp_pixel[0]) / 255;
			}
		}
	}
}

static void BlurToolMotionCallBack(
	DRAW_WINDOW* window,
	FLOAT_T x,
	FLOAT_T y,
	FLOAT_T pressure,
	BRUSH_CORE *core,
	void* state
)
{
	if(((*(GdkModifierType*)state) & GDK_BUTTON1_MASK) != 0)
	{
		BLUR_TOOL* blur = (BLUR_TOOL*)core->brush_data;
		FLOAT_T r, alpha, d, step;
		FLOAT_T zoom;
		cairo_matrix_t matrix;
		FLOAT_T min_x, min_y, max_x, max_y;
		FLOAT_T draw_x = blur->before_x, draw_y = blur->before_y;
		FLOAT_T dx, dy, cos_x, sin_y;
		FLOAT_T hardness = blur->outline_hardness * 0.01f;
		int32 clear_x, clear_width, clear_y, clear_height;
		int sum_color0 = 0, sum_color1 = 0, sum_color2 = 0, sum_color3 = 0;
		int before_y_color[4];
		int extends, num_samples;
		int layer_width = window->work_layer->width;
		uint8 *work_pixels = window->work_layer->pixels;
		uint8 *temp_pixels = window->temp_layer->pixels;
		uint8 *mask;
		uint8 *add_pixel;
		uint8 alpha_c;
		gboolean skip_draw;
		int stride = window->work_layer->stride;
		int left;
		int top;
		int start_i, start_j, end_i, end_j;
		int i, j, counter_x, counter_y;
		int temp_stride;

		if((blur->flags & BRUSH_FLAG_SIZE) != 0)
		{
			r = blur->r * pressure;
			zoom = 1/pressure;
		}
		else
		{
			r = blur->r;
			zoom = 1;
		}
		extends = (int)(r * (blur->color_extend*0.01f))/2;
		if(extends == 0)
		{
			return;
		}
		
		dx = x-blur->before_x, dy = y-blur->before_y;
		d = sqrt(dx*dx+dy*dy);
		step = r * BRUSH_STEP;
		if(step < 1)
		{
			step = 1;
		}

		alpha = ((blur->flags & BRUSH_FLAG_FLOW) == 0) ? 1 : pressure;
		alpha_c = (uint8)(alpha * 255);
		cos_x = step * dx / d, sin_y = step * dy / d;

		min_x = x - r*2, min_y = y - r*2;
		max_x = x + r*2, max_y = y + r*2;

		if(min_x < 0.0)
		{
			min_x = 0.0;
		}
		if(min_y < 0.0)
		{
			min_y = 0.0;
		}
		if(max_x > window->work_layer->width)
		{
			max_x = window->work_layer->width;
		}
		if(max_y > window->work_layer->height)
		{
			max_y = window->work_layer->height;
		}

		if(core->min_x > min_x)
		{
			core->min_x = min_x;
		}
		if(core->min_y > min_y)
		{
			core->min_y = min_y;
		}
		if(core->max_x < max_x)
		{
			core->max_x = max_x;
		}
		if(core->max_y < max_y)
		{
			core->max_y = max_y;
		}

		if(window->update.x > min_x)
		{
			window->update.width += window->update.x - (int)min_x;
			window->update.x = (int)min_x;
		}
		if(window->update.width + window->update.x < max_x)
		{
			window->update.width += (int)max_x - window->update.width + window->update.x;
		}
		if(window->update.y > min_y)
		{
			window->update.height += window->update.y - (int)min_y;
			window->update.y = (int)min_y;
		}
		if(window->update.height + window->update.y < max_y)
		{
			window->update.height += (int)max_y - window->update.height + window->update.y;
		}
		window->flags |= DRAW_WINDOW_UPDATE_PART;

		cairo_set_operator(window->mask_temp->cairo_p, CAIRO_OPERATOR_OVER);
		(void)memcpy(window->mask_temp->pixels, work_pixels, window->pixel_buf_size);
		cairo_set_operator(window->temp_layer->cairo_p, CAIRO_OPERATOR_OVER);
		dx = d;

		do
		{
			skip_draw = FALSE;

			clear_x = (int32)(draw_x - r - 1);
			clear_width = (int32)(draw_x + r + 1);
			clear_y = (int32)(draw_y - r - 1);
			clear_height = (int32)(draw_y + r + 1);

			if(clear_x < 0)
			{
				clear_x = 0;
			}
			else if(clear_x >= window->width)
			{
				skip_draw = TRUE;
			}
			if(clear_y < 0)
			{
				clear_y = 0;
			}
			if(clear_height >= window->height)
			{
				clear_height = window->height;
			}
			clear_width = clear_width - clear_x;
			clear_height = clear_height - clear_y;
			temp_stride = clear_width*5;

			if(clear_width <= 0 || clear_height <= 0)
			{
				skip_draw = TRUE;
			}

			if(skip_draw == FALSE)
			{
				for(counter_y=0; counter_y<clear_height; counter_y++)
				{
					(void)memset(&window->mask->pixels[(clear_y+counter_y)*window->width
						+ clear_x], 0, clear_width);
				}

				cairo_set_operator(window->mask_temp->cairo_p, CAIRO_OPERATOR_OVER);
				mask = window->mask->pixels;
				cairo_set_operator(window->alpha_cairo, CAIRO_OPERATOR_OVER);
				if((window->flags & DRAW_WINDOW_HAS_SELECTION_AREA) == 0)
				{
					if((window->active_layer->flags & LAYER_LOCK_OPACITY) == 0)
					{
						cairo_matrix_init_scale(&matrix, zoom, zoom);
						cairo_matrix_translate(&matrix, - x + r, - y + r);
						cairo_pattern_set_matrix(core->brush_pattern, &matrix);
						cairo_set_source(window->alpha_cairo, core->brush_pattern);
						cairo_paint_with_alpha(window->alpha_cairo, alpha);
					}
					else
					{
						cairo_matrix_init_scale(&matrix, zoom, zoom);
						cairo_pattern_set_matrix(core->brush_pattern, &matrix);
						cairo_set_source(core->temp_cairo, core->brush_pattern);
						cairo_paint_with_alpha(core->temp_cairo, alpha);
						cairo_matrix_init_translate(&matrix, - x + r, - y + r);
						cairo_pattern_set_matrix(core->temp_pattern, &matrix);
						cairo_set_source(window->alpha_cairo, core->temp_pattern);
						cairo_mask_surface(window->alpha_cairo,
							window->active_layer->surface_p, 0, 0);
					}
				}
				else
				{
					if((window->active_layer->flags & LAYER_LOCK_OPACITY) == 0)
					{
						cairo_matrix_init_scale(&matrix, zoom, zoom);
						cairo_pattern_set_matrix(core->brush_pattern, &matrix);
						cairo_set_source(core->temp_cairo, core->brush_pattern);
						cairo_paint_with_alpha(core->temp_cairo, alpha);
						cairo_matrix_init_translate(&matrix, - x + r, - y + r);
						cairo_pattern_set_matrix(core->temp_pattern, &matrix);
						cairo_set_source(window->alpha_cairo, core->temp_pattern);
						cairo_mask_surface(window->alpha_cairo,
							window->selection->surface_p, 0, 0);
					}
					else
					{
						cairo_matrix_init_scale(&matrix, zoom, zoom);
						cairo_pattern_set_matrix(core->brush_pattern, &matrix);
						cairo_set_source(core->temp_cairo, core->brush_pattern);
						cairo_paint_with_alpha(core->temp_cairo, alpha);
						cairo_matrix_init_translate(&matrix, - x + r, - y + r);
						cairo_pattern_set_matrix(core->temp_pattern, &matrix);
						cairo_set_source(window->alpha_cairo, core->temp_pattern);

						for(counter_y=0; counter_y<clear_height; counter_y++)
						{
							(void)memset(&window->mask_temp->pixels[(clear_y+counter_y)*window->width
								+ clear_x], 0, clear_width);
						}

						cairo_mask_surface(window->alpha_cairo,
							window->selection->surface_p, 0, 0);
						cairo_set_source_surface(window->gray_mask_cairo,
							window->alpha_surface, 0, 0);
						cairo_mask_surface(window->gray_mask_cairo,
							window->active_layer->surface_p, 0, 0);

						mask = window->mask_temp->pixels;
					}
				}

				sum_color0 = sum_color1 = sum_color2 = sum_color3 = 0;

#ifdef _OPENMP
				if(clear_height <= MINIMUM_PARALLEL_SIZE)
				{
					omp_set_dynamic(FALSE);
					omp_set_num_threads(1);
				}
#pragma omp parallel for firstprivate(clear_width, temp_pixels, temp_stride, layer_width, clear_x, clear_y)
#endif
				for(counter_y=0; counter_y<clear_height; counter_y++)
				{
					int counter_x;
					for(counter_x=0; counter_x<clear_width; counter_x++)
					{
						temp_pixels[temp_stride*counter_y+counter_x*5+4] =
							mask[layer_width*(counter_y+clear_y)+(counter_x+clear_x)];
					}
				}

				start_i = clear_y-extends, start_j=clear_x-extends;
				end_i = clear_y+extends, end_j=clear_x+extends;
				if(start_i < 0)
				{
					start_i = 0;
				}
				if(start_j < 0)
				{
					start_j = 0;
				}
				if(end_i > window->work_layer->height)
				{
					end_i = window->work_layer->height;
				}
				if(end_j > window->work_layer->width)
				{
					end_j = window->work_layer->width;
				}

				for(i=start_i; i<end_i; i++)
				{
					int j;
					for(j=start_j; j<end_j; j++)
					{
						uint8 *add_pixel = &work_pixels[i*stride+j*4];
						sum_color0 += add_pixel[0];
						sum_color1 += add_pixel[1];
						sum_color2 += add_pixel[2];
						sum_color3 += add_pixel[3];
					}
				}

				before_y_color[0] = sum_color0;
				before_y_color[1] = sum_color1;
				before_y_color[2] = sum_color2;
				before_y_color[3] = sum_color3;

				for(counter_y=0; counter_y<clear_height; counter_y++)
				{
					left = start_j = clear_x-extends, end_j = clear_x+extends;
					top = i = counter_y+clear_y-extends, end_i = counter_y+clear_y+extends;
					if(i < 0)
					{
						i = 0;
					}
					if(end_i >= window->work_layer->height)
					{
						if(i >= window->work_layer->height-1)
						{
							i = -1;
							counter_y = clear_height;
						}
						end_i = window->work_layer->height-1;
					}
					if(start_j < 0)
					{
						start_j = 0;
					}
					if(end_j > window->work_layer->width)
					{
						end_j = window->work_layer->width;
					}
					num_samples = (end_i-i)*(end_j-start_j);

					if(i >= 0)
					{
						for(counter_x=0; counter_x<clear_width; counter_x++, start_j++, end_j++)
						{
							add_pixel = &window->temp_layer->pixels[counter_y*temp_stride+counter_x*5];
							add_pixel[0] = sum_color0 / num_samples;
							add_pixel[1] = sum_color1 / num_samples;
							add_pixel[2] = sum_color2 / num_samples;
							add_pixel[3] = sum_color3 / num_samples;

							if(left >= 0)
							{
								for(j=i; j<end_i; j++)
								{
									uint8 *add_pixel = &work_pixels[j*stride+start_j*4];
									sum_color0 -= add_pixel[0];
									sum_color1 -= add_pixel[1];
									sum_color2 -= add_pixel[2];
									sum_color3 -= add_pixel[3];
								}
							}
							else
							{
								left++;
							}

							if(end_j < window->width)
							{
								for(j=i; j<end_i; j++)
								{
									uint8 *add_pixel = &work_pixels[j*stride+(end_j)*4];
									sum_color0 += add_pixel[0];
									sum_color1 += add_pixel[1];
									sum_color2 += add_pixel[2];
									sum_color3 += add_pixel[3];
								}
							}
						}

						start_j = clear_x-extends, end_j = clear_x+extends;
						sum_color0 = before_y_color[0];
						sum_color1 = before_y_color[1];
						sum_color2 = before_y_color[2];
						sum_color3 = before_y_color[3];

						if(top >= 0)
						{
							for(j=start_j; j<end_j; j++)
							{
								uint8 *add_pixel = &work_pixels[i*stride+j*4];
								sum_color0 -= add_pixel[0];
								sum_color1 -= add_pixel[1];
								sum_color2 -= add_pixel[2];
								sum_color3 -= add_pixel[3];
							}
						}
						else
						{
							top++;
						}

						for(j=start_j; j<end_j; j++)
						{
							uint8 *add_pixel = &work_pixels[(end_i)*stride+j*4];
							sum_color0 += add_pixel[0];
							sum_color1 += add_pixel[1];
							sum_color2 += add_pixel[2];
							sum_color3 += add_pixel[3];
						}

						before_y_color[0] = sum_color0;
						before_y_color[1] = sum_color1;
						before_y_color[2] = sum_color2;
						before_y_color[3] = sum_color3;
					}
				}
#ifdef _OPENMP
#pragma omp parallel for firstprivate(clear_width, clear_x, clear_y, temp_pixels, work_pixels, stride, temp_stride)
#endif
				for(counter_y=0; counter_y<clear_height; counter_y++)
				{
					int counter_x;
					for(counter_x=0; counter_x<clear_width; counter_x++)
					{
						uint8 *temp_pixel = &temp_pixels[counter_y*temp_stride+counter_x*5];
						uint8 t = temp_pixel[4];
						uint8 *add_pixel = &work_pixels[stride*(counter_y+clear_y)+(counter_x+clear_x)*4];

						add_pixel[0] = ((0xff- t + 1) * add_pixel[0] + t * temp_pixel[0]) >> 8;
						add_pixel[1] = ((0xff- t + 1) * add_pixel[1] + t * temp_pixel[1]) >> 8;
						add_pixel[2] = ((0xff- t + 1) * add_pixel[2] + t * temp_pixel[2]) >> 8;
						add_pixel[3] = ((0xff- t + 1) * add_pixel[3] + t * temp_pixel[3]) >> 8;
					}
				}
			}
#ifdef _OPENMP
			omp_set_dynamic(TRUE);
			omp_set_num_threads(window->app->max_threads);
#endif
			dx -= step;
			if(dx < 1)
			{
				skip_draw = TRUE;
			}
			else
			{
				skip_draw = FALSE;
				if(dx >= step)
				{
					draw_x += cos_x, draw_y += sin_y;
				}
				else
				{
					draw_x = x, draw_y = y;
				}
			}
		} while(skip_draw == FALSE);

		blur->before_x = x, blur->before_y = y;
	}
}

static void BlurToolEditSelectionMotionCallBack(
	DRAW_WINDOW* window,
	FLOAT_T x,
	FLOAT_T y,
	FLOAT_T pressure,
	BRUSH_CORE *core,
	void* state
)
{
	if(((*(GdkModifierType*)state) & GDK_BUTTON1_MASK) != 0)
	{
		BLUR_TOOL* blur = (BLUR_TOOL*)core->brush_data;
		FLOAT_T r, alpha, d, step;
		FLOAT_T zoom;
		cairo_matrix_t matrix;
		FLOAT_T min_x, min_y, max_x, max_y;
		FLOAT_T draw_x = blur->before_x, draw_y = blur->before_y;
		FLOAT_T dx, dy, cos_x, sin_y;
		FLOAT_T hardness = blur->outline_hardness * 0.01f;
		int32 clear_x, clear_width, clear_y, clear_height;
		int sum_color[2];
		int before_y_color[2];
		int extends, num_samples;
		uint8* work_pixels = window->work_layer->pixels;
		uint8* add_pixel;
		uint8* temp_pixel;
		uint8* mask;
		uint8 alpha_c, t;
		int stride = window->work_layer->width;
		int start_j, end_i, end_j;
		int i, j, counter_x, counter_y;
		int temp_stride;

		if((blur->flags & BRUSH_FLAG_SIZE) != 0)
		{
			r = blur->r * pressure;
			zoom = 1/pressure;
		}
		else
		{
			r = blur->r;
			zoom = 1;
		}
		extends = (int)(r * (blur->color_extend*0.01f))/2;
		if(extends == 0)
		{
			return;
		}
		
		dx = x-blur->before_x, dy = y-blur->before_y;
		d = sqrt(dx*dx+dy*dy);
		step = r * BRUSH_STEP;
		if(step < 1)
		{
			step = 1;
		}

		alpha = ((blur->flags & BRUSH_FLAG_FLOW) == 0) ?
			blur->alpha * 0.01 : blur->alpha * 0.01 * pressure;
		alpha_c = (uint8)(alpha * 255);
		cos_x = step * dx / d, sin_y = step * dy / d;

		min_x = x - r*2, min_y = y - r*2;
		max_x = x + r*2, max_y = y + r*2;

		if(min_x < 0.0)
		{
			return;
			//min_x = 0.0;
		}
		if(min_y < 0.0)
		{
			return;
			//min_y = 0.0;
		}
		if(max_x > window->work_layer->width)
		{
			return;
			//max_x = window->work_layer->width;
		}
		if(max_y > window->work_layer->height)
		{
			return;
			//max_y = window->work_layer->height;
		}

		if(core->min_x > min_x)
		{
			core->min_x = min_x;
		}
		if(core->min_y > min_y)
		{
			core->min_y = min_y;
		}
		if(core->max_x < max_x)
		{
			core->max_x = max_x;
		}
		if(core->max_y < max_y)
		{
			core->max_y = max_y;
		}

		cairo_set_operator(window->mask_temp->cairo_p, CAIRO_OPERATOR_OVER);
		(void)memcpy(window->mask_temp->pixels, work_pixels, window->pixel_buf_size);
		cairo_set_operator(window->temp_layer->cairo_p, CAIRO_OPERATOR_OVER);
		dx = d;

		do
		{
			clear_x = (int32)(draw_x - r - 1);
			clear_width = (int32)(draw_x + r + 1);
			clear_y = (int32)(draw_y - r - 1);
			clear_height = (int32)(draw_y + r + 1);

			if(clear_x < 0)
			{
				clear_x = 0;
			}
			else if(clear_x >= window->width)
			{
				goto skip_draw;
			}
			if(clear_y < 0)
			{
				clear_y = 0;
			}
			if(clear_height >= window->height)
			{
				clear_height = window->height;
			}
			clear_width = clear_width - clear_x;
			clear_height = clear_height - clear_y;
			temp_stride = clear_width*2;

			if(clear_width <= 0 || clear_height <= 0)
			{
				goto skip_draw;
			}

			for(counter_y=0; counter_y<clear_height; counter_y++)
			{
				(void)memset(&window->mask->pixels[(clear_y+counter_y)*window->width
					+ clear_x], 0, clear_width);
			}

			cairo_set_operator(window->mask_temp->cairo_p, CAIRO_OPERATOR_OVER);
			mask = window->mask->pixels;
			cairo_set_operator(window->alpha_cairo, CAIRO_OPERATOR_OVER);
			if((window->flags & DRAW_WINDOW_HAS_SELECTION_AREA) == 0)
			{
				if((window->active_layer->flags & LAYER_LOCK_OPACITY) == 0)
				{
					cairo_matrix_init_scale(&matrix, zoom, zoom);
					cairo_matrix_translate(&matrix, - x + r, - y + r);
					cairo_pattern_set_matrix(core->brush_pattern, &matrix);
					cairo_set_source(window->alpha_cairo, core->brush_pattern);
					cairo_paint_with_alpha(window->alpha_cairo, alpha);
				}
				else
				{
					cairo_matrix_init_scale(&matrix, zoom, zoom);
					cairo_pattern_set_matrix(core->brush_pattern, &matrix);
					cairo_set_source(core->temp_cairo, core->brush_pattern);
					cairo_paint_with_alpha(core->temp_cairo, alpha);
					cairo_matrix_init_translate(&matrix, - x + r, - y + r);
					cairo_pattern_set_matrix(core->temp_pattern, &matrix);
					cairo_set_source(window->alpha_cairo, core->temp_pattern);
					cairo_mask_surface(window->alpha_cairo,
						window->active_layer->surface_p, 0, 0);
				}
			}
			else
			{
				if((window->active_layer->flags & LAYER_LOCK_OPACITY) == 0)
				{
					cairo_matrix_init_scale(&matrix, zoom, zoom);
					cairo_pattern_set_matrix(core->brush_pattern, &matrix);
					cairo_set_source(core->temp_cairo, core->brush_pattern);
					cairo_paint_with_alpha(core->temp_cairo, alpha);
					cairo_matrix_init_translate(&matrix, - x + r, - y + r);
					cairo_pattern_set_matrix(core->temp_pattern, &matrix);
					cairo_set_source(window->alpha_cairo, core->temp_pattern);
					cairo_mask_surface(window->alpha_cairo,
						window->selection->surface_p, 0, 0);
				}
				else
				{
					cairo_matrix_init_scale(&matrix, zoom, zoom);
					cairo_pattern_set_matrix(core->brush_pattern, &matrix);
					cairo_set_source(core->temp_cairo, core->brush_pattern);
					cairo_paint_with_alpha(core->temp_cairo, alpha);
					cairo_matrix_init_translate(&matrix, - x + r, - y + r);
					cairo_pattern_set_matrix(core->temp_pattern, &matrix);
					cairo_set_source(window->alpha_cairo, core->temp_pattern);

					for(counter_y=0; counter_y<clear_height; counter_y++)
					{
						(void)memset(&window->mask_temp->pixels[(clear_y+counter_y)*window->width
							+ clear_x], 0, clear_width);
					}

					cairo_mask_surface(window->alpha_cairo,
						window->selection->surface_p, 0, 0);
					cairo_set_source_surface(window->gray_mask_cairo,
						window->alpha_surface, 0, 0);
					cairo_mask_surface(window->gray_mask_cairo,
						window->active_layer->surface_p, 0, 0);

					mask = window->mask_temp->pixels;
				}
			}

			for(counter_y=0; counter_y<clear_height; counter_y++)
			{
				for(counter_x=0; counter_x<clear_width; counter_x++)
				{
					window->temp_layer->pixels[temp_stride*counter_y+counter_x*2+1] =
						mask[window->width*(counter_y+clear_y)+(counter_x+clear_x)];
				}
			}

			i = clear_y-extends, start_j=clear_x-extends;
			end_i = clear_y+extends, end_j=clear_x+extends;
			if(i < 0)
			{
				i = 0;
			}
			if(start_j < 0)
			{
				start_j = 0;
			}
			if(end_i > window->work_layer->height)
			{
				end_i = window->work_layer->height;
			}
			if(end_j > window->work_layer->width)
			{
				end_j = window->work_layer->width;
			}

			sum_color[0] = 0;
			for( ; i<end_i; i++)
			{
				for(j=start_j; j<end_j; j++)
				{
					add_pixel = &work_pixels[i*stride+j];
					sum_color[0] += add_pixel[0];
				}
			}
			before_y_color[0] = sum_color[0];

			for(counter_y=0; counter_y<clear_height; counter_y++)
			{
				start_j = clear_x-extends, end_j = clear_x+extends;
				i = counter_y+clear_y-extends, end_i = counter_y+clear_y+extends;
				if(i < 0)
				{
					i = 0;
				}
				if(end_i > window->work_layer->height)
				{
					end_i = window->work_layer->height;
				}
				if(start_j < 0)
				{
					start_j = 0;
				}
				if(end_j > window->work_layer->width)
				{
					end_j = window->work_layer->width;
				}
				num_samples = (end_i-i)*(end_j-start_j);

				for(counter_x=0; counter_x<clear_width; counter_x++, start_j++, end_j++)
				{
					add_pixel = &window->temp_layer->pixels[counter_y*temp_stride+counter_x*2];
					add_pixel[0] = sum_color[0] / num_samples;

					for(j=i; j<end_i; j++)
					{
						add_pixel = &work_pixels[j*stride+start_j];
						sum_color[0] -= add_pixel[0];
					}
					for(j=i; j<end_i; j++)
					{
						add_pixel = &work_pixels[j*stride+(end_j)];
						sum_color[0] += add_pixel[0];
					}
				}

				start_j = clear_x-extends, end_j = clear_x+extends;
				sum_color[0] = before_y_color[0];
				for(j=start_j; j<end_j; j++)
				{
					add_pixel = &work_pixels[i*stride+j];
					sum_color[0] -= add_pixel[0];
				}
				
				for(j=start_j; j<end_j; j++)
				{
					add_pixel = &work_pixels[(end_i)*stride+j];
					sum_color[0] += add_pixel[0];
				}
				before_y_color[0] = sum_color[0];
			}

			for(counter_y=0; counter_y<clear_height; counter_y++)
			{
				for(counter_x=0; counter_x<clear_width; counter_x++)
				{
					temp_pixel = &window->temp_layer->pixels[counter_y*temp_stride+counter_x*2];
					t = temp_pixel[1];
					add_pixel = &work_pixels[stride*(counter_y+clear_y)+(counter_x+clear_x)];

					add_pixel[0] = ((0xff- t + 1) * add_pixel[0] + t * temp_pixel[0]) >> 8;
				}
			}

skip_draw:
			dx -= step;
			if(dx < 1)
			{
				break;
			}
			else if(dx >= step)
			{
				draw_x += cos_x, draw_y += sin_y;
			}
			else
			{
				draw_x = x, draw_y = y;
			}
		} while(1);

		blur->before_x = x, blur->before_y = y;
	}
}

#define BlurToolReleaseCallBack DefaultReleaseCallBack
#define BlurToolEditSelectionReleaseCallBack DefaultEditSelectionReleaseCallBack

static void BlurToolDrawCursor(
	DRAW_WINDOW* window,
	FLOAT_T x,
	FLOAT_T y,
	void* data
)
{
	BLUR_TOOL* blur = (BLUR_TOOL*)data;
	FLOAT_T r = blur->r * window->zoom_rate;
	cairo_set_line_width(window->disp_temp->cairo_p, 1.0);
	cairo_set_source_rgb(window->disp_temp->cairo_p, 1, 1, 1);
	cairo_arc(window->disp_temp->cairo_p, x, y, r, 0, 2*G_PI);
	cairo_stroke(window->disp_temp->cairo_p);

	cairo_rectangle(window->disp_layer->cairo_p, x - r, y - r,
		(r + BRUSH_UPDATE_MARGIN) * 2, (r + BRUSH_UPDATE_MARGIN) * 2);
	cairo_clip(window->disp_layer->cairo_p);
}

static void BlurToolButtonUpdate(DRAW_WINDOW* window, FLOAT_T x, FLOAT_T y, BLUR_TOOL* blur)
{
	FLOAT_T r = blur->r * window->zoom_rate + 3;
	gtk_widget_queue_draw_area(window->window, (gint)(x - r - 1),
		(gint)(y - r - 1), (gint)(r * 2 + 3), (gint)(r * 2 + 3));
}

static void BlurToolMotionUpdate(DRAW_WINDOW* window, FLOAT_T x, FLOAT_T y, BLUR_TOOL* blur)
{
	FLOAT_T start_x, start_y;
	FLOAT_T width, height;
	FLOAT_T r = blur->r * window->zoom_rate * 1.275 + BRUSH_UPDATE_MARGIN;

	if(window->before_cursor_x < x)
	{
		start_x = window->before_cursor_x - r;
		width = r * 2 + x - window->before_cursor_x;
	}
	else
	{
		start_x = x - r;
		width = r * 2 + window->before_cursor_x - x;
	}

	if(window->before_cursor_y < y)
	{
		start_y = window->before_cursor_y - r;
		height = r * 2 + y - window->before_cursor_y;
	}
	else
	{
		start_y = y - r;
		height = r * 2 + window->before_cursor_y - y;
	}

	gtk_widget_queue_draw_area(window->window,
		(gint)start_x, (gint)start_y, (gint)width + 2, (gint)height + 2);
}

static void BlurToolScaleChange(
	GtkAdjustment* slider,
	gpointer data
)
{
	BLUR_TOOL* blur = (BLUR_TOOL*)data;
	blur->r = gtk_adjustment_get_value(slider) * 0.5;
	BrushCoreSetGrayCirclePattern(blur->core, blur->r, blur->outline_hardness*0.01,
		blur->blur*0.01, blur->alpha*0.01);
}

static void BlurToolFlowChange(
	GtkAdjustment* slider,
	gpointer data
)
{
	BLUR_TOOL* blur = (BLUR_TOOL*)data;
	blur->alpha = gtk_adjustment_get_value(slider);
	BrushCoreSetGrayCirclePattern(blur->core, blur->r, blur->outline_hardness*0.01,
		blur->blur*0.01, blur->alpha*0.01);
}

static void BlurToolPressureSizeChange(
	GtkWidget* widget,
	gpointer data
)
{
	BLUR_TOOL* blur = (BLUR_TOOL*)data;
	if(gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(widget)) == FALSE)
	{
		blur->flags &= ~(BRUSH_FLAG_SIZE);
	}
	else
	{
		blur->flags |= BRUSH_FLAG_SIZE;
	}
}

static void BlurToolOutlineHardnessChange(
	GtkAdjustment* slider,
	BLUR_TOOL* blur
)
{
	blur->outline_hardness =
		gtk_adjustment_get_value(slider);
	BrushCoreSetGrayCirclePattern(blur->core, blur->r, blur->outline_hardness*0.01,
		blur->blur*0.01, blur->alpha*0.01);
}

static void BlurToolBlurChange(
	GtkAdjustment* slider,
	BLUR_TOOL* blur
)
{
	blur->blur =
		gtk_adjustment_get_value(slider);
	BrushCoreSetGrayCirclePattern(blur->core, blur->r, blur->outline_hardness*0.01,
		blur->blur*0.01, blur->alpha*0.01);
}

static void BlurToolColorExtendsChange(
	GtkAdjustment* slider,
	BLUR_TOOL* blur
)
{
	blur->color_extend =
		gtk_adjustment_get_value(slider);
}

static void BlurToolPressureFlowChange(
	GtkWidget* widget,
	gpointer data
)
{
	BLUR_TOOL* blur = (BLUR_TOOL*)data;
	if(gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(widget)) == FALSE)
	{
		blur->flags &= ~(BRUSH_FLAG_FLOW);
	}
	else
	{
		blur->flags |= BRUSH_FLAG_FLOW;
	}
}

static GtkWidget* CreateBlurToolDetailUI(APPLICATION* app, BRUSH_CORE* core)
{
#define UI_FONT_SIZE 8.0
	BLUR_TOOL* blur = (BLUR_TOOL*)core->brush_data;
	GtkWidget* vbox = gtk_vbox_new(FALSE, 2);
	GtkWidget* hbox;
	GtkWidget* base_scale;
	GtkWidget* brush_scale;
	GtkWidget* table = gtk_table_new(5, 3, TRUE);
	GtkWidget* check_button;
	GtkWidget* label;
	GtkAdjustment* brush_scale_adjustment;
	char mark_up_buff[256];

	blur->core = core;

	{
		const char *mag_str[] = {"x 0.1", "x 1", "x 10"};
		hbox = gtk_hbox_new(FALSE, 0);
		label = gtk_label_new("");
		(void)sprintf(mark_up_buff, "<span font_desc=\"%.2f\">%s : </span>",
			UI_FONT_SIZE * app->gui_scale, app->labels->tool_box.base_scale);
		gtk_label_set_markup(GTK_LABEL(label), mark_up_buff);
		gtk_box_pack_start(GTK_BOX(hbox), label, FALSE, FALSE, 0);
#if GTK_MAJOR_VERSION <= 2
		base_scale = gtk_combo_box_new_text();
		gtk_combo_box_append_text(GTK_COMBO_BOX(base_scale), mag_str[0]);
		gtk_combo_box_append_text(GTK_COMBO_BOX(base_scale), mag_str[1]);
		gtk_combo_box_append_text(GTK_COMBO_BOX(base_scale), mag_str[2]);
#else
		base_scale = gtk_combo_box_text_new();
		gtk_combo_box_text_append_text(GTK_COMBO_BOX_TEXT(base_scale), mag_str[0]);
		gtk_combo_box_text_append_text(GTK_COMBO_BOX_TEXT(base_scale), mag_str[1]);
		gtk_combo_box_text_append_text(GTK_COMBO_BOX_TEXT(base_scale), mag_str[2]);
#endif
		gtk_combo_box_set_active(GTK_COMBO_BOX(base_scale), blur->base_scale);
		gtk_box_pack_start(GTK_BOX(hbox), base_scale, TRUE, TRUE, 0);
		gtk_box_pack_start(GTK_BOX(vbox), hbox, FALSE, FALSE, 0);
	}

	switch(blur->base_scale)
	{
	case 0:
		brush_scale_adjustment =
			GTK_ADJUSTMENT(gtk_adjustment_new(blur->r * 2, 0.1, 10.0, 0.1, 0.1, 0.0));
		break;
	case 1:
		brush_scale_adjustment = GTK_ADJUSTMENT(gtk_adjustment_new(
			blur->r * 2, 1.0, 100.0, 1.0, 1.0, 0.0));
		break;
	default:
		brush_scale_adjustment =
			GTK_ADJUSTMENT(gtk_adjustment_new(blur->r * 2, 5.0, 500.0, 1.0, 1.0, 0.0));
	}

	brush_scale = SpinScaleNew(brush_scale_adjustment,
		app->labels->tool_box.brush_scale, 1);
	(void)g_signal_connect(G_OBJECT(brush_scale_adjustment), "value_changed",
		G_CALLBACK(BlurToolScaleChange), core->brush_data);
	gtk_table_attach_defaults(GTK_TABLE(table), brush_scale, 0, 3, 0, 1);

	g_object_set_data(G_OBJECT(base_scale), "scale", brush_scale);
	(void)g_signal_connect(G_OBJECT(base_scale), "changed", G_CALLBACK(SetBrushBaseScale), &blur->base_scale);

	brush_scale_adjustment =
		GTK_ADJUSTMENT(gtk_adjustment_new(blur->alpha, 0.0, 100.0, 1.0, 1.0, 0.0));
	brush_scale = SpinScaleNew(brush_scale_adjustment,
		app->labels->tool_box.flow, 1);
	(void)g_signal_connect(G_OBJECT(brush_scale_adjustment), "value_changed",
		G_CALLBACK(BlurToolFlowChange), core->brush_data);
	gtk_table_attach_defaults(GTK_TABLE(table), brush_scale, 0, 3, 1, 2);

	brush_scale_adjustment = GTK_ADJUSTMENT(gtk_adjustment_new(blur->outline_hardness,
		0, 100, 1, 1, 0));
	(void)g_signal_connect(G_OBJECT(brush_scale_adjustment), "value_changed",
		G_CALLBACK(BlurToolOutlineHardnessChange), core->brush_data);
	brush_scale = SpinScaleNew(brush_scale_adjustment,
		app->labels->tool_box.outline_hardness, 1);
	gtk_table_attach_defaults(GTK_TABLE(table), brush_scale, 0, 3, 2, 3);

	brush_scale_adjustment = GTK_ADJUSTMENT(gtk_adjustment_new(blur->blur,
		0, 100, 1, 1, 0));
	(void)g_signal_connect(G_OBJECT(brush_scale_adjustment), "value_changed",
		G_CALLBACK(BlurToolBlurChange), core->brush_data);
	brush_scale = SpinScaleNew(brush_scale_adjustment,
		app->labels->tool_box.blur, 1);
	gtk_table_attach_defaults(GTK_TABLE(table), brush_scale, 0, 3, 3, 4);

	brush_scale_adjustment = GTK_ADJUSTMENT(gtk_adjustment_new(blur->color_extend,
		0, 100, 1, 1, 0));
	(void)g_signal_connect(G_OBJECT(brush_scale_adjustment), "value_changed",
		G_CALLBACK(BlurToolColorExtendsChange), core->brush_data);
	brush_scale = SpinScaleNew(brush_scale_adjustment,
		app->labels->tool_box.color_extend, 1);
	gtk_table_attach_defaults(GTK_TABLE(table), brush_scale, 0, 3, 4, 5);
	gtk_box_pack_start(GTK_BOX(vbox), table, FALSE, TRUE, 0);

	table = gtk_hbox_new(FALSE, 0);
	label = gtk_label_new("");
	(void)sprintf(mark_up_buff, "<span font_desc=\"%.2f\">%s : </span>",
		UI_FONT_SIZE * app->gui_scale, app->labels->tool_box.pressure);
	gtk_label_set_markup(GTK_LABEL(label), mark_up_buff);
	gtk_box_pack_start(GTK_BOX(table), label, FALSE, TRUE, 0);
	check_button = gtk_check_button_new_with_label(app->labels->tool_box.scale);
	(void)g_signal_connect(G_OBJECT(check_button), "toggled", G_CALLBACK(BlurToolPressureSizeChange), core->brush_data);
	gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(check_button), blur->flags & BRUSH_FLAG_SIZE);
	gtk_box_pack_start(GTK_BOX(table), check_button, FALSE, TRUE, 0);
	check_button = gtk_check_button_new_with_label(app->labels->tool_box.flow);
	(void)g_signal_connect(G_OBJECT(check_button), "toggled", G_CALLBACK(BlurToolPressureFlowChange), core->brush_data);
	gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(check_button), blur->flags & BRUSH_FLAG_FLOW);
	gtk_box_pack_start(GTK_BOX(table), check_button, FALSE, TRUE, 0);
	gtk_box_pack_start(GTK_BOX(vbox), table, FALSE, TRUE, 0);

	return vbox;
}

static void SmudgePressCallBack(
	DRAW_WINDOW* window,
	FLOAT_T x,
	FLOAT_T y,
	FLOAT_T pressure,
	BRUSH_CORE *core,
	void* state
)
{
	if(((GdkEventButton*)state)->button == 1)
	{
		SMUDGE* smudge = (SMUDGE*)core->brush_data;
		int start_x, start_y, width, height;
		int counter_y;

		smudge->before_x = x;
		smudge->before_y = y;

		core->max_x = x + smudge->before_r + 1;
		core->max_y = y + smudge->before_r + 1;
		core->min_x = x - smudge->before_r - 1;
		core->min_y = y - smudge->before_r - 1;

		if(core->max_x >= window->width)
		{
			core->max_x = window->width;
		}
		if(core->max_y >= window->height)
		{
			core->max_y = window->height;
		}
		if(core->min_x < 0)
		{
			core->min_x = 0;
		}
		if(core->min_y < 0)
		{
			core->min_y = 0;
		}

		window->update.x = (int)core->min_x, window->update.y = (int)core->min_y;
		window->update.width = (int)core->max_x - window->update.x;
		window->update.height = (int)core->max_y - window->update.y;

		window->flags |= DRAW_WINDOW_UPDATE_PART;

		start_x = (int)core->min_x;
		start_y = (int)core->min_y;
		width = (int)(core->max_x - core->min_x);
		height = (int)(core->max_y -core->min_y);

		if(width <= 0 || height <= 0)
		{
			smudge->flags &= ~(SMUDGE_DRAW_STARTED);
			return;
		}

		smudge->before_r = (width < height) ? width : height;

		(void)memcpy(window->work_layer->pixels, window->active_layer->pixels, window->pixel_buf_size);
		window->work_layer->layer_mode = LAYER_BLEND_SOURCE;

		for(counter_y=0; counter_y<height; counter_y++)
		{
			(void)memcpy(&window->brush_buffer[counter_y*width*4],
				&window->work_layer->pixels[(start_y+counter_y)*window->work_layer->stride+start_x*4], width*4
			);
		}

		smudge->flags |= SMUDGE_INITIALIZED;
	}
}

static void SmudgeEditSelectionPressCallBack(
	DRAW_WINDOW* window,
	FLOAT_T x,
	FLOAT_T y,
	FLOAT_T pressure,
	BRUSH_CORE *core,
	void* state
)
{
	if(((GdkEventButton*)state)->button == 1)
	{
		SMUDGE* smudge = (SMUDGE*)core->brush_data;
		int start_x, start_y, width, height;
		int counter_y;

		smudge->before_x = x;
		smudge->before_y = y;

		core->max_x = x + smudge->before_r + 1;
		core->max_y = y + smudge->before_r + 1;
		core->min_x = x - smudge->before_r - 1;
		core->min_y = y - smudge->before_r - 1;

		if(core->max_x >= window->width)
		{
			core->max_x = window->width;
		}
		if(core->max_y >= window->height)
		{
			core->max_y = window->height;
		}
		if(core->min_x < 0)
		{
			core->min_x = 0;
		}
		if(core->min_y < 0)
		{
			core->min_y = 0;
		}

		start_x = (int)core->min_x;
		start_y = (int)core->min_y;
		width = (int)(core->max_x - core->min_x);
		height = (int)(core->max_y -core->min_y);

		smudge->before_r = height;

		if(width <= 0 || height <= 0)
		{
			smudge->flags &= ~(SMUDGE_DRAW_STARTED);
			return;
		}

		smudge->flags |= SMUDGE_DRAW_STARTED;

		smudge->before_r = (width < height) ? width : height;

		(void)memcpy(window->work_layer->pixels, window->selection->pixels, window->width * window->height);
		window->selection->layer_mode = SELECTION_BLEND_COPY;

		for(counter_y=0; counter_y<height; counter_y++)
		{
			(void)memcpy(&window->brush_buffer[counter_y*width*4],
				&window->work_layer->pixels[(start_y+counter_y)*window->work_layer->width*4+start_x*4], width*4
			);
		}

		smudge->flags |= SMUDGE_INITIALIZED;
	}
}

static void SmudgeMotionCallBack(
	DRAW_WINDOW* window,
	FLOAT_T x,
	FLOAT_T y,
	FLOAT_T pressure,
	BRUSH_CORE *core,
	void* state
)
{
	SMUDGE* smudge = (SMUDGE*)core->brush_data;

	if(((*(GdkModifierType*)state) & GDK_BUTTON1_MASK) != 0)
	{
		cairo_t *update;
		cairo_surface_t *update_surface;
		cairo_matrix_t matrix;
		FLOAT_T r, alpha, d;
		FLOAT_T min_x, min_y, max_x, max_y;
		FLOAT_T draw_x, draw_y;
		FLOAT_T dx, dy, cos_x, sin_y;
		FLOAT_T zoom;
		FLOAT_T hardness = smudge->outline_hardness * 0.01f;
		int before_size = (int)smudge->before_r;
		int32 clear_x, clear_width, clear_y, clear_height;
		int i;
		// 作業レイヤーの幅
		int layer_width = window->work_layer->width;
		// 作業レイヤーの一行分のバイト数
		int layer_stride = window->work_layer->stride;
		// 作業レイヤーのピクセル
		uint8 *work_pixel = window->work_layer->pixels;
		uint8 *brush_buffer = window->brush_buffer;
		uint8 alpha_c, extention = (uint8)(smudge->extention*0.01*255);
		uint8 *mask;

		r = smudge->r;

		if((smudge->flags & SMUDGE_PRESSURE_SIZE) != 0)
		{
			r *= pressure;
			zoom = 1 / pressure;
		}
		else
		{
			zoom = 1;
		}

		alpha = ((smudge->flags & SMUDGE_PRESSURE_EXTENTION) == 0) ?
			1 : 0.01f * pressure;
		alpha_c = (uint8)(alpha * 255);
		dx = x-smudge->before_x, dy = y-smudge->before_y;
		d = dx*dx+dy*dy;
		d = sqrt(d);

		if((smudge->flags & SMUDGE_DRAW_STARTED) == 0)
		{
			smudge->before_r = ((smudge->flags & SMUDGE_PRESSURE_SIZE) != 0)
				? smudge->r * pressure : smudge->r;

			if(d >= r * 0.25)
			{
				smudge->before_x = draw_x = x;
				smudge->before_y = draw_y = y;
				smudge->flags |= SMUDGE_DRAW_STARTED;

				clear_x = (int32)(draw_x - r - 1);
				clear_width = (int32)(draw_x + r + 1);
				clear_y = (int32)(draw_y - r - 1);
				clear_height = (int32)(draw_y + r + 1);

				if(clear_x < 0)
				{
					clear_x = 0;
				}
				else if(clear_width > window->width)
				{
					clear_width = window->width;
				}
				else if(clear_width < 0)
				{
					clear_width = 0;
				}
				if(clear_y < 0)
				{
					clear_y = 0;
				}
				if(clear_height >= window->height)
				{
					clear_height = window->height;
				}
				clear_width = clear_width - clear_x;
				clear_height = clear_height - clear_y;

				for(i=0; i<clear_height; i++)
				{
					(void)memcpy(&window->brush_buffer[i*before_size*4],
						&window->work_layer->pixels[(i+clear_y)*window->work_layer->stride+clear_x*4], before_size*4);
				}
			}
			
			smudge->before_r *= 2;

			return;
		}

		if(fabs(dx) < 2 && fabs(dy) < 2)
		{
			return;
		}
		cos_x = dx / d, sin_y = dy / d;
		draw_x = smudge->before_x + cos_x, draw_y = smudge->before_y + sin_y;

		min_x = x - r*2, min_y = y - r*2;
		max_x = x + r*2, max_y = y + r*2;

		if(min_x < 0.0)
		{
			min_x = 0.0;
		}
		if(min_y < 0.0)
		{
			min_y = 0.0;
		}
		if(max_x > window->work_layer->width)
		{
			max_x = window->work_layer->width;
		}
		if(max_y > window->work_layer->height)
		{
			max_y = window->work_layer->height;
		}

		if(window->update.x > min_x)
		{
			window->update.width += window->update.x - (int)min_x;
			window->update.x = (int)min_x;
		}
		if(window->update.width + window->update.x < max_x)
		{
			window->update.width += (int)max_x - window->update.width + window->update.x;
		}
		if(window->update.y > min_y)
		{
			window->update.height += window->update.y - (int)min_y;
			window->update.y = (int)min_y;
		}
		if(window->update.height + window->update.y < max_y)
		{
			window->update.height += (int)max_y - window->update.height + window->update.y;
		}

		if(core->min_x > min_x)
		{
			core->min_x = min_x;
		}
		if(core->min_y > min_y)
		{
			core->min_y = min_y;
		}
		if(core->max_x < max_x)
		{
			core->max_x = max_x;
		}
		if(core->max_y < max_y)
		{
			core->max_y = max_y;
		}

		if((smudge->flags & SMUDGE_INITIALIZED) != 0)
		{
			dx = d;
			do
			{
				if(fabs(draw_x - smudge->before_x) >= 1 || fabs(draw_y - smudge->before_y) >= 1)
				{
					smudge->before_x = draw_x, smudge->before_y = draw_y;
					clear_x = (int32)(draw_x - r - 1);
					clear_width = (int32)(draw_x + r + 1);
					clear_y = (int32)(draw_y - r - 1);
					clear_height = (int32)(draw_y + r + 1);

					if(clear_x < 0)
					{
						clear_x = 0;
					}
					else if(clear_x >= window->width)
					{
						goto skip_draw;
					}
					if(clear_y < 0)
					{
						clear_y = 0;
					}
					if(clear_height >= window->height)
					{
						goto skip_draw;
						//clear_height = window->height;
					}
					clear_width = clear_width - clear_x;
					clear_height = clear_height - clear_y;

					if(clear_width <= 0 || clear_height <= 0)
					{
						goto skip_draw;
					}

					for(i=0; i<clear_height; i++)
					{
						(void)memset(&window->temp_layer->pixels[(i+clear_y)*window->work_layer->stride+clear_x*4],
							0x0, clear_width*4);
					}

					update_surface = cairo_surface_create_for_rectangle(
						window->alpha_surface, draw_x - r, draw_y - r, r*2+1, r*2+1);
					update = cairo_create(update_surface);

					mask = window->mask->pixels;
					cairo_set_operator(window->alpha_cairo, CAIRO_OPERATOR_OVER);
					if(window->app->textures.active_texture == 0)
					{
						if((window->flags & DRAW_WINDOW_HAS_SELECTION_AREA) == 0)
						{
							if((window->active_layer->flags & LAYER_LOCK_OPACITY) == 0)
							{
								cairo_matrix_init_scale(&matrix, zoom, zoom);
								cairo_pattern_set_matrix(core->brush_pattern, &matrix);
								cairo_set_source(update, core->brush_pattern);
								cairo_paint_with_alpha(update, alpha);
							}
							else
							{
								cairo_matrix_init_scale(&matrix, zoom, zoom);
								cairo_pattern_set_matrix(core->brush_pattern, &matrix);
								cairo_set_source(core->temp_cairo, core->brush_pattern);
								cairo_paint_with_alpha(core->temp_cairo, alpha);
								cairo_matrix_init_translate(&matrix, 0, 0);
								cairo_pattern_set_matrix(core->temp_pattern, &matrix);
								cairo_set_source(update, core->temp_pattern);
								cairo_mask_surface(update,
									window->active_layer->surface_p, - draw_x + r, - draw_y + r);
							}
						}
						else
						{
							if((window->active_layer->flags & LAYER_LOCK_OPACITY) == 0)
							{
								cairo_matrix_init_scale(&matrix, zoom, zoom);
								cairo_pattern_set_matrix(core->brush_pattern, &matrix);
								cairo_set_source(core->temp_cairo, core->brush_pattern);
								cairo_paint_with_alpha(core->temp_cairo, alpha);
								cairo_matrix_init_translate(&matrix, 0, 0);
								cairo_pattern_set_matrix(core->temp_pattern, &matrix);
								cairo_set_source(update, core->temp_pattern);
								cairo_mask_surface(update,
									window->selection->surface_p, - draw_x + r, - draw_y + r);
							}
							else
							{
								cairo_surface_t *temp_surface = cairo_surface_create_for_rectangle(
									window->alpha_temp, draw_x - r, draw_y - r, r*2+1, r*2+1);
								cairo_t *update_temp = cairo_create(temp_surface);

								cairo_matrix_init_scale(&matrix, zoom, zoom);
								cairo_pattern_set_matrix(core->brush_pattern, &matrix);
								cairo_set_source(core->temp_cairo, core->brush_pattern);
								cairo_paint_with_alpha(core->temp_cairo, alpha);
								cairo_matrix_init_translate(&matrix, 0, 0);
								cairo_pattern_set_matrix(core->temp_pattern, &matrix);
								cairo_set_source(update, core->temp_pattern);

								(void)memset(window->temp_layer->pixels, 0,
									window->width*window->height);

								cairo_mask_surface(update,
									window->selection->surface_p, 0, 0);
								cairo_set_source_surface(update_temp,
									update_surface, 0, 0);
								cairo_mask_surface(update_temp,
									window->active_layer->surface_p, - draw_x + r, - draw_y + r);

								mask = window->temp_layer->pixels;

								cairo_surface_destroy(temp_surface);
								cairo_destroy(update_temp);
							}
						}
					}
					else
					{
						cairo_surface_t *temp_surface = cairo_surface_create_for_rectangle(
							window->alpha_temp, draw_x - r, draw_y - r, r*2+1, r*2+1);
						cairo_t *update_temp = cairo_create(temp_surface);

						if((window->flags & DRAW_WINDOW_HAS_SELECTION_AREA) == 0)
						{
							if((window->active_layer->flags & LAYER_LOCK_OPACITY) == 0)
							{
								cairo_matrix_init_scale(&matrix, zoom, zoom);
								cairo_pattern_set_matrix(core->brush_pattern, &matrix);
								cairo_set_source(update, core->brush_pattern);
								cairo_paint_with_alpha(update, alpha);
							}
							else
							{
								cairo_matrix_init_scale(&matrix, zoom, zoom);
								cairo_pattern_set_matrix(core->brush_pattern, &matrix);
								cairo_set_source(core->temp_cairo, core->brush_pattern);
								cairo_paint_with_alpha(core->temp_cairo, alpha);
								cairo_matrix_init_translate(&matrix, 0, 0);
								cairo_pattern_set_matrix(core->temp_pattern, &matrix);
								cairo_set_source(update, core->temp_pattern);
								cairo_mask_surface(update,
									window->active_layer->surface_p, - draw_x + r, - draw_y + r);
							}

							cairo_set_source_surface(update_temp, update_surface, 0, 0);
							cairo_mask_surface(update_temp, window->texture->surface_p, - draw_x + r, - draw_y + r);

							mask = window->temp_layer->pixels;
						}
						else
						{
							if((window->active_layer->flags & LAYER_LOCK_OPACITY) == 0)
							{
								cairo_matrix_init_scale(&matrix, zoom, zoom);
								cairo_pattern_set_matrix(core->brush_pattern, &matrix);
								cairo_set_source(core->temp_cairo, core->brush_pattern);
								cairo_paint_with_alpha(core->temp_cairo, alpha);
								cairo_matrix_init_translate(&matrix, 0, 0);
								cairo_pattern_set_matrix(core->temp_pattern, &matrix);
								cairo_set_source(update, core->temp_pattern);
								cairo_mask_surface(update,
									window->selection->surface_p, - draw_x + r, - draw_y + r);

								cairo_set_source_surface(update_temp, update_surface, 0, 0);
								cairo_mask_surface(update_temp, window->texture->surface_p, - draw_x + r, - draw_y + r);

								mask = window->temp_layer->pixels;
							}
							else
							{
								cairo_matrix_init_scale(&matrix, zoom, zoom);
								cairo_pattern_set_matrix(core->brush_pattern, &matrix);
								cairo_set_source(core->temp_cairo, core->brush_pattern);
								cairo_paint_with_alpha(core->temp_cairo, alpha);
								cairo_matrix_init_translate(&matrix, 0, 0);
								cairo_pattern_set_matrix(core->temp_pattern, &matrix);
								cairo_set_source(update, core->temp_pattern);

								(void)memset(window->temp_layer->pixels, 0,
									window->width*window->height);

								cairo_mask_surface(update,
									window->selection->surface_p, 0, 0);
								cairo_set_source_surface(update_temp,
									update_surface, 0, 0);
								cairo_mask_surface(update_temp,
									window->active_layer->surface_p, - draw_x + r, - draw_y + r);

								cairo_set_operator(update, CAIRO_OPERATOR_SOURCE);
								cairo_set_source_surface(update, temp_surface, 0, 0);
								cairo_mask_surface(update, window->texture->surface_p, - draw_x + r, - draw_y + r);
							}
						}

						cairo_surface_destroy(temp_surface);
						cairo_destroy(update_temp);
					}

					cairo_surface_destroy(update_surface);
					cairo_destroy(update);

#ifdef _OPENMP
#pragma omp parallel for firstprivate(work_pixel, before_size, layer_stride, mask, brush_buffer, clear_x, clear_y)
#endif
					for(i=0; i<before_size; i++)
					{
						FLOAT_T c;
						int index;
						int j, k;
						uint8 t;
						uint8 before_alpha;
						for(j=0; j<before_size; j++)
						{
							index = (clear_y+i)*layer_stride+(clear_x+j)*4;
							t = mask[layer_width*(clear_y+i)+(clear_x+j)];
							before_alpha = work_pixel[index+3];
							for(k=0; k<4; k++)
							{
								c = ((0xff-extention)*work_pixel[index+k]
									+ extention*brush_buffer[i*before_size*4+j*4+k]) / 255.0 + 0.49;
								work_pixel[index+k] =
									(uint8)(((0xff-t)*work_pixel[index+k]
										+t*c) / 255);
							}
						}
					}

					for(i=0; i<clear_height; i++)
					{
						(void)memcpy(&window->brush_buffer[i*before_size*4],
							&window->work_layer->pixels[(i+clear_y)*window->work_layer->stride+clear_x*4], before_size*4);
					}
				}
skip_draw:
				dx -= 1;
				if(dx < 1)
				{
					break;
				}
				else
				{
					draw_x += cos_x, draw_y += sin_y;
				}
			} while(1);
		}
		else
		{
			draw_x = x, draw_y = y;
		}

		window->flags |= DRAW_WINDOW_UPDATE_PART;

		smudge->before_r = ((smudge->flags & SMUDGE_PRESSURE_SIZE) != 0)
			? smudge->r * pressure : smudge->r;

		clear_x = (int32)(draw_x - smudge->before_r);
		clear_width = (int32)(draw_x + smudge->before_r);
		clear_y = (int32)(draw_y - smudge->before_r);
		clear_height = (int32)(draw_y + smudge->before_r);

		smudge->before_r *= 2;

		if(clear_x < 0)
		{
			clear_x = 0;
		}
		else if(clear_width > window->width)
		{
			clear_width = window->width;
		}
		else if(clear_width < 0)
		{
			clear_width = 0;
		}
		if(clear_y < 0)
		{
			clear_y = 0;
		}
		if(clear_height >= window->height)
		{
			clear_height = window->height;
		}
		clear_width = clear_width - clear_x;
		clear_height = clear_height - clear_y;

		if((smudge->flags & SMUDGE_INITIALIZED) == 0
			&& clear_width > 0 && clear_height > 0)
		{
			for(i=0; i<clear_height; i++)
			{
				(void)memcpy(&window->brush_buffer[i*before_size*4],
					&window->work_layer->pixels[(i+clear_y)*window->work_layer->width+clear_x*4], before_size*4);
			}

			smudge->flags |= SMUDGE_INITIALIZED;
		}
	}
}

static void SmudgeEditSelectionMotionCallBack(
	DRAW_WINDOW* window,
	FLOAT_T x,
	FLOAT_T y,
	FLOAT_T pressure,
	BRUSH_CORE *core,
	void* state
)
{
	SMUDGE* smudge = (SMUDGE*)core->brush_data;

	if(((*(GdkModifierType*)state) & GDK_BUTTON1_MASK) != 0)
	{
		cairo_pattern_t* brush;
		FLOAT_T r, alpha, d;
		FLOAT_T min_x, min_y, max_x, max_y;
		FLOAT_T draw_x, draw_y;
		FLOAT_T dx, dy, cos_x, sin_y;
		FLOAT_T hardness = smudge->outline_hardness * 0.01f;
		int before_size = (int)smudge->before_r;
		int32 clear_x, clear_width, clear_y, clear_height;
		int i, j, t, c, index;
		uint8 alpha_c, extention = (uint8)(smudge->extention*0.01*255);

		r = smudge->r;

		alpha = ((smudge->flags & SMUDGE_PRESSURE_EXTENTION) == 0) ?
			1 : 0.01f * pressure;
		alpha_c = (uint8)(alpha * 255);
		dx = x-smudge->before_x, dy = y-smudge->before_y;
		d = dx*dx+dy*dy;
		if(fabs(dx) < 2 && fabs(dy) < 2)
		{
			return;
		}
		d = sqrt(d);
		// arg = atan2(dy, dx);
		cos_x = dx / d, sin_y = dy / d;
		draw_x = smudge->before_x + cos_x, draw_y = smudge->before_y + sin_y;
		//cos_x = cos(arg), sin_y = sin(arg);

		min_x = x - r*2, min_y = y - r*2;
		max_x = x + r*2, max_y = y + r*2;

		if(min_x < 0.0)
		{
			min_x = 0.0;
		}
		if(min_y < 0.0)
		{
			min_y = 0.0;
		}
		if(max_x > window->work_layer->width)
		{
			max_x = window->work_layer->width;
		}
		if(max_y > window->work_layer->height)
		{
			max_y = window->work_layer->height;
		}

		if(core->min_x > min_x)
		{
			core->min_x = min_x;
		}
		if(core->min_y > min_y)
		{
			core->min_y = min_y;
		}
		if(core->max_x < max_x)
		{
			core->max_x = max_x;
		}
		if(core->max_y < max_y)
		{
			core->max_y = max_y;
		}

		if((smudge->flags & SMUDGE_INITIALIZED) != 0)
		{
			dx = d;
			do
			{
				if(fabs(draw_x - smudge->before_x) >= 1 || fabs(draw_y - smudge->before_y) >= 1)
				{
					smudge->before_x = draw_x, smudge->before_y = draw_y;
					clear_x = (int32)(draw_x - r - 1);
					clear_width = (int32)(draw_x + r + 1);
					clear_y = (int32)(draw_y - r - 1);
					clear_height = (int32)(draw_y + r + 1);

					if(clear_x < 0)
					{
						clear_x = 0;
					}
					else if(clear_x >= window->width)
					{
						goto skip_draw;
					}
					if(clear_y < 0)
					{
						clear_y = 0;
					}
					if(clear_height >= window->height)
					{
						goto skip_draw;
						//clear_height = window->height;
					}
					clear_width = clear_width - clear_x;
					clear_height = clear_height - clear_y;

					if(clear_width <= 0 || clear_height <= 0)
					{
						goto skip_draw;
					}

					for(i=0; i<clear_height; i++)
					{
						(void)memset(&window->temp_layer->pixels[(i+clear_y)*window->work_layer->stride+clear_x*window->work_layer->channel],
							0x0, clear_width*window->work_layer->channel);
					}
					brush = cairo_pattern_create_radial(draw_x, draw_y, r * 0.0, draw_x, draw_y, r);
					cairo_pattern_set_extend(brush, CAIRO_EXTEND_NONE);
					cairo_pattern_add_color_stop_rgba(brush, 0.0, 0, 0, 0, alpha);
					cairo_pattern_add_color_stop_rgba(brush, 1-smudge->opacity*0.01f, 0, 0, 0, alpha);
					cairo_pattern_add_color_stop_rgba(brush, 1.0, 0, 0, 0, alpha*hardness);
					cairo_set_source(window->temp_layer->cairo_p, brush);

					cairo_arc(window->temp_layer->cairo_p, draw_x, draw_y, r, 0, 2*G_PI);
					cairo_fill(window->temp_layer->cairo_p);

					for(i=0; i<before_size; i++)
					{
						for(j=0; j<before_size; j++)
						{
							uint8 before_alpha;
							index = (clear_y+i)*window->temp_layer->stride+(clear_x+j)*4;
							t = window->temp_layer->pixels[index+3];
							before_alpha = window->work_layer->pixels[(clear_y+i)*window->width+clear_x+j];

							c = ((0xff-extention+1)*window->work_layer->pixels[(clear_y+i)*window->width+clear_x+j]
								+ extention*window->brush_buffer[i*before_size+j]) >> 8;
							window->work_layer->pixels[(clear_y+i)*window->width+clear_x+j] =
								((0xff-t+1)*window->work_layer->pixels[(clear_y+i)*window->width+clear_x+j]
									+t*c) >> 8;
						}
					}

					for(i=0; i<clear_height; i++)
					{
						(void)memcpy(&window->brush_buffer[i*before_size],
							&window->work_layer->pixels[(i+clear_y)*window->work_layer->width+clear_x], before_size);
					}
				}
skip_draw:
				dx -= 1;
				if(dx < 1)
				{
					break;
				}
				else
				{
					draw_x += cos_x, draw_y += sin_y;
				}
			} while(1);
		}
		else
		{
			draw_x = x, draw_y = y;
		}

		//smudge->before_x = draw_x, smudge->before_y = draw_y;
		smudge->before_r = ((smudge->flags & SMUDGE_PRESSURE_SIZE) != 0)
			? smudge->r * pressure : smudge->r;

		clear_x = (int32)(draw_x - smudge->before_r);
		clear_width = (int32)(draw_x + smudge->before_r);
		clear_y = (int32)(draw_y - smudge->before_r);
		clear_height = (int32)(draw_y + smudge->before_r);

		smudge->before_r *= 2;

		if(clear_x < 0)
		{
			clear_x = 0;
		}
		else if(clear_width > window->width)
		{
			clear_width = window->width;
		}
		else if(clear_width < 0)
		{
			clear_width = 0;
		}
		if(clear_y < 0)
		{
			clear_y = 0;
		}
		if(clear_height >= window->height)
		{
			clear_height = window->height;
		}
		clear_width = clear_width - clear_x;
		clear_height = clear_height - clear_y;

		if((smudge->flags & SMUDGE_INITIALIZED) == 0
			&& clear_width > 0 && clear_height > 0)
		{
			for(i=0; i<clear_height; i++)
			{
				(void)memcpy(&window->brush_buffer[i*before_size],
					&window->work_layer->pixels[(i+clear_y)*window->work_layer->width+clear_x], before_size);
			}

			smudge->flags |= SMUDGE_INITIALIZED;
		}
	}
}

static void SmudgeReleaseCallBack(
	DRAW_WINDOW* window,
	FLOAT_T x,
	FLOAT_T y,
	FLOAT_T pressure,
	BRUSH_CORE *core,
	void* state
)
{
	if(((GdkEventButton*)state)->button == 1)
	{
		SMUDGE* smudge = (SMUDGE*)core->brush_data;

		AddBrushHistory(core, window->active_layer);

		window->update.surface_p = cairo_surface_create_for_rectangle(
			window->active_layer->surface_p, window->update.x, window->update.y,
				window->update.width, window->update.height);
		window->update.cairo_p = cairo_create(window->update.surface_p);
		window->part_layer_blend_functions[window->work_layer->layer_mode](window->work_layer, &window->update);
		cairo_destroy(window->update.cairo_p);
		cairo_surface_destroy(window->update.surface_p);

		(void)memset(window->work_layer->pixels, 0, window->work_layer->stride*window->work_layer->height);

		window->work_layer->layer_mode = LAYER_BLEND_NORMAL;
		window->flags |= DRAW_WINDOW_UPDATE_PART;

		smudge->flags &= ~(SMUDGE_INITIALIZED);
	}
}

static void SmudgeEditSelectionReleaseCallBack(
	DRAW_WINDOW* window,
	FLOAT_T x,
	FLOAT_T y,
	FLOAT_T pressure,
	BRUSH_CORE *core,
	void* state
)
{
	if(((GdkEventButton*)state)->button == 1)
	{
		SMUDGE* smudge = (SMUDGE*)core->brush_data;

		AddSelectionEditHistory(core, window->selection);

		g_blend_selection_funcs[window->selection->layer_mode](window->work_layer, window->selection);

		(void)memset(window->work_layer->pixels, 0, window->work_layer->stride*window->work_layer->height);

		window->selection->layer_mode = SELECTION_BLEND_NORMAL;

		smudge->flags &= ~(SMUDGE_INITIALIZED);
	}
}

static void SmudgeDrawCursor(
	DRAW_WINDOW* window,
	FLOAT_T x,
	FLOAT_T y,
	void* data
)
{
	SMUDGE* smudge = (SMUDGE*)data;
	FLOAT_T r = smudge->r * window->zoom_rate;
	cairo_set_line_width(window->disp_temp->cairo_p, 1.0);
	cairo_set_source_rgb(window->disp_temp->cairo_p, 1, 1, 1);
	cairo_arc(window->disp_temp->cairo_p, x, y, r, 0, 2*G_PI);
	cairo_stroke(window->disp_temp->cairo_p);

	cairo_rectangle(window->disp_layer->cairo_p, x - r, y - r,
		(r + BRUSH_UPDATE_MARGIN) * 2, (r + BRUSH_UPDATE_MARGIN) * 2);
	cairo_clip(window->disp_layer->cairo_p);
}

static void SmudgeButtonUpdate(DRAW_WINDOW* window, FLOAT_T x, FLOAT_T y, SMUDGE* smudge)
{
	FLOAT_T r = smudge->r * window->zoom_rate + 3;
	gtk_widget_queue_draw_area(window->window, (gint)(x - r - 1),
		(gint)(y - r - 1), (gint)(r * 2 + 3), (gint)(r * 2 + 3));
}

static void SmudgeMotionUpdate(DRAW_WINDOW* window, FLOAT_T x, FLOAT_T y, SMUDGE* smudge)
{
	FLOAT_T start_x, start_y;
	FLOAT_T width, height;
	FLOAT_T r = smudge->r * window->zoom_rate * 1.275 + BRUSH_UPDATE_MARGIN;

	if(window->before_cursor_x < x)
	{
		start_x = window->before_cursor_x - r;
		width = (r + BRUSH_UPDATE_MARGIN) * 2 + x - window->before_cursor_x;
	}
	else
	{
		start_x = x - r;
		width = (r + BRUSH_UPDATE_MARGIN) * 2 + window->before_cursor_x - x;
	}

	if(window->before_cursor_y < y)
	{
		start_y = window->before_cursor_y - r;
		height = (r + BRUSH_UPDATE_MARGIN) * 2 + y - window->before_cursor_y;
	}
	else
	{
		start_y = y - r;
		height = (r + BRUSH_UPDATE_MARGIN) * 2 + window->before_cursor_y - y;
	}

	gtk_widget_queue_draw_area(window->window,
		(gint)start_x, (gint)start_y, (gint)width, (gint)height);
}

static void SmudgeScaleChange(
	GtkAdjustment* slider,
	gpointer data
)
{
	SMUDGE* smudge = (SMUDGE*)data;
	smudge->r = gtk_adjustment_get_value(slider) * 0.5;
	BrushCoreSetGrayCirclePattern(smudge->core, smudge->r, smudge->outline_hardness * 0.01,
		smudge->blur * 0.01, smudge->opacity * 0.01);
}

static void SmudgeOpacityChange(
	GtkAdjustment* slider,
	gpointer data
)
{
	SMUDGE* smudge = (SMUDGE*)data;
	smudge->opacity = gtk_adjustment_get_value(slider);
	BrushCoreSetGrayCirclePattern(smudge->core, smudge->r, smudge->outline_hardness * 0.01,
		smudge->blur * 0.01, smudge->opacity * 0.01);
}

static void SmudgeBlurChange(
	GtkAdjustment* slider,
	gpointer data
)
{
	SMUDGE* smudge = (SMUDGE*)data;
	smudge->blur = gtk_adjustment_get_value(slider);
	BrushCoreSetGrayCirclePattern(smudge->core, smudge->r, smudge->outline_hardness * 0.01,
		smudge->blur * 0.01, smudge->opacity * 0.01);
}

static void SmudgePressureSizeChange(
	GtkWidget* widget,
	gpointer data
)
{
	SMUDGE* smudge = (SMUDGE*)data;
	if(gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(widget)) == FALSE)
	{
		smudge->flags &= ~(SMUDGE_PRESSURE_SIZE);
	}
	else
	{
		smudge->flags |= SMUDGE_PRESSURE_SIZE;
	}
}

static void SmudgeOutlineHardnessChange(
	GtkAdjustment* slider,
	SMUDGE* smudge
)
{
	smudge->outline_hardness =
		gtk_adjustment_get_value(slider);
	BrushCoreSetGrayCirclePattern(smudge->core, smudge->r, smudge->outline_hardness * 0.01,
		smudge->blur * 0.01, smudge->opacity * 0.01);
}

static void SmudgeColorExtendsChange(
	GtkAdjustment* slider,
	SMUDGE* smudge
)
{
	smudge->extention =
		gtk_adjustment_get_value(slider);
}

static void SmudgeExtentionChange(
	GtkWidget* widget,
	gpointer data
)
{
	SMUDGE* smudge = (SMUDGE*)data;
	if(gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(widget)) == FALSE)
	{
		smudge->flags &= ~(SMUDGE_PRESSURE_EXTENTION);
	}
	else
	{
		smudge->flags |= SMUDGE_PRESSURE_EXTENTION;
	}
}

static GtkWidget* CreateSmudgeDetailUI(APPLICATION* app, BRUSH_CORE* core)
{
#define UI_FONT_SIZE 8.0
	SMUDGE* smudge = (SMUDGE*)core->brush_data;
	GtkWidget* vbox = gtk_vbox_new(FALSE, 2);
	GtkWidget* hbox;
	GtkWidget* base_scale;
	GtkWidget* brush_scale;
	GtkWidget* table = gtk_table_new(5, 3, TRUE);
	GtkWidget* check_button;
	GtkWidget* label;
	GtkAdjustment* brush_scale_adjustment;
	char mark_up_buff[256];

	smudge->core = core;

	BrushCoreSetGrayCirclePattern(smudge->core, smudge->r, smudge->outline_hardness * 0.01,
		smudge->blur * 0.01, smudge->opacity * 0.01);

	{
		const char *mag_str[] = {"x 0.1", "x 1", "x 10"};
		hbox = gtk_hbox_new(FALSE, 0);
		label = gtk_label_new("");
		(void)sprintf(mark_up_buff, "<span font_desc=\"%.2f\">%s : </span>",
			UI_FONT_SIZE * app->gui_scale, app->labels->tool_box.base_scale);
		gtk_label_set_markup(GTK_LABEL(label), mark_up_buff);
		gtk_box_pack_start(GTK_BOX(hbox), label, FALSE, FALSE, 0);
#if GTK_MAJOR_VERSION <= 2
		base_scale = gtk_combo_box_new_text();
		gtk_combo_box_append_text(GTK_COMBO_BOX(base_scale), mag_str[0]);
		gtk_combo_box_append_text(GTK_COMBO_BOX(base_scale), mag_str[1]);
		gtk_combo_box_append_text(GTK_COMBO_BOX(base_scale), mag_str[2]);
#else
		base_scale = gtk_combo_box_text_new();
		gtk_combo_box_text_append_text(GTK_COMBO_BOX_TEXT(base_scale), mag_str[0]);
		gtk_combo_box_text_append_text(GTK_COMBO_BOX_TEXT(base_scale), mag_str[1]);
		gtk_combo_box_text_append_text(GTK_COMBO_BOX_TEXT(base_scale), mag_str[2]);
#endif
		gtk_combo_box_set_active(GTK_COMBO_BOX(base_scale), smudge->base_scale);
		gtk_box_pack_start(GTK_BOX(hbox), base_scale, TRUE, TRUE, 0);
		gtk_box_pack_start(GTK_BOX(vbox), hbox, FALSE, FALSE, 0);
	}

	switch(smudge->base_scale)
	{
	case 0:
		brush_scale_adjustment =
			GTK_ADJUSTMENT(gtk_adjustment_new(smudge->r * 2, 0.1, 10.0, 0.1, 0.1, 0.0));
		break;
	case 1:
		brush_scale_adjustment = GTK_ADJUSTMENT(gtk_adjustment_new(
			smudge->r * 2, 1.0, 100.0, 1.0, 1.0, 0.0));
		break;
	default:
		brush_scale_adjustment =
			GTK_ADJUSTMENT(gtk_adjustment_new(smudge->r * 2, 5.0, 500.0, 1.0, 1.0, 0.0));
	}

	brush_scale = SpinScaleNew(brush_scale_adjustment,
		app->labels->tool_box.brush_scale, 1);
	g_signal_connect(G_OBJECT(brush_scale_adjustment), "value_changed",
		G_CALLBACK(SmudgeScaleChange), core->brush_data);
	gtk_table_attach_defaults(GTK_TABLE(table), brush_scale, 0, 3, 0, 1);

	g_object_set_data(G_OBJECT(base_scale), "scale", brush_scale);
	g_signal_connect(G_OBJECT(base_scale), "changed", G_CALLBACK(SetBrushBaseScale), &smudge->base_scale);

	brush_scale_adjustment =
		GTK_ADJUSTMENT(gtk_adjustment_new(smudge->opacity, 0.0, 100.0, 1.0, 1.0, 0.0));
	brush_scale = SpinScaleNew(brush_scale_adjustment,
		app->labels->tool_box.flow, 1);
	g_signal_connect(G_OBJECT(brush_scale_adjustment), "value_changed",
		G_CALLBACK(SmudgeOpacityChange), core->brush_data);
	gtk_table_attach_defaults(GTK_TABLE(table), brush_scale, 0, 3, 1, 2);

	brush_scale_adjustment = GTK_ADJUSTMENT(gtk_adjustment_new(smudge->outline_hardness,
		0, 100, 1, 1, 0));
	g_signal_connect(G_OBJECT(brush_scale_adjustment), "value_changed",
		G_CALLBACK(SmudgeOutlineHardnessChange), core->brush_data);
	brush_scale = SpinScaleNew(brush_scale_adjustment,
		app->labels->tool_box.outline_hardness, 1);
	gtk_table_attach_defaults(GTK_TABLE(table), brush_scale, 0, 3, 2, 3);

	brush_scale_adjustment =
		GTK_ADJUSTMENT(gtk_adjustment_new(smudge->blur, 0.0, 100.0, 1.0, 1.0, 0.0));
	brush_scale = SpinScaleNew(brush_scale_adjustment,
		app->labels->tool_box.blur, 1);
	g_signal_connect(G_OBJECT(brush_scale_adjustment), "value_changed",
		G_CALLBACK(SmudgeBlurChange), core->brush_data);
	gtk_table_attach_defaults(GTK_TABLE(table), brush_scale, 0, 3, 3, 4);

	brush_scale_adjustment = GTK_ADJUSTMENT(gtk_adjustment_new(smudge->extention,
		0, 100, 1, 1, 0));
	g_signal_connect(G_OBJECT(brush_scale_adjustment), "value_changed",
		G_CALLBACK(SmudgeColorExtendsChange), core->brush_data);
	brush_scale = SpinScaleNew(brush_scale_adjustment,
		app->labels->tool_box.color_extend, 1);
	gtk_table_attach_defaults(GTK_TABLE(table), brush_scale, 0, 3, 4, 5);
	gtk_box_pack_start(GTK_BOX(vbox), table, FALSE, TRUE, 0);

	table = gtk_hbox_new(FALSE, 0);
	label = gtk_label_new("");
	(void)sprintf(mark_up_buff, "<span font_desc=\"%.2f\">%s : </span>",
		UI_FONT_SIZE * app->gui_scale, app->labels->tool_box.pressure);
	gtk_label_set_markup(GTK_LABEL(label), mark_up_buff);
	gtk_box_pack_start(GTK_BOX(table), label, FALSE, TRUE, 0);
	check_button = gtk_check_button_new_with_label(app->labels->tool_box.scale);
	g_signal_connect(G_OBJECT(check_button), "toggled", G_CALLBACK(SmudgePressureSizeChange), core->brush_data);
	gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(check_button), smudge->flags & SMUDGE_PRESSURE_SIZE);
	gtk_box_pack_start(GTK_BOX(table), check_button, FALSE, TRUE, 0);
	check_button = gtk_check_button_new_with_label(app->labels->tool_box.flow);
	g_signal_connect(G_OBJECT(check_button), "toggled", G_CALLBACK(SmudgeExtentionChange), core->brush_data);
	gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(check_button), smudge->flags & SMUDGE_PRESSURE_EXTENTION);
	gtk_box_pack_start(GTK_BOX(table), check_button, FALSE, TRUE, 0);
	gtk_box_pack_start(GTK_BOX(vbox), table, FALSE, TRUE, 0);

	return vbox;
}

static void MixBrushPressCallBack(
	DRAW_WINDOW* window,
	FLOAT_T x,
	FLOAT_T y,
	FLOAT_T pressure,
	BRUSH_CORE *core,
	void* state
)
{
	// 左クリックならば
	if(((GdkEventButton*)state)->button == 1)
	{
		// ブラシの詳細情報にキャスト
		MIX_BRUSH* mix = (MIX_BRUSH*)core->brush_data;
		// ブラシの半径と不透明度
		FLOAT_T r, alpha;
		// 座標の最大・最小値
		FLOAT_T min_x, min_y, max_x, max_y;
		// ピクセルデータをリセットする座標
		int start_x, start_y;
		// 描画する幅、高さ、一行分のバイト数
		int width, height, stride;
		// ブラシ位置のピクセル値合計
		unsigned int sum_color[5] = {0, 0, 0, 1, 1};
		// 参照ピクセル
		uint8 *ref_pix, *mask_pix;
		// 描画する色
		uint8 color[4];
		// αブレンド用
		uint8 rev_alpha;
		uint8 blend_alpha;
		// ブラシパターン
		cairo_pattern_t *brush;
		int i, j;	// for文用のカウンタ

		// アクティブレイヤーの内容を作業レイヤーにコピー
		(void)memcpy(window->work_layer->pixels, window->active_layer->pixels, window->pixel_buf_size);

		// 作業レイヤーの合成モードを上書きモードに
		window->work_layer->layer_mode = LAYER_BLEND_SOURCE;

		// ワークレイヤーでのCAIROの合成モードを通常モードに
		cairo_set_operator(window->work_layer->cairo_p, CAIRO_OPERATOR_OVER);

		// 半径と濃度を計算
		r = ((mix->flags & BRUSH_FLAG_SIZE) == 0) ? mix->r : mix->r * pressure;
		alpha = ((mix->flags & BRUSH_FLAG_FLOW) == 0) ? mix->alpha : mix->alpha * pressure;
		alpha *= 0.01;

		// αチャンネル記憶用にバッファをクリア
		(void)memset(window->brush_buffer, 0, window->width*window->height);

		// 現在の座標を記憶
		mix->before_x = x, mix->before_y = y;

		min_x = x - r, max_x = x + r;
		min_y = y - r, max_y = y + r;

		if(min_x < 0.0)
		{
			min_x = 0.0;
		}
		if(min_y < 0.0)
		{
			min_y = 0.0;
		}
		if(max_x > window->work_layer->width)
		{
			max_x = window->work_layer->width;
		}
		if(max_y > window->work_layer->height)
		{
			max_y = window->work_layer->height;
		}

		core->min_x = min_x, core->min_y = min_y;
		core->max_x = max_x, core->max_y = max_y;
		start_x = (int)min_x, start_y = (int)min_y;
		width = (int)(max_x - min_x);
		height = (int)(max_y - min_y);
		stride = width * 4;

		for(i=0; i<height; i++)
		{
			(void)memset(&window->mask_temp->pixels[(i+start_y)*window->mask_temp->stride+start_x*4],
				0, stride);
		}

		cairo_set_operator(window->mask_temp->cairo_p, CAIRO_OPERATOR_OVER);
		brush = cairo_pattern_create_radial(x, y, 0, x, y, r);
		cairo_pattern_set_extend(brush, CAIRO_EXTEND_NONE);
		cairo_pattern_add_color_stop_rgba(brush, 0, 0, 0, 0, alpha);
		cairo_pattern_add_color_stop_rgba(brush, 1.0-mix->blur*0.01, 0, 0, 0, alpha);
		cairo_pattern_add_color_stop_rgba(brush, 1, 0, 0, 0, mix->outline_hardness*0.01*alpha);
		cairo_set_source(window->mask_temp->cairo_p, brush);

		if((window->flags & DRAW_WINDOW_HAS_SELECTION_AREA) == 0)
		{
			cairo_arc(window->mask_temp->cairo_p, x, y, r, 0, 2*G_PI);
			cairo_fill(window->mask_temp->cairo_p);
		}
		else
		{
			cairo_mask_surface(window->mask_temp->cairo_p, window->selection->surface_p, 0, 0);
		}
		cairo_pattern_destroy(brush);

		for(i=0; i<height; i++)
		{
			ref_pix = &window->work_layer->pixels[(i+start_y)*window->work_layer->stride+start_x*4];
			mask_pix = &window->mask_temp->pixels[(i+start_y)*window->mask_temp->stride+start_x*4+3];
			for(j=0; j<width; j++, ref_pix+=4, mask_pix+=4)
			{
				sum_color[0] += ((ref_pix[0]+1) * *mask_pix * ref_pix[3]) >> 8;
				sum_color[1] += ((ref_pix[1]+1) * *mask_pix * ref_pix[3]) >> 8;
				sum_color[2] += ((ref_pix[2]+1) * *mask_pix * ref_pix[3]) >> 8;
				sum_color[3] += ((ref_pix[3]+1) * *mask_pix) >> 8;
				sum_color[4] += *mask_pix;
			}
		}

		color[0] = (uint8)((sum_color[0] + sum_color[3] / 2) / sum_color[3]);
		color[1] = (uint8)((sum_color[1] + sum_color[3] / 2) / sum_color[3]);
		color[2] = (uint8)((sum_color[2] + sum_color[3] / 2) / sum_color[3]);
		color[3] = (uint8)((sum_color[3] + (sum_color[4] / 255) / 2) / (sum_color[4] / 255.0));

		for(i=0; i<height; i++)
		{
			(void)memset(&window->temp_layer->pixels[(i+start_y)*window->temp_layer->stride+start_x*4],
				0, stride);
		}

		brush = cairo_pattern_create_radial(x, y, 0, x, y, r);
		cairo_pattern_set_extend(brush, CAIRO_EXTEND_NONE);
#if !defined(USE_BGR_COLOR_SPACE) || USE_BGR_COLOR_SPACE == 0
		cairo_pattern_add_color_stop_rgba(brush, 0,
			color[2]*DIV_PIXEL, color[1]*DIV_PIXEL, color[0]*DIV_PIXEL, alpha*(color[3]*DIV_PIXEL));
		cairo_pattern_add_color_stop_rgba(brush, 1.0-mix->blur*0.01,
			color[2]*DIV_PIXEL, color[1]*DIV_PIXEL, color[0]*DIV_PIXEL, alpha*(color[3]*DIV_PIXEL));
		cairo_pattern_add_color_stop_rgba(brush, 1,
			color[2]*DIV_PIXEL, color[1]*DIV_PIXEL, color[0]*DIV_PIXEL,
			alpha*mix->outline_hardness*0.01*(color[3]*DIV_PIXEL));
		cairo_set_source(window->temp_layer->cairo_p, brush);
#else
		cairo_pattern_add_color_stop_rgba(brush, 0,
			color[0]*DIV_PIXEL, color[1]*DIV_PIXEL, color[2]*DIV_PIXEL, alpha);
		cairo_pattern_add_color_stop_rgba(brush, 1.0-mix->blur*0.01,
			color[0]*DIV_PIXEL, color[1]*DIV_PIXEL, color[2]*DIV_PIXEL, alpha);
		cairo_pattern_add_color_stop_rgba(brush, 1,
			color[0]*DIV_PIXEL, color[1]*DIV_PIXEL, color[2]*DIV_PIXEL, alpha*mix->outline_hardness);
		cairo_set_source(window->temp_layer->cairo_p, brush);
#endif
		if((window->flags & DRAW_WINDOW_HAS_SELECTION_AREA) == 0)
		{
			cairo_arc(window->temp_layer->cairo_p, x, y, r, 0, 2*G_PI);
			cairo_fill(window->temp_layer->cairo_p);
		}
		else
		{
			cairo_mask_surface(window->temp_layer->cairo_p, window->selection->surface_p, 0, 0);
		}
		cairo_pattern_destroy(brush);

		for(i=0; i<height; i++)
		{
			ref_pix = &window->work_layer->pixels[(i+start_y)*window->work_layer->stride+start_x*4];
			mask_pix = &window->temp_layer->pixels[(i+start_y)*window->temp_layer->stride+start_x*4];

			for(j=0; j<width; j++, ref_pix+=4, mask_pix+=4)
			{
				rev_alpha = ~mask_pix[3];
				blend_alpha = ((rev_alpha+1)*ref_pix[3]+mask_pix[3]*color[3])>>8;

				ref_pix[0] = ((rev_alpha+1)*ref_pix[0]+color[0]*mask_pix[3])>>8;
				ref_pix[1] = ((rev_alpha+1)*ref_pix[1]+color[1]*mask_pix[3])>>8;
				ref_pix[2] = ((rev_alpha+1)*ref_pix[2]+color[2]*mask_pix[3])>>8;
				ref_pix[3] = blend_alpha;
			}
		}
	}
}

static void MixBrushEditSelectionPressCallBack(
	DRAW_WINDOW* window,
	FLOAT_T x,
	FLOAT_T y,
	FLOAT_T pressure,
	BRUSH_CORE *core,
	void* state
)
{
	// 左クリックならば
	if(((GdkEventButton*)state)->button == 1)
	{
		// ブラシの詳細情報にキャスト
		MIX_BRUSH* mix = (MIX_BRUSH*)core->brush_data;
		// ブラシの半径と不透明度
		FLOAT_T r, alpha;
		// 座標の最大・最小値
		FLOAT_T min_x, min_y, max_x, max_y;
		// ピクセルデータをリセットする座標
		int start_x, start_y;
		// 描画する幅、高さ、一行分のバイト数
		int width, height, stride;
		// ブラシ位置のピクセル値合計
		unsigned int sum_color[2] = {1, 1};
		// 参照ピクセル
		uint8 *ref_pix, *mask_pix;
		// 描画する色
		uint8 color[2];
		// αブレンド用
		uint8 rev_alpha;
		uint8 blend_alpha;
		// ブラシパターン
		cairo_pattern_t *brush;
		int i, j;	// for文用のカウンタ

		// 選択範囲の内容を作業レイヤーにコピー
		(void)memcpy(window->work_layer->pixels, window->selection->pixels, window->width * window->height);

		// 作業レイヤーの合成モードを上書きモードに
		window->selection->layer_mode = SELECTION_BLEND_COPY;

		// ワークレイヤーでのCAIROの合成モードを通常モードに
		cairo_set_operator(window->work_layer->cairo_p, CAIRO_OPERATOR_OVER);

		// 半径と濃度を計算
		r = ((mix->flags & BRUSH_FLAG_SIZE) == 0) ? mix->r : mix->r * pressure;
		alpha = ((mix->flags & BRUSH_FLAG_FLOW) == 0) ? mix->alpha : mix->alpha * pressure;
		alpha *= 0.01;

		// αチャンネル記憶用にバッファをクリア
		(void)memset(window->brush_buffer, 0, window->width*window->height);

		// 現在の座標を記憶
		mix->before_x = x, mix->before_y = y;

		min_x = x - r, max_x = x + r;
		min_y = y - r, max_y = y + r;

		if(min_x < 0.0)
		{
			min_x = 0.0;
		}
		if(min_y < 0.0)
		{
			min_y = 0.0;
		}
		if(max_x > window->work_layer->width)
		{
			max_x = window->work_layer->width;
		}
		if(max_y > window->work_layer->height)
		{
			max_y = window->work_layer->height;
		}

		core->min_x = min_x, core->min_y = min_y;
		core->max_x = max_x, core->max_y = max_y;
		start_x = (int)min_x, start_y = (int)min_y;
		width = (int)(max_x - min_x);
		height = (int)(max_y - min_y);
		stride = width * 4;

		for(i=0; i<height; i++)
		{
			(void)memset(&window->mask_temp->pixels[(i+start_y)*window->mask_temp->stride+start_x*4],
				0, stride);
		}

		cairo_set_operator(window->mask_temp->cairo_p, CAIRO_OPERATOR_OVER);
		brush = cairo_pattern_create_radial(x, y, 0, x, y, r);
		cairo_pattern_set_extend(brush, CAIRO_EXTEND_NONE);
		cairo_pattern_add_color_stop_rgba(brush, 0, 0, 0, 0, alpha);
		cairo_pattern_add_color_stop_rgba(brush, 1.0-mix->blur*0.01, 0, 0, 0, alpha);
		cairo_pattern_add_color_stop_rgba(brush, 1, 0, 0, 0, mix->outline_hardness*0.01*alpha);
		cairo_set_source(window->mask_temp->cairo_p, brush);

		cairo_arc(window->mask_temp->cairo_p, x, y, r, 0, 2*G_PI);
		cairo_fill(window->mask_temp->cairo_p);
		
		cairo_pattern_destroy(brush);

		for(i=0; i<height; i++)
		{
			ref_pix = &window->work_layer->pixels[(i+start_y)*window->work_layer->width+start_x];
			mask_pix = &window->mask_temp->pixels[(i+start_y)*window->mask_temp->stride+start_x*4+3];
			for(j=0; j<width; j++, ref_pix++, mask_pix+=4)
			{
				sum_color[0] += ((ref_pix[3]+1) * *mask_pix) >> 8;
				sum_color[1] += *mask_pix;
			}
		}

		color[0] = (uint8)((sum_color[0] + (sum_color[1] / 255) / 2) / (sum_color[1] / 255.0));

		for(i=0; i<height; i++)
		{
			(void)memset(&window->temp_layer->pixels[(i+start_y)*window->temp_layer->stride+start_x*4],
				0, stride);
		}

		brush = cairo_pattern_create_radial(x, y, 0, x, y, r);
		cairo_pattern_set_extend(brush, CAIRO_EXTEND_NONE);

		cairo_pattern_add_color_stop_rgba(brush, 0,
			0, 0, 0, alpha*(color[0]*DIV_PIXEL));
		cairo_pattern_add_color_stop_rgba(brush, 1.0-mix->blur*0.01,
			0, 0, 0, alpha*(color[0]*DIV_PIXEL));
		cairo_pattern_add_color_stop_rgba(brush, 1,
			0, 0, 0,
			alpha*mix->outline_hardness*0.01*(color[0]*DIV_PIXEL));
		cairo_set_source(window->temp_layer->cairo_p, brush);

		cairo_arc(window->temp_layer->cairo_p, x, y, r, 0, 2*G_PI);
		cairo_fill(window->temp_layer->cairo_p);
		cairo_pattern_destroy(brush);

		for(i=0; i<height; i++)
		{
			ref_pix = &window->work_layer->pixels[(i+start_y)*window->work_layer->width+start_x];
			mask_pix = &window->temp_layer->pixels[(i+start_y)*window->temp_layer->stride+start_x*4];

			for(j=0; j<width; j++, ref_pix++, mask_pix+=4)
			{
				rev_alpha = ~mask_pix[3];
				blend_alpha = ((rev_alpha+1)*ref_pix[0]+mask_pix[0]*color[0])>>8;

				ref_pix[0] = blend_alpha;
			}
		}
	}
}

static void MixBrushMotionCallBack(
	DRAW_WINDOW* window,
	FLOAT_T x,
	FLOAT_T y,
	FLOAT_T pressure,
	BRUSH_CORE *core,
	void* state
)
{
	if(((*(GdkModifierType*)state) & GDK_BUTTON1_MASK) != 0)
	{
		// ブラシの詳細情報にキャスト
		MIX_BRUSH* mix = (MIX_BRUSH*)core->brush_data;
		// ブラシの半径と不透明度
		FLOAT_T r, alpha;
		// 座標の最大・最小値
		FLOAT_T min_x, min_y, max_x, max_y;
		// X、Y方向の移動量
		FLOAT_T dx, dy;
		// ブラシの傾き用
		FLOAT_T diff_x, diff_y;
		// ブラシの移動量
		FLOAT_T d;
		// 描画を行う座標
		FLOAT_T draw_x = mix->before_x, draw_y = mix->before_y;
		// ピクセルデータをリセットする座標
		int start_x, start_y;
		// 描画する幅、高さ、一行分のバイト数
		int width, height, stride;
		// ブラシ位置のピクセル値合計
		unsigned int sum_color[5];
		// 参照ピクセル
		uint8 *ref_pix, *mask_pix, *comp_pix, *alpha_pix;
		// αブレンド用
		uint8 rev_alpha;
		uint8 blend_alpha;
		FLOAT_T inv_alpha;
		// 描画する色
		uint8 color[4];
		// ブラシパターン
		cairo_pattern_t *brush;
		// 輪郭の硬さのバイト値
		uint8 hardness = (uint8)(mix->outline_hardness*2.55);
		// マスクのバイト値
		uint8 mask_value;
		int i, j;	// for文用のカウンタ

		// 半径と濃度を計算
		r = ((mix->flags & BRUSH_FLAG_SIZE) == 0) ? mix->r : mix->r * pressure;
		alpha = ((mix->flags & BRUSH_FLAG_FLOW) == 0) ? mix->alpha : mix->alpha * pressure;
		alpha *= 0.01;

		// ブラシの移動範囲を更新
		min_x = x - r - 1, min_y = y - r - 1;
		max_x = x + r + 1, max_y = y + r + 1;
		if(min_x < 0.0)
		{
			min_x = 0.0;
		}
		if(core->min_x > min_x)
		{
			core->min_x = min_x;
		}
		if(min_y < 0.0)
		{
			min_y = 0.0;
		}
		if(core->min_y > min_y)
		{
			core->min_y = min_y;
		}
		if(max_x > window->work_layer->width)
		{
			max_x = window->work_layer->width;
		}
		if(core->max_x < max_x)
		{
			core->max_x = max_x;
		}
		if(max_y > window->work_layer->height)
		{
			max_y = window->work_layer->height;
		}
		if(core->max_y < max_y)
		{
			core->max_y = max_y;
		}

		// 前のステップからの距離を計算
		dx = x - mix->before_x, dy = y - mix->before_y;
		d = sqrt(dx*dx+dy*dy);
		diff_x = dx / d, diff_y = dy / d;

		dx = d;
		do
		{
			sum_color[0] = sum_color[1] = sum_color[2] = 0;
			sum_color[3] = sum_color[4] = 1;
			start_x = (int)(draw_x - r);
			start_y = (int)(draw_y - r);
			width = (int)(draw_x + r);
			height = (int)(draw_y + r);

			if(start_x < 0)
			{
				start_x = 0;
			}
			else if(start_x > window->work_layer->width)
			{
				goto skip_draw;
			}
			if(start_y < 0)
			{
				start_y = 0;
			}
			else if(start_y > window->work_layer->height)
			{
				goto skip_draw;
			}
			if(width > window->work_layer->width)
			{
				width = window->work_layer->width - start_x;
			}
			else
			{
				width = width - start_x;
			}
			if(height > window->work_layer->height)
			{
				height = window->work_layer->height - start_y;
			}
			else
			{
				height = height - start_y;
			}
			stride = width*4;

			for(i=0; i<height; i++)
			{
				(void)memset(&window->mask_temp->pixels[(i+start_y)*window->mask_temp->stride+start_x*4],
					0, stride);
			}

			cairo_set_operator(window->mask_temp->cairo_p, CAIRO_OPERATOR_OVER);
			brush = cairo_pattern_create_radial(draw_x, draw_y, 0, draw_x, draw_y, r);
			cairo_pattern_set_extend(brush, CAIRO_EXTEND_NONE);
			cairo_pattern_add_color_stop_rgba(brush, 0, 0, 0, 0, alpha);
			cairo_pattern_add_color_stop_rgba(brush, 1.0-mix->blur*0.01, 0, 0, 0, alpha);
			cairo_pattern_add_color_stop_rgba(brush, 1, 0, 0, 0, mix->outline_hardness*0.01*alpha);
			cairo_set_source(window->mask_temp->cairo_p, brush);

			if((window->flags & DRAW_WINDOW_HAS_SELECTION_AREA) == 0)
			{
				cairo_arc(window->mask_temp->cairo_p, draw_x, draw_y, r, 0, 2*G_PI);
				cairo_fill(window->mask_temp->cairo_p);
			}
			else
			{
				cairo_mask_surface(window->mask_temp->cairo_p, window->selection->surface_p, 0, 0);
			}
			cairo_pattern_destroy(brush);

			for(i=0; i<height; i++)
			{
				ref_pix = &window->work_layer->pixels[(i+start_y)*window->work_layer->stride+start_x*4];
				mask_pix = &window->mask_temp->pixels[(i+start_y)*window->mask_temp->stride+start_x*4+3];
				for(j=0; j<width; j++, ref_pix+=4, mask_pix+=4)
				{
					sum_color[0] += ((ref_pix[0]+1) * *mask_pix * ref_pix[3]) >> 8;
					sum_color[1] += ((ref_pix[1]+1) * *mask_pix * ref_pix[3]) >> 8;
					sum_color[2] += ((ref_pix[2]+1) * *mask_pix * ref_pix[3]) >> 8;
					sum_color[3] += ((ref_pix[3]+1) * *mask_pix) >> 8;
					sum_color[4] += *mask_pix;
				}
			}
			color[0] = (uint8)((sum_color[0] + sum_color[3] / 2) / sum_color[3]);
			color[1] = (uint8)((sum_color[1] + sum_color[3] / 2) / sum_color[3]);
			color[2] = (uint8)((sum_color[2] + sum_color[3] / 2) / sum_color[3]);
			color[3] = (uint8)((sum_color[3] + (sum_color[4] / 255) / 2) / (sum_color[4] / 255.0));
			inv_alpha = color[3] * DIV_PIXEL;

			for(i=0; i<height; i++)
			{
				ref_pix = &window->work_layer->pixels[(i+start_y)*window->work_layer->stride+start_x*4];
				mask_pix = &window->temp_layer->pixels[(i+start_y)*window->temp_layer->stride+start_x*4];
				comp_pix = &window->brush_buffer[(i+start_y)*window->width+start_x];
				alpha_pix = &window->mask_temp->pixels[(i+start_y)*window->mask_temp->stride+start_x*4+3];

				for(j=0; j<width; j++, ref_pix+=4, mask_pix+=4, comp_pix++, alpha_pix+=4)
				{
					mask_value = *alpha_pix;
					*alpha_pix = (uint8)(*alpha_pix * inv_alpha);
					blend_alpha = *alpha_pix;
					rev_alpha = ~blend_alpha;
					blend_alpha = ((rev_alpha+1)*ref_pix[3]+blend_alpha*color[3])>>8;

					if(*alpha_pix > *comp_pix)
					{
						*comp_pix = mask_value;
						ref_pix[0] = ((rev_alpha+1)*ref_pix[0]+color[0]*(*alpha_pix))>>8;
						ref_pix[1] = ((rev_alpha+1)*ref_pix[1]+color[1]*(*alpha_pix))>>8;
						ref_pix[2] = ((rev_alpha+1)*ref_pix[2]+color[2]*(*alpha_pix))>>8;
						ref_pix[3] = blend_alpha;
					}
					else if(*alpha_pix > ref_pix[3])//if(blend_alpha > ref_pix[3])
					{
						ref_pix[0] = ((rev_alpha+1)*ref_pix[0]+color[0]*(*alpha_pix))>>8;
						ref_pix[1] = ((rev_alpha+1)*ref_pix[1]+color[1]*(*alpha_pix))>>8;
						ref_pix[2] = ((rev_alpha+1)*ref_pix[2]+color[2]*(*alpha_pix))>>8;
						ref_pix[3] = ((0xff-hardness)*(*alpha_pix)+(hardness+1)*blend_alpha)>>8;
					}
				}
			}
skip_draw:
			dx -= 1;
			if(dx < 1)
			{
				break;
			}
			else
			{
				draw_x += diff_x, draw_y += diff_y;
			}
		} while(1);

		// 現在の座標を記憶
		mix->before_x = x, mix->before_y = y;
	}
}

static void MixBrushEditSelectionMotionCallBack(
	DRAW_WINDOW* window,
	FLOAT_T x,
	FLOAT_T y,
	FLOAT_T pressure,
	BRUSH_CORE *core,
	void* state
)
{
	if(((*(GdkModifierType*)state) & GDK_BUTTON1_MASK) != 0)
	{
		// ブラシの詳細情報にキャスト
		MIX_BRUSH* mix = (MIX_BRUSH*)core->brush_data;
		// ブラシの半径と不透明度
		FLOAT_T r, alpha;
		// 座標の最大・最小値
		FLOAT_T min_x, min_y, max_x, max_y;
		// X、Y方向の移動量
		FLOAT_T dx, dy;
		// ブラシの傾き用
		FLOAT_T diff_x, diff_y;
		// ブラシの移動量
		FLOAT_T d;
		// 描画を行う座標
		FLOAT_T draw_x = mix->before_x, draw_y = mix->before_y;
		// ピクセルデータをリセットする座標
		int start_x, start_y;
		// 描画する幅、高さ、一行分のバイト数
		int width, height, stride;
		// ブラシ位置のピクセル値合計
		unsigned int sum_color[2];
		// 参照ピクセル
		uint8 *ref_pix, *mask_pix, *comp_pix, *alpha_pix;
		// αブレンド用
		uint8 rev_alpha;
		uint8 blend_alpha;
		FLOAT_T inv_alpha;
		// 描画する色
		uint8 color[2];
		// ブラシパターン
		cairo_pattern_t *brush;
		// 輪郭の硬さのバイト値
		uint8 hardness = (uint8)(mix->outline_hardness*2.55);
		// マスクのバイト値
		uint8 mask_value;
		int i, j;	// for文用のカウンタ

		// 半径と濃度を計算
		r = ((mix->flags & BRUSH_FLAG_SIZE) == 0) ? mix->r : mix->r * pressure;
		alpha = ((mix->flags & BRUSH_FLAG_FLOW) == 0) ? mix->alpha : mix->alpha * pressure;
		alpha *= 0.01;

		// ブラシの移動範囲を更新
		min_x = x - r - 1, min_y = y - r - 1;
		max_x = x + r + 1, max_y = y + r + 1;
		if(min_x < 0.0)
		{
			min_x = 0.0;
		}
		if(core->min_x > min_x)
		{
			core->min_x = min_x;
		}
		if(min_y < 0.0)
		{
			min_y = 0.0;
		}
		if(core->min_y > min_y)
		{
			core->min_y = min_y;
		}
		if(max_x > window->work_layer->width)
		{
			max_x = window->work_layer->width;
		}
		if(core->max_x < max_x)
		{
			core->max_x = max_x;
		}
		if(max_y > window->work_layer->height)
		{
			max_y = window->work_layer->height;
		}
		if(core->max_y < max_y)
		{
			core->max_y = max_y;
		}

		// 前のステップからの距離を計算
		dx = x - mix->before_x, dy = y - mix->before_y;
		d = sqrt(dx*dx+dy*dy);
		diff_x = dx / d, diff_y = dy / d;

		dx = d;
		do
		{
			sum_color[0] = sum_color[1] = 1;
			start_x = (int)(draw_x - r);
			start_y = (int)(draw_y - r);
			width = (int)(draw_x + r);
			height = (int)(draw_y + r);

			if(start_x < 0)
			{
				start_x = 0;
			}
			else if(start_x > window->work_layer->width)
			{
				goto skip_draw;
			}
			if(start_y < 0)
			{
				start_y = 0;
			}
			else if(start_y > window->work_layer->height)
			{
				goto skip_draw;
			}
			if(width > window->work_layer->width)
			{
				width = window->work_layer->width - start_x;
			}
			else
			{
				width = width - start_x;
			}
			if(height > window->work_layer->height)
			{
				height = window->work_layer->height - start_y;
			}
			else
			{
				height = height - start_y;
			}
			stride = width*4;

			for(i=0; i<height; i++)
			{
				(void)memset(&window->mask_temp->pixels[(i+start_y)*window->mask_temp->stride+start_x*4],
					0, stride);
			}

			cairo_set_operator(window->mask_temp->cairo_p, CAIRO_OPERATOR_OVER);
			brush = cairo_pattern_create_radial(draw_x, draw_y, 0, draw_x, draw_y, r);
			cairo_pattern_set_extend(brush, CAIRO_EXTEND_NONE);
			cairo_pattern_add_color_stop_rgba(brush, 0, 0, 0, 0, alpha);
			cairo_pattern_add_color_stop_rgba(brush, 1.0-mix->blur*0.01, 0, 0, 0, alpha);
			cairo_pattern_add_color_stop_rgba(brush, 1, 0, 0, 0, mix->outline_hardness*0.01*alpha);
			cairo_set_source(window->mask_temp->cairo_p, brush);

			cairo_arc(window->mask_temp->cairo_p, draw_x, draw_y, r, 0, 2*G_PI);
			cairo_fill(window->mask_temp->cairo_p);
			cairo_pattern_destroy(brush);

			for(i=0; i<height; i++)
			{
				ref_pix = &window->work_layer->pixels[(i+start_y)*window->work_layer->width+start_x];
				mask_pix = &window->mask_temp->pixels[(i+start_y)*window->mask_temp->stride+start_x*4+3];
				for(j=0; j<width; j++, ref_pix++, mask_pix+=4)
				{
					sum_color[0] += ((ref_pix[0]+1) * *mask_pix) >> 8;
					sum_color[1] += *mask_pix;
				}
			}
			color[0] = (uint8)((sum_color[0] + (sum_color[1] / 255) / 2) / (sum_color[1] / 255.0));
			inv_alpha = color[0] * DIV_PIXEL;

			for(i=0; i<height; i++)
			{
				ref_pix = &window->work_layer->pixels[(i+start_y)*window->work_layer->width+start_x];
				mask_pix = &window->temp_layer->pixels[(i+start_y)*window->temp_layer->stride+start_x*4];
				comp_pix = &window->brush_buffer[(i+start_y)*window->width+start_x];
				alpha_pix = &window->mask_temp->pixels[(i+start_y)*window->mask_temp->stride+start_x*4+3];

				for(j=0; j<width; j++, ref_pix++, mask_pix+=4, comp_pix++, alpha_pix+=4)
				{
					mask_value = *alpha_pix;
					*alpha_pix = (uint8)(*alpha_pix * inv_alpha);
					blend_alpha = *alpha_pix;
					rev_alpha = ~blend_alpha;
					blend_alpha = ((rev_alpha+1)*ref_pix[0]+blend_alpha*color[0])>>8;

					if(*alpha_pix > *comp_pix)
					{
						*comp_pix = mask_value;
						ref_pix[0] = blend_alpha;
					}
					else if(*alpha_pix > ref_pix[0])//if(blend_alpha > ref_pix[3])
					{
						ref_pix[0] = ((0xff-hardness)*(*alpha_pix)+(hardness+1)*blend_alpha)>>8;
					}
				}
			}
skip_draw:
			dx -= 1;
			if(dx < 1)
			{
				break;
			}
			else
			{
				draw_x += diff_x, draw_y += diff_y;
			}
		} while(1);

		// 現在の座標を記憶
		mix->before_x = x, mix->before_y = y;
	}
}

#define MixBrushReleaseCallBack DefaultReleaseCallBack
#define MixBrushEditSelectionReleaseCallBack DefaultEditSelectionReleaseCallBack

static void MixBrushDrawCursor(
	DRAW_WINDOW* window,
	FLOAT_T x,
	FLOAT_T y,
	void* data
)
{
	MIX_BRUSH* mix = (MIX_BRUSH*)data;
	FLOAT_T r = mix->r * window->zoom_rate;
	cairo_set_line_width(window->disp_temp->cairo_p, 1.0);
	cairo_set_source_rgb(window->disp_temp->cairo_p, 1, 1, 1);
	cairo_arc(window->disp_temp->cairo_p, x, y, r, 0, 2*G_PI);
	cairo_stroke(window->disp_temp->cairo_p);

	cairo_rectangle(window->disp_layer->cairo_p, x - r, y - r,
		(r + BRUSH_UPDATE_MARGIN) * 2, (r + BRUSH_UPDATE_MARGIN) * 2);
	cairo_clip(window->disp_layer->cairo_p);
}

static void MixBrushButtonUpdate(DRAW_WINDOW* window, FLOAT_T x, FLOAT_T y, MIX_BRUSH* mix)
{
	FLOAT_T r = mix->r * window->zoom_rate + 3;
	gtk_widget_queue_draw_area(window->window, (gint)(x - r - 1),
		(gint)(y - r - 1), (gint)(r * 2 + 3), (gint)(r * 2 + 3));
}

static void MixBrushMotionUpdate(DRAW_WINDOW* window, FLOAT_T x, FLOAT_T y, MIX_BRUSH* mix)
{
	FLOAT_T start_x, start_y;
	FLOAT_T width, height;
	FLOAT_T r = mix->r * window->zoom_rate + 3;

	if(window->before_cursor_x < x)
	{
		start_x = window->before_cursor_x - r;
		width = r * 2 + x - window->before_cursor_x;
	}
	else
	{
		start_x = x - r;
		width = r * 2 + window->before_cursor_x - x;
	}

	if(window->before_cursor_y < y)
	{
		start_y = window->before_cursor_y - r;
		height = r * 2 + y - window->before_cursor_y;
	}
	else
	{
		start_y = y - r;
		height = r * 2 + window->before_cursor_y - y;
	}

	gtk_widget_queue_draw_area(window->window,
		(gint)start_x, (gint)start_y, (gint)width + 2, (gint)height + 2);
}

static void MixBrushSetSize(GtkAdjustment* slider, MIX_BRUSH* mix)
{
	mix->r = gtk_adjustment_get_value(slider) * 0.5;
}

static void MixBrushSetAlpha(GtkAdjustment* slider, MIX_BRUSH* mix)
{
	mix->alpha = gtk_adjustment_get_value(slider);
}

static void MixBrushSetBlur(GtkAdjustment* slider, MIX_BRUSH* mix)
{
	mix->blur = gtk_adjustment_get_value(slider);
}

static void MixBrushSetOutlineHardness(GtkAdjustment* slider, MIX_BRUSH* mix)
{
	mix->outline_hardness = gtk_adjustment_get_value(slider);
}

static void MixBrushSetPressureSize(GtkWidget* button, MIX_BRUSH* mix)
{
	if(gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(button)) == FALSE)
	{
		mix->flags &= ~(BRUSH_FLAG_SIZE);
	}
	else
	{
		mix->flags |= BRUSH_FLAG_SIZE;
	}
}

static void MixBrushSetPressureFlow(GtkWidget* button, MIX_BRUSH* mix)
{
	if(gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(button)) == FALSE)
	{
		mix->flags &= ~(BRUSH_FLAG_FLOW);
	}
	else
	{
		mix->flags |= BRUSH_FLAG_FLOW;
	}
}

static GtkWidget* CreateMixBrushDetailUI(APPLICATION* app, BRUSH_CORE* core)
{
#define UI_FONT_SIZE 8.0
	MIX_BRUSH *mix = (MIX_BRUSH*)core->brush_data;
	GtkWidget *vbox = gtk_vbox_new(FALSE, 0);
	GtkWidget *hbox;
	GtkWidget *combo;
	GtkWidget *scale;
	GtkWidget *packing;
	GtkWidget *check_button;
	GtkWidget *label;
	GtkAdjustment *scale_adjust;
	char mark_up_buff[256];

	{
		const char *mag_str[] = {"x 0.1", "x 1", "x 10"};
		hbox = gtk_hbox_new(FALSE, 0);
		label = gtk_label_new("");
		(void)sprintf(mark_up_buff, "<span font_desc=\"%.2f\">%s : </span>",
			UI_FONT_SIZE * app->gui_scale, app->labels->tool_box.base_scale);
		gtk_label_set_markup(GTK_LABEL(label), mark_up_buff);
		gtk_box_pack_start(GTK_BOX(hbox), label, FALSE, FALSE, 0);
#if GTK_MAJOR_VERSION <= 2
		combo = gtk_combo_box_new_text();
		gtk_combo_box_append_text(GTK_COMBO_BOX(combo), mag_str[0]);
		gtk_combo_box_append_text(GTK_COMBO_BOX(combo), mag_str[1]);
		gtk_combo_box_append_text(GTK_COMBO_BOX(combo), mag_str[2]);
#else
		combo = gtk_combo_box_text_new();
		gtk_combo_box_text_append_text(GTK_COMBO_BOX_TEXT(combo), mag_str[0]);
		gtk_combo_box_text_append_text(GTK_COMBO_BOX_TEXT(combo), mag_str[1]);
		gtk_combo_box_text_append_text(GTK_COMBO_BOX_TEXT(combo), mag_str[2]);
#endif
		gtk_combo_box_set_active(GTK_COMBO_BOX(combo), mix->base_scale);
		gtk_box_pack_start(GTK_BOX(hbox), combo, TRUE, TRUE, 0);
		gtk_box_pack_start(GTK_BOX(vbox), hbox, FALSE, FALSE, 0);
	}

	switch(mix->base_scale)
	{
	case 0:
		scale_adjust =
			GTK_ADJUSTMENT(gtk_adjustment_new(mix->r * 2, 0.1, 10.0, 0.1, 0.1, 0.0));
		break;
	case 1:
		scale_adjust = GTK_ADJUSTMENT(gtk_adjustment_new(
			mix->r * 2, 1.0, 100.0, 1.0, 1.0, 0.0));
		break;
	default:
		scale_adjust =
			GTK_ADJUSTMENT(gtk_adjustment_new(mix->r * 2, 5.0, 500.0, 1.0, 1.0, 0.0));
	}

	scale = SpinScaleNew(scale_adjust, app->labels->tool_box.brush_scale, 1);
	g_signal_connect(G_OBJECT(scale_adjust), "value_changed",
		G_CALLBACK(MixBrushSetSize), core->brush_data);
	gtk_box_pack_start(GTK_BOX(vbox), scale, FALSE, FALSE, 0);

	g_object_set_data(G_OBJECT(combo), "scale", scale);
	g_signal_connect(G_OBJECT(combo), "changed", G_CALLBACK(SetBrushBaseScale), &mix->base_scale);

	scale_adjust = GTK_ADJUSTMENT(gtk_adjustment_new(
		mix->alpha, 0, 100, 1, 1, 0));
	scale = SpinScaleNew(scale_adjust, app->labels->tool_box.flow, 1);
	g_signal_connect(G_OBJECT(scale_adjust), "value_changed",
		G_CALLBACK(MixBrushSetAlpha), core->brush_data);
	gtk_box_pack_start(GTK_BOX(vbox), scale, FALSE, FALSE, 0);

	scale_adjust = GTK_ADJUSTMENT(gtk_adjustment_new(
		mix->outline_hardness, 0, 100, 1, 1, 0));
	scale = SpinScaleNew(scale_adjust, app->labels->tool_box.outline_hardness, 1);
	g_signal_connect(G_OBJECT(scale_adjust), "value_changed",
		G_CALLBACK(MixBrushSetOutlineHardness), core->brush_data);
	gtk_box_pack_start(GTK_BOX(vbox), scale, FALSE, FALSE, 0);

	scale_adjust = GTK_ADJUSTMENT(gtk_adjustment_new(
		mix->blur, 0, 100, 1, 1, 0));
	scale = SpinScaleNew(scale_adjust, app->labels->tool_box.blur, 1);
	g_signal_connect(G_OBJECT(scale_adjust), "value_changed",
		G_CALLBACK(MixBrushSetBlur), core->brush_data);
	gtk_box_pack_start(GTK_BOX(vbox), scale, FALSE, FALSE, 0);

	packing = gtk_hbox_new(FALSE, 0);
	label = gtk_label_new("");
	(void)sprintf(mark_up_buff, "<span font_desc=\"%.2f\">%s : </span>",
		UI_FONT_SIZE * app->gui_scale, app->labels->tool_box.pressure);
	gtk_label_set_markup(GTK_LABEL(label), mark_up_buff);
	gtk_box_pack_start(GTK_BOX(packing), label, FALSE, FALSE, 0);
	check_button = gtk_check_button_new_with_label(app->labels->tool_box.scale);
	g_signal_connect(G_OBJECT(check_button), "toggled",
		G_CALLBACK(MixBrushSetPressureSize), core->brush_data);
	gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(check_button), mix->flags & BRUSH_FLAG_SIZE);
	gtk_box_pack_start(GTK_BOX(packing), check_button, FALSE, TRUE, 0);
	check_button = gtk_check_button_new_with_label(app->labels->tool_box.flow);
	g_signal_connect(G_OBJECT(check_button), "toggled",
		G_CALLBACK(MixBrushSetPressureFlow), core->brush_data);
	gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(check_button), mix->flags & BRUSH_FLAG_FLOW);
	gtk_box_pack_start(GTK_BOX(packing), check_button, FALSE, TRUE, 0);
	gtk_box_pack_start(GTK_BOX(vbox), packing, FALSE, FALSE, 0);

	return vbox;
#undef UI_FONT_SIZE
}

static void CustomBrushButtonPressCallBack(
	DRAW_WINDOW* window,
	FLOAT_T x,
	FLOAT_T y,
	FLOAT_T pressure,
	BRUSH_CORE *core,
	void* state
)
{
	// 左クリックなら
	if(((GdkEventButton*)state)->button == 1)
	{
		// ブラシの詳細情報にキャスト
		CUSTOM_BRUSH *brush = (CUSTOM_BRUSH*)core->brush_data;
		// ブラシの半径
		FLOAT_T r;
		// 座標の最大値・最小値
		BRUSH_UPDATE_INFO area;
		// 描画結果
		uint8 *draw_pixel;
		// 拡大率
		FLOAT_T zoom;

		// ブラシの描画結果を格納するピクセルデータを初期化
			// これをしないと散布の結果が狂う
		(void)memset(window->mask_temp->pixels, 0, window->pixel_buf_size);

		// 合成ブラシとして扱う場合
		if(brush->brush_mode == CUSTOM_BRUSH_MODE_BLEND)
		{
			window->work_layer->layer_mode = LAYER_BLEND_NORMAL;

			if(brush->blend_target == BLEND_BRUSH_TARGET_UNDER_LAYER && window->active_layer->prev != NULL)
			{
				(void)memcpy(window->brush_buffer, window->active_layer->prev->pixels, window->pixel_buf_size);
			}
			else
			{
				(void)memcpy(window->brush_buffer, window->mixed_layer->pixels, window->pixel_buf_size);
			}
		}
		else if(brush->brush_mode == CUSTOM_BRUSH_MODE_SMUDGE)
		{
			window->work_layer->layer_mode = LAYER_BLEND_SOURCE;
			(void)memset(window->brush_buffer, 0, window->pixel_buf_size);
			(void)memcpy(window->work_layer->pixels, window->active_layer->pixels, window->pixel_buf_size);
		}
		else if(brush->brush_mode == CUSTOM_BRUSH_MODE_WATER_BRUSH)
		{
			window->work_layer->layer_mode = LAYER_BLEND_SOURCE;
			(void)memset(window->brush_buffer, 0, window->pixel_buf_size);
			(void)memcpy(window->work_layer->pixels, window->active_layer->pixels, window->pixel_buf_size);
			(void)memset(window->mask->pixels, 0, window->pixel_buf_size);
		}
		else	// 通常ブラシとして扱う場合
		{
			window->work_layer->layer_mode = brush->blend_mode;
		}

		zoom = ((brush->flags & CUSTOM_BRUSH_FLAG_PRESSURE_SIZE) == 0) ? 1 : pressure;
		//r = (brush->brush_shape < CUSTOM_BRUSH_SHAPE_PATTERN) ?
		//	brush->r * 0.5 * zoom : brush->r * zoom;
		r = brush->r * 0.5 * zoom;

		if((brush->flags & CUSTOM_BRUSH_FLAG_RANDOM_SIZE) != 0)
		{
			r *= rand() / (FLOAT_T)RAND_MAX;
		}

		brush->draw_distance = 0;
		brush->before_x = x, brush->before_y = y;
		brush->points[0][0] = 0;
		brush->points[0][1] = x, brush->points[0][2] = y;
		brush->points[0][3] = pressure;
		brush->sum_distance = brush->travel = brush->finish_length = 0;
		brush->remain_distance = (brush->brush_shape == CUSTOM_BRUSH_SHAPE_CIRCLE)
			? brush->r * 0.25 : brush->distance * brush->distance;
		brush->draw_start = r * brush->out * 0.01 * 4;
		brush->enter_length = r * brush->enter * 0.01 * 4;
		brush->enter_size = (1 - brush->enter * 0.01);
		brush->num_point = 0;
		brush->draw_finished = 0;
		brush->ref_point = 1;
		brush->last_draw_x = x;
		brush->last_draw_y = y;

		UpdateBrushButtonPressDrawArea(window, &area, core, x, y, r, &brush->update);

		if(brush->brush_mode == CUSTOM_BRUSH_MODE_SMUDGE)
		{
			int start_x, start_y;
			int width, height;
			int skip = FALSE;

			start_x = (int)(x - r);
			start_y = (int)(y - r);
			width = (int)(x + r + 1);
			height = (int)(y + r + 1);

			if(start_x < 0)
			{
				start_x = 0;
			}
			else if(start_x >= window->width)
			{
				skip = TRUE;
			}
			if(width > window->width)
			{
				width = window->width;
			}
			else if(width <= 0)
			{
				skip = TRUE;
			}
			if(start_y < 0)
			{
				start_y = 0;
			}
			else if(start_y >= window->height)
			{
				skip = TRUE;
			}
			if(height > window->height)
			{
				height = window->height;
			}
			else if(height <= 0)
			{
				skip = TRUE;
			}
			width = width - start_x;
			height = height - start_y;

			if(skip == FALSE)
			{
				AdaptSmudge(window, start_x, start_y, width, height,
					width, height, NULL, brush->extend, FALSE
				);
				brush->before_width = width;
				brush->before_height = height;
				brush->draw_finished++;
			}
		}
		else if(brush->enter_length == 0 && area.width >= 0 && area.height >= 0 &&
			(brush->brush_shape == CUSTOM_BRUSH_SHAPE_CIRCLE || (brush->flags & (1 << CUSTOM_BRUSH_FLAG_ROTATE_BY_CURSOR)) == 0))
		{
			FLOAT_T alpha;			// 濃度

			alpha = ((brush->flags & (1 << CUSTOM_BRUSH_FLAG_PRESSURE_FLOW)) == 0) ?
				brush->alpha : brush->alpha * pressure;

			// ブラシの座標データを更新
			brush->points[1][0] = 0;
			brush->points[1][1] = x, brush->points[1][2] = y;
			brush->points[1][3] = pressure;
			brush->ref_point++;
			brush->draw_finished++;
			brush->num_point++;

			if((brush->flags & (1 << CUSTOM_BRUSH_FLAG_DRAW_ONLY_SCATTER)) == 0)
			{
				// 通常のブラシとして扱う場合
				if(brush->brush_mode == CUSTOM_BRUSH_MODE_NORMAL)
				{
					if(brush->brush_shape == CUSTOM_BRUSH_SHAPE_CIRCLE)
					{
						DrawCircleBrushWorkLayer(window, core, x - r, y - r, area.width,
							area.height, &draw_pixel, zoom, alpha);
					}
					else
					{
						DrawImageBrushWorkLayer(window, core, x, y, area.width, area.height, zoom,
							r, brush->start_angle, brush->image_width, brush->image_height, &draw_pixel, alpha);
					}
					AdaptNormalBrush(window, draw_pixel, (int)area.width, (int)area.height,
						area.start_x, area.start_y, brush->flags & (1 << CUSTOM_BRUSH_FLAG_ANTI_ALIAS));
				}
				else
				{
					if(brush->brush_shape == CUSTOM_BRUSH_SHAPE_CIRCLE)
					{
						DrawCircleBrush(window, core, x - r, y - r, area.width,
							area.height, &draw_pixel, zoom, alpha, brush->blend_mode);
					}
					else
					{
						DrawImageBrush(window, core, x, y, area.width, area.height, zoom,
							r, brush->start_angle, brush->image_width, brush->image_height, &draw_pixel, alpha, brush->blend_mode);
					}

					switch(brush->brush_mode)
					{
					case CUSTOM_BRUSH_MODE_BLEND:
						AdaptBlendBrush(window, draw_pixel, (int)area.width, (int)area.height,
							area.start_x, area.start_y, brush->flags & (1 << CUSTOM_BRUSH_FLAG_ANTI_ALIAS), brush->blend_mode);
						break;
					case CUSTOM_BRUSH_MODE_SMUDGE:
						break;
					case CUSTOM_BRUSH_MODE_PICKER:
						AdaptPickerBrush(window, draw_pixel, (int)area.width, (int)area.height,
							area.start_x, area.start_y, brush->flags & (1 << CUSTOM_BRUSH_FLAG_ANTI_ALIAS),
								brush->picker_mode, brush->blend_target, brush->picker_mode, brush->hue, brush->saturation, brush->brightness);
						break;
					case CUSTOM_BRUSH_MODE_WATER_BRUSH:
						BlendWaterBrush(window, core, x, y, x, y, brush->r * 0.5, area.start_x, area.start_y,
							(int)area.width, (int)area.height, window->work_layer->pixels, draw_pixel, brush->alpha, brush->before_color,
								brush->mix, brush->extend
						);
						break;
					}
				}
			}

			brush->angle += brush->rotate_speed;

			if(brush->num_scatter > 0)
			{
				FLOAT_T range = brush->scatter_range * r * 10;
				FLOAT_T scatter_r;
				FLOAT_T size;
				FLOAT_T flow;
				FLOAT_T scatter_zoom;
				FLOAT_T draw_x,	draw_y;
				FLOAT_T direction;
				FLOAT_T update_r;
				FLOAT_T update_x, update_y;
				int i;

				for(i=0; i<brush->num_scatter; i++)
				{
					direction = (rand() % 2 == 0) ? 1 : -1;
					draw_x = ((FLOAT_T)rand() / RAND_MAX) * range * direction + x;
					direction = (rand() % 2 == 0) ? 1 : -1;
					draw_y = ((FLOAT_T)rand() / RAND_MAX) * range * direction + y;
					scatter_zoom = 1 - (((FLOAT_T)rand() / RAND_MAX) * brush->scatter_random_size);
					scatter_r = r * scatter_zoom;
					size = scatter_zoom * r;
					flow = (1 - (((FLOAT_T)rand() / RAND_MAX) * brush->scatter_random_flow)) * alpha;

					UpdateBrushScatterDrawArea(window, &area, core, draw_x, draw_y, size, &brush->update);

					// 通常のブラシとして扱う場合
					if(brush->brush_mode == CUSTOM_BRUSH_MODE_NORMAL)
					{	
						if(brush->brush_shape == CUSTOM_BRUSH_SHAPE_CIRCLE)
						{
							DrawCircleBrushWorkLayer(window, core, draw_x - scatter_r, draw_y - scatter_r, area.width,
								area.height, &draw_pixel, scatter_zoom, flow);
						}
						else
						{
							DrawImageBrushWorkLayer(window, core, draw_x, draw_y, area.width, area.height, scatter_zoom,
								scatter_r, brush->start_angle, brush->image_width, brush->image_height, &draw_pixel, flow);
						}
						AdaptNormalBrush(window, draw_pixel, (int)area.width, (int)area.height,
							area.start_x, area.start_y, brush->flags & (1 << CUSTOM_BRUSH_FLAG_ANTI_ALIAS));
					}
					else
					{
						if(brush->brush_shape == CUSTOM_BRUSH_SHAPE_CIRCLE)
						{
							DrawCircleBrush(window, core, draw_x - scatter_r, draw_y - scatter_r, area.width,
								area.height, &draw_pixel, scatter_zoom, flow, brush->blend_mode);
						}
						else
						{
							DrawImageBrush(window, core, draw_x, draw_y, area.width, area.height, scatter_zoom,
								scatter_r, brush->start_angle, brush->image_width, brush->image_height, &draw_pixel, flow, brush->blend_mode);
						}

						switch(brush->brush_mode)
						{
						case CUSTOM_BRUSH_MODE_BLEND:
							AdaptBlendBrush(window, draw_pixel, (int)area.width, (int)area.height,
								area.start_x, area.start_y, brush->flags & (1 << CUSTOM_BRUSH_FLAG_ANTI_ALIAS), brush->blend_mode);
							break;
						case CUSTOM_BRUSH_MODE_SMUDGE:
							break;
						case CUSTOM_BRUSH_MODE_PICKER:
							AdaptPickerBrush(window, draw_pixel, (int)area.width, (int)area.height,
								area.start_x, area.start_y, brush->flags & (1 << CUSTOM_BRUSH_FLAG_ANTI_ALIAS),
									brush->picker_mode, brush->blend_target, brush->picker_mode, brush->hue, brush->saturation, brush->brightness);
							break;
						case CUSTOM_BRUSH_MODE_WATER_BRUSH:
							BlendWaterBrush(window, core, draw_x, draw_y, draw_x, draw_y, brush->r * 0.5, area.start_x, area.start_y,
								(int)area.width, (int)area.height, window->work_layer->pixels, draw_pixel, brush->alpha, brush->before_color,
									brush->mix, brush->extend
							);
							break;
						}
					}

					update_r = scatter_r * window->zoom_rate;
					update_x = ((draw_x-window->width/2)*window->cos_value + (draw_y-window->height/2)*window->sin_value) * window->zoom_rate
						+ window->rev_add_cursor_x;
					update_y = (- (draw_x-window->width/2)*window->sin_value + (draw_y-window->height/2)*window->cos_value) * window->zoom_rate
						+ window->rev_add_cursor_y;
					gtk_widget_queue_draw_area(window->window, (gint)(update_x-update_r), (gint)(update_y-update_r),
						(gint)(update_r * 2 + BRUSH_UPDATE_MARGIN), (gint)(update_r * 2 + BRUSH_UPDATE_MARGIN));
				}
			}	// if(brush->num_scatter > 0)
		}

		window->flags |= DRAW_WINDOW_UPDATE_PART;
	}	// 左クリックなら
		// if(((GdkEventButton*)state)->button == 1)
}

#define CustomBrushEditSelectionPress CustomBrushButtonPressCallBack

static void CustomBrushMotionCallBack(
	DRAW_WINDOW* window,
	FLOAT_T x,
	FLOAT_T y,
	FLOAT_T pressure,
	BRUSH_CORE *core,
	void* state
)
{
	// マウスの左ボタンが押されていたら
	if(((*(GdkModifierType*)state) & GDK_BUTTON1_MASK) != 0)
	{
		// ブラシの詳細情報にキャスト
		CUSTOM_BRUSH *brush = (CUSTOM_BRUSH*)core->brush_data;
		FLOAT_T distance;
		int index = brush->ref_point % BRUSH_POINT_BUFFER_SIZE;
		// X、Y方向の移動量
		FLOAT_T dx, dy;
		dx = x-brush->before_x;
		dy = y-brush->before_y;
		distance = dx*dx + dy*dy;
		if(distance < 0.25)
		{
			return;
		}
		distance = sqrt(distance);
		brush->draw_distance += distance;
		brush->remain_distance -= distance;

		if(((brush->brush_shape == CUSTOM_BRUSH_SHAPE_CIRCLE && brush->remain_distance <= 0)
			|| (brush->brush_shape != CUSTOM_BRUSH_SHAPE_CIRCLE && brush->remain_distance <= 0))
 		)
		{
			FLOAT_T update_x, update_y, update_r;

			brush->before_x = x, brush->before_y = y;
			brush->sum_distance += distance;
			brush->travel += distance;
			brush->points[index][0] = distance;
			brush->points[index][1] = x, brush->points[index][2] = y;
			brush->points[index][3] = pressure;
			brush->ref_point++;

			if(brush->sum_distance >= brush->draw_start
				&& brush->sum_distance >= brush->enter_length)
			{
				// 入りの色補正用
				FLOAT_T enter_alpha;
				// ブラシの半径と不透明度
				FLOAT_T r, alpha;
				// ブラシの更新範囲情報
				BRUSH_UPDATE_INFO area;
				// ブラシの傾き用
				FLOAT_T diff_x, diff_y;
				// ブラシの移動量
				FLOAT_T d;
				// 描画を行う座標
				FLOAT_T draw_x = brush->before_x, draw_y = brush->before_y;
				// 画像の拡大率
				FLOAT_T zoom;
				// 画像の幅・高さの半分
				FLOAT_T half_width, half_height;
				// 描画する幅、高さ、一行分のバイト数
				int width, height, stride;
				// 作業レイヤーのピクセル
				uint8 *work_pixel = window->work_layer->pixels;
				// 参照ピクセル
				uint8 *draw_pixel;
				uint8 *mask_pixel = window->mask->pixels;
				// 配列のインデックス用
				int ref_point = brush->draw_finished % BRUSH_POINT_BUFFER_SIZE;
				int before_point;
				int i;	// for文用のカウンタ

				while(brush->sum_distance > brush->draw_start
					&& brush->draw_finished < brush->ref_point-1
					&& brush->remain_distance <= 0)
				{
					if(brush->finish_length < brush->enter_length)
					{
						if((brush->flags & (1 << CUSTOM_BRUSH_FLAG_ENTER_OUT_FLOW)) != 0)
						{
							enter_alpha = brush->finish_length / brush->enter_length;
						}
						if((brush->flags & (1 << CUSTOM_BRUSH_FLAG_ENTER_OUT_SIZE)) != 0)
						{
							r = brush->enter_size + brush->finish_length * 0.25;
						}
					}
					else
					{
						enter_alpha = 1, r = 1;
					}
					if((brush->flags & (1 << CUSTOM_BRUSH_FLAG_PRESSURE_SIZE)) != 0)
					{
						r *= brush->points[ref_point][3];
					}
					if((brush->flags & (1 << CUSTOM_BRUSH_FLAG_RANDOM_SIZE)) != 0)
					{
						r *= 1 - (brush->random_size * (rand() / (FLOAT_T)RAND_MAX));
					}

					if(r < MIN_BRUSH_STEP)
					{
						r = MIN_BRUSH_STEP;
					}

					zoom = r;
					half_width = brush->half_width * r;
					half_height = brush->half_height * r;
					//r *= (brush->brush_shape == CUSTOM_BRUSH_SHAPE_CIRCLE) ?
					//	brush->r * 0.5 : brush->r;
					r *= brush->r * 0.5;

					alpha = ((brush->flags & (1 << CUSTOM_BRUSH_FLAG_PRESSURE_FLOW)) == 0)
						? 1 : brush->points[ref_point][3];
					alpha *= enter_alpha;

					before_point = (ref_point == 0) ? BRUSH_POINT_BUFFER_SIZE - 1 : ref_point - 1;
					d = brush->points[ref_point][0];

					brush->sum_distance -= d;
					if(brush->draw_finished == 0)
					{
						draw_x = brush->points[0][1], draw_y = brush->points[0][2];
					}
					else
					{
						draw_x = brush->points[before_point][1];
						draw_y = brush->points[before_point][2];
					}
					dx = brush->points[ref_point][1] - draw_x;
					dy = brush->points[ref_point][2] - draw_y;

					d = sqrt(dx*dx + dy*dy);
					if(d < MIN_BRUSH_STEP)
					{
						brush->draw_finished++;
						return;
					}

					if((brush->flags & (1 << CUSTOM_BRUSH_FLAG_RANDOM_ROTATE)) != 0)
					{
						brush->angle = brush->start_angle +
							(rand() / (FLOAT_T)RAND_MAX) * brush->rotate_direction * brush->random_angle;
						if((brush->flags & (1 << CUSTOM_BRUSH_FLAG_ROTATE_BY_CURSOR)) != 0)
						{
							brush->angle += brush->rotate_direction * atan2(dy, dx);
						}
					}
					else if((brush->flags & (1 << CUSTOM_BRUSH_FLAG_ROTATE_BY_CURSOR)) != 0)
					{
						brush->angle = brush->start_angle + brush->rotate_direction * atan2(dy, dx);
					}
					else
					{
						brush->angle = brush->start_angle;
					}
					diff_x = brush->distance * dx/d, diff_y = brush->distance * dy/d;

					UpdateBrushMotionDrawArea(window, &area, core, brush->points[ref_point][1],
						brush->points[ref_point][2], draw_x, draw_y, r * 2, &brush->update);

					if(brush->draw_distance >= brush->distance)
					{
						dx = d;
						do
						{
							area.start_x = (int)(draw_x - r);
							area.start_y = (int)(draw_y - r);
							width = (int)(draw_x + r);
							height = (int)(draw_y + r);

							if(area.start_x < 0)
							{
								area.start_x = 0;
							}
							else if(area.start_x > window->work_layer->width)
							{
								goto skip_draw;
							}
							if(area.start_y < 0)
							{
								area.start_y = 0;
							}
							else if(area.start_y > window->work_layer->height)
							{
								goto skip_draw;
							}
							if(width > window->work_layer->width)
							{
								width = window->work_layer->width - area.start_x;
							}
							else
							{
								width = width - area.start_x;
							}
							if(height > window->work_layer->height)
							{
								height = window->work_layer->height - area.start_y;
							}
							else
							{
								height = height - area.start_y;
							}

							if(width < 0 || height < 0)
							{
								goto skip_draw;
							}

							stride = width*4;

							if((brush->flags & (1 << CUSTOM_BRUSH_FLAG_DRAW_ONLY_SCATTER)) == 0)
							{
								for(i=0; i<height; i++)
								{
									(void)memset(&window->mask_temp->pixels[(i+area.start_y)*window->mask_temp->stride+area.start_x*4],
										0, stride);
								}

								if(brush->brush_mode == CUSTOM_BRUSH_MODE_NORMAL)
								{
									if(brush->brush_shape == CUSTOM_BRUSH_SHAPE_CIRCLE)
									{
										DrawCircleBrushWorkLayer(window, core, draw_x - r, draw_y - r, width, height,
											&draw_pixel, zoom, alpha);
									}
									else
									{
										DrawImageBrushWorkLayer(window, core, draw_x, draw_y, width, height,
											zoom, r, brush->angle, brush->image_width, brush->image_height, &draw_pixel, alpha);
									}
									AdaptNormalBrush(window, draw_pixel, (int)width, (int)height,
										area.start_x, area.start_y, brush->flags & CUSTOM_BRUSH_FLAG_ANTI_ALIAS);
								}
								else
								{
									if(brush->brush_shape == CUSTOM_BRUSH_SHAPE_CIRCLE)
									{
										DrawCircleBrush(window, core, draw_x - r, draw_y - r, width, height,
											&draw_pixel, zoom, alpha, brush->blend_mode);
									}
									else
									{
										DrawImageBrush(window, core, draw_x, draw_y, width, height,
											zoom, r, brush->angle, brush->image_width, brush->image_height, &draw_pixel, alpha, brush->blend_mode);
									}

									switch(brush->brush_mode)
									{
									case CUSTOM_BRUSH_MODE_BLEND:
										AdaptBlendBrush(window, draw_pixel, (int)width, (int)height,
											area.start_x, area.start_y, brush->flags & (1 << CUSTOM_BRUSH_FLAG_ANTI_ALIAS), brush->blend_mode);
										break;
									case CUSTOM_BRUSH_MODE_SMUDGE:
										AdaptSmudge(window, area.start_x, area.start_y, width, height,
											brush->before_width, brush->before_height, draw_pixel, brush->extend, brush->draw_finished
										);
										brush->before_width = width;
										brush->before_height = height;
										break;
									case CUSTOM_BRUSH_MODE_PICKER:
										AdaptPickerBrush(window, draw_pixel, (int)area.width, (int)area.height,
											area.start_x, area.start_y, brush->flags & (1 << CUSTOM_BRUSH_FLAG_ANTI_ALIAS),
												brush->picker_mode, brush->blend_target, brush->picker_mode, brush->hue, brush->saturation, brush->brightness);
										break;
									case CUSTOM_BRUSH_MODE_WATER_BRUSH:
										BlendWaterBrush(window, core, draw_x, draw_y, brush->last_draw_x, brush->last_draw_y, r, area.start_x, area.start_y,
											(int)area.width, (int)area.height, window->work_layer->pixels, draw_pixel, brush->alpha, brush->before_color,
												brush->mix, brush->extend
										);
										brush->last_draw_x = draw_x;
										brush->last_draw_y = draw_y;
										break;
									}
								}
							}

							brush->angle += brush->rotate_speed;

							update_r = r * window->zoom_rate;
							update_x = ((draw_x-window->width/2)*window->cos_value + (draw_y-window->height/2)*window->sin_value) * window->zoom_rate
								+ window->rev_add_cursor_x;
							update_y = (- (draw_x-window->width/2)*window->sin_value + (draw_y-window->height/2)*window->cos_value) * window->zoom_rate
								+ window->rev_add_cursor_y;
							gtk_widget_queue_draw_area(window->window, (gint)(update_x-update_r), (gint)(update_y-update_r),
								(gint)(update_r * 2 + BRUSH_UPDATE_MARGIN), (gint)(update_r * 2 + BRUSH_UPDATE_MARGIN));

							if(brush->num_scatter > 0)
							{
								FLOAT_T range = brush->scatter_range * r * 10;
								FLOAT_T scatter_r;
								FLOAT_T size;
								FLOAT_T flow;
								FLOAT_T scatter_zoom;
								FLOAT_T scatter_x,	scatter_y;
								FLOAT_T direction;

								for(i=0; i<brush->num_scatter; i++)
								{
									direction = (rand() % 2 == 0) ? 1 : -1;
									scatter_x = ((FLOAT_T)rand() / RAND_MAX) * range * direction + draw_x;
									direction = (rand() % 2 == 0) ? 1 : -1;
									scatter_y = ((FLOAT_T)rand() / RAND_MAX) * range * direction + draw_y;
									scatter_zoom = (1 - (((FLOAT_T)rand() / RAND_MAX) * brush->scatter_random_size)) * brush->scatter_size;
									scatter_r = scatter_zoom * r;
									size = scatter_zoom * r;
									flow = (1 - ((FLOAT_T)rand() / RAND_MAX) * brush->scatter_random_flow) * alpha;

									UpdateBrushScatterDrawArea(window, &area, core, scatter_x, scatter_y, size, &brush->update);

									// 通常のブラシとして扱う場合
									if(brush->brush_mode == CUSTOM_BRUSH_MODE_NORMAL)
									{
										if(brush->brush_shape == CUSTOM_BRUSH_SHAPE_CIRCLE)
										{
											DrawCircleBrushWorkLayer(window, core, scatter_x - scatter_r, scatter_y - scatter_r, area.width,
												area.height, &draw_pixel, scatter_zoom, flow);
										}
										else
										{
											DrawImageBrushWorkLayer(window, core, scatter_x, scatter_y, area.width, area.height, scatter_zoom,
												scatter_r, brush->start_angle, brush->image_width, brush->image_height, &draw_pixel, flow);
										}
										AdaptNormalBrush(window, draw_pixel, (int)area.width, (int)area.height,
											area.start_x, area.start_y, brush->flags & (1 << CUSTOM_BRUSH_FLAG_ANTI_ALIAS));
									}
									else
									{
										if(brush->brush_shape == CUSTOM_BRUSH_SHAPE_CIRCLE)
										{
											DrawCircleBrush(window, core, scatter_x - scatter_r, scatter_y - scatter_r, area.width,
												area.height, &draw_pixel, scatter_zoom, flow, brush->blend_mode);
										}
										else
										{
											DrawImageBrush(window, core, scatter_x, scatter_y, area.width, area.height, scatter_zoom,
												scatter_r, brush->start_angle, brush->image_width, brush->image_height, &draw_pixel, flow, brush->blend_mode);
										}

										switch(brush->brush_mode)
										{
										case CUSTOM_BRUSH_MODE_BLEND:
											AdaptBlendBrush(window, draw_pixel, (int)area.width, (int)area.height,
												area.start_x, area.start_y, brush->flags & (1 << CUSTOM_BRUSH_FLAG_ANTI_ALIAS), brush->blend_mode);
											break;
										case CUSTOM_BRUSH_MODE_SMUDGE:
											AdaptSmudge(window, area.start_x, area.start_y, (int)area.width, (int)area.height,
												brush->before_width, brush->before_height, draw_pixel, brush->extend, brush->draw_finished
											);
											break;
										case CUSTOM_BRUSH_MODE_PICKER:
											AdaptPickerBrush(window, draw_pixel, (int)area.width, (int)area.height,
												area.start_x, area.start_y, brush->flags & (1 << CUSTOM_BRUSH_FLAG_ANTI_ALIAS),
													brush->picker_mode, brush->blend_target, brush->picker_mode, brush->hue, brush->saturation, brush->brightness);
											break;
										case CUSTOM_BRUSH_MODE_WATER_BRUSH:
											BlendWaterBrush(window, core, scatter_x, scatter_y, scatter_x, scatter_y, scatter_r, area.start_x, area.start_y,
												(int)area.width, (int)area.height, window->work_layer->pixels, draw_pixel, brush->alpha, brush->before_color,
													brush->mix, brush->extend
											);
											break;
										}
									}

									update_r = scatter_r * window->zoom_rate;
									update_x = ((scatter_x-window->width/2)*window->cos_value + (scatter_y-window->height/2)*window->sin_value) * window->zoom_rate
										+ window->rev_add_cursor_x;
									update_y = (- (scatter_x-window->width/2)*window->sin_value + (scatter_y-window->height/2)*window->cos_value) * window->zoom_rate
										+ window->rev_add_cursor_y;
									gtk_widget_queue_draw_area(window->window, (gint)(update_x-update_r), (gint)(update_y-update_r),
										(gint)(update_r * 2 + BRUSH_UPDATE_MARGIN), (gint)(update_r * 2 + BRUSH_UPDATE_MARGIN));
								}
							}

skip_draw:
							dx -= brush->distance;
							brush->remain_distance += brush->distance;
							brush->draw_distance -= brush->distance;
							if(/*brush->remain_distance > 0 ||*/ dx <= 0.0)
							{
								brush->points[ref_point][1] = draw_x;
								brush->points[ref_point][2] = draw_y;
								break;
							}
							else
							{
								draw_x += diff_x, draw_y += diff_y;
							}
						} while(1);
					}

					brush->finish_length += d;
					brush->travel += d;
					brush->draw_finished++;
					ref_point = brush->draw_finished % BRUSH_POINT_BUFFER_SIZE;
				}	// while(brush->sum_distance > brush->draw_start
						// && brush->draw_finished < brush->ref_point)
			}	// if(brush->sum_distance >= brush->draw_start
					// && brush->sum_distance >= brush->enter_length)
		}	// if(distance >= 1.0)

		window->flags |= DRAW_WINDOW_UPDATE_PART;
	}	// マウスの左ボタンが押されていたら
		// if(((*(GdkModifierType*)state) & GDK_BUTTON1_MASK) != 0)
}

#define CustomBrushEditSelectionMotion CustomBrushMotionCallBack

static void CustomBrushButtonReleaseCallBack(
	DRAW_WINDOW* window,
	FLOAT_T x,
	FLOAT_T y,
	FLOAT_T pressure,
	BRUSH_CORE *core,
	void* state
)
{
	// マウスの左ボタンなら
	if(((GdkEventButton*)state)->button == 1)
	{
		// ブラシの詳細情報にキャスト
		CUSTOM_BRUSH *brush = (CUSTOM_BRUSH*)core->brush_data;
		// ブラシの半径と不透明度
		FLOAT_T r, alpha;
		// 更新範囲
		BRUSH_UPDATE_INFO area;
		// X、Y方向の移動量
		FLOAT_T dx, dy;
		// ブラシの傾き用
		FLOAT_T diff_x, diff_y;
		// ブラシの移動量
		FLOAT_T d;
		// 描画を行う座標
		FLOAT_T draw_x, draw_y;
		// 画面更新を行う座標、範囲
		FLOAT_T update_x, update_y, update_r;
		// 入り、抜き時の色補正
		FLOAT_T enter_alpha, out_alpha;
		// 描画する幅、高さ、一行分のバイト数
		int width, height, stride;
		// 作業レイヤーの一行分のバイト数
		int layer_stride = window->work_layer->stride;
		// 作業レイヤーのピクセル
		uint8 *work_pixel = window->work_layer->pixels;
		// 画像の拡大率
		FLOAT_T zoom;
		// 画像の幅・高さの半分
		FLOAT_T half_width, half_height;
		// 参照ピクセル
		uint8 *draw_pixel;
		uint8 *mask_pixel = window->mask->pixels;
		// 配列のインデックス用
		int ref_point;
		int before_point;
		int i;	// for文用のカウンタ

		ref_point = brush->ref_point % BRUSH_POINT_BUFFER_SIZE;
		brush->points[ref_point][1] = x, brush->points[ref_point][2] = y;
		brush->ref_point++;

		while(brush->ref_point > brush->draw_finished)
		{
			ref_point = brush->draw_finished % BRUSH_POINT_BUFFER_SIZE;

			if(brush->finish_length < brush->enter_length)
			{
				enter_alpha = brush->finish_length / brush->enter_length;
				r = brush->enter_size + brush->finish_length * 0.25;
			}
			else
			{
				enter_alpha = 1;
				r = 1;
			}

			if((brush->flags & (1 << CUSTOM_BRUSH_FLAG_PRESSURE_SIZE)) != 0)
			{
				r *= brush->points[ref_point][3];
			}
			if((brush->flags & (1 << CUSTOM_BRUSH_FLAG_RANDOM_SIZE)) != 0)
			{
				r *= 1 - (brush->random_size * (rand() / (FLOAT_T)RAND_MAX));
			}
			if(r < MIN_BRUSH_STEP)
			{
				r = MIN_BRUSH_STEP;
			}

			if((brush->flags & (1 << CUSTOM_BRUSH_FLAG_RANDOM_ROTATE)) != 0)
			{
				brush->angle = (rand() / (FLOAT_T)RAND_MAX) * (2*G_PI);
			}

			zoom = r;
			half_width = brush->half_width * r;
			half_height = brush->half_height * r;
			//r *= (brush->brush_shape == CUSTOM_BRUSH_SHAPE_CIRCLE) ?
			//	brush->r * 0.5 : brush->r;
			r *= brush->r * 0.5;

			if(brush->sum_distance < brush->draw_start)
			{
				out_alpha = brush->sum_distance / brush->draw_start;
				r -= (brush->draw_start - brush->sum_distance) * 0.25;
			}
			else
			{
				out_alpha = 1;
			}

			if(r < 0.0)
			{
				brush->draw_finished++;
				continue;
			}

			alpha = ((brush->flags & (1 << CUSTOM_BRUSH_FLAG_PRESSURE_FLOW)) == 0)
				? 1 : brush->points[ref_point][3];
			alpha *= enter_alpha;

			before_point = (ref_point == 0) ? BRUSH_POINT_BUFFER_SIZE - 1 : ref_point - 1;
			d = brush->points[ref_point][0];
			if(d <= MIN_BRUSH_STEP)
			{
				brush->draw_finished++;
				continue;
			}
			brush->sum_distance -= d;
			if(brush->draw_finished == 0)
			{
				draw_x = brush->points[0][1], draw_y = brush->points[0][2];
			}
			else
			{
				draw_x = brush->points[before_point][1];
				draw_y = brush->points[before_point][2];
			}
			dx = brush->points[ref_point][1] - draw_x;
			dy = brush->points[ref_point][2] - draw_y;

			if((brush->flags & (1 << CUSTOM_BRUSH_FLAG_RANDOM_ROTATE)) != 0)
			{
				brush->angle = brush->start_angle +
					(rand() / (FLOAT_T)RAND_MAX) * brush->rotate_direction * brush->random_angle;
				if((brush->flags & (1 << CUSTOM_BRUSH_FLAG_ROTATE_BY_CURSOR)) != 0)
				{
					brush->angle += brush->rotate_direction * atan2(dy, dx);
				}
			}
			else if((brush->flags & (1 << CUSTOM_BRUSH_FLAG_ROTATE_BY_CURSOR)) != 0)
			{
				brush->angle = brush->start_angle + brush->rotate_direction * atan2(dy, dx);
			}
			else
			{
				brush->angle = brush->start_angle;
			}
			diff_x = dx/d, diff_y = dy/d;

			UpdateBrushMotionDrawArea(window, &area, core, brush->points[ref_point][1],
				brush->points[ref_point][2], draw_x, draw_y, r * 2, &brush->update);

			if(brush->draw_distance > brush->distance || brush->draw_finished == 0)
			{
				dx = d;
				do
				{
					area.start_x = (int)(draw_x - r);
					area.start_y = (int)(draw_y - r);
					width = (int)(draw_x + r);
					height = (int)(draw_y + r);

					if(area.start_x < 0)
					{
						area.start_x = 0;
					}
					else if(area.start_x > window->work_layer->width)
					{
						goto skip_draw;
					}
					if(area.start_y < 0)
					{
						area.start_y = 0;
					}
					else if(area.start_y > window->work_layer->height)
					{
						goto skip_draw;
					}
					if(width > window->work_layer->width)
					{
						width = window->work_layer->width - area.start_x;
					}
					else
					{
						width = width - area.start_x;
					}
					if(height > window->work_layer->height)
					{
						height = window->work_layer->height - area.start_y;
					}
					else
					{
						height = height - area.start_y;
					}

					if(width < 0 || height < 0)
					{
						goto skip_draw;
					}

					stride = width*4;

					if((brush->flags & (1 << CUSTOM_BRUSH_FLAG_DRAW_ONLY_SCATTER)) == 0)
					{
						for(i=0; i<height; i++)
						{
							(void)memset(&window->mask_temp->pixels[(i+area.start_y)*window->mask_temp->stride+area.start_x*4],
								0, stride);
						}

						if(brush->brush_mode == CUSTOM_BRUSH_MODE_NORMAL)
						{
							if(brush->brush_shape == CUSTOM_BRUSH_SHAPE_CIRCLE)
							{
								DrawCircleBrushWorkLayer(window, core, draw_x - r, draw_y - r, width, height,
									&draw_pixel, zoom, alpha);
							}
							else
							{
								DrawImageBrushWorkLayer(window, core, draw_x, draw_y, width, height,
									zoom, r, brush->angle, brush->image_width, brush->image_height, &draw_pixel, alpha);
							}
							AdaptNormalBrush(window, draw_pixel, (int)width, (int)height,
								area.start_x, area.start_y, brush->flags & CUSTOM_BRUSH_FLAG_ANTI_ALIAS);
						}
						else
						{
							if(brush->brush_shape == CUSTOM_BRUSH_SHAPE_CIRCLE)
							{
								DrawCircleBrush(window, core, draw_x - r, draw_y - r, width, height,
									&draw_pixel, zoom, alpha, brush->blend_mode);
							}
							else
							{
								DrawImageBrush(window, core, draw_x, draw_y, width, height,
									zoom, r, brush->angle, brush->image_width, brush->image_height, &draw_pixel, alpha, brush->blend_mode);
							}

							switch(brush->brush_mode)
							{
							case CUSTOM_BRUSH_MODE_BLEND:
								AdaptBlendBrush(window, draw_pixel, (int)width, (int)height,
									area.start_x, area.start_y, brush->flags & (1 << CUSTOM_BRUSH_FLAG_ANTI_ALIAS), brush->blend_mode);
								break;
							case CUSTOM_BRUSH_MODE_SMUDGE:
								AdaptSmudge(window, area.start_x, area.start_y, width, height,
									brush->before_width, brush->before_height, draw_pixel, brush->extend, brush->draw_finished
								);
								brush->before_width = width;
								brush->before_height = height;
								break;
							case CUSTOM_BRUSH_MODE_PICKER:
								AdaptPickerBrush(window, draw_pixel, (int)area.width, (int)area.height,
									area.start_x, area.start_y, brush->flags & (1 << CUSTOM_BRUSH_FLAG_ANTI_ALIAS),
										brush->picker_mode, brush->blend_target, brush->picker_mode, brush->hue, brush->saturation, brush->brightness);
								break;
							case CUSTOM_BRUSH_MODE_WATER_BRUSH:
								BlendWaterBrush(window, core, draw_x, draw_y, brush->last_draw_x, brush->last_draw_y, r, area.start_x, area.start_y,
									(int)area.width, (int)area.height, window->work_layer->pixels, draw_pixel, brush->alpha, brush->before_color,
										brush->mix, brush->extend
								);
								brush->last_draw_x = draw_x;
								brush->last_draw_y = draw_y;
								break;
							}
						}
					}

					brush->angle += brush->rotate_speed;

					update_r = r * window->zoom_rate;
					update_x = ((draw_x-window->width/2)*window->cos_value + (draw_y-window->height/2)*window->sin_value) * window->zoom_rate
						+ window->rev_add_cursor_x;
					update_y = (- (draw_x-window->width/2)*window->sin_value + (draw_y-window->height/2)*window->cos_value) * window->zoom_rate
						+ window->rev_add_cursor_y;
					gtk_widget_queue_draw_area(window->window, (gint)(update_x-update_r), (gint)(update_y-update_r),
						(gint)(update_r * 2 + BRUSH_UPDATE_MARGIN), (gint)(update_r * 2 + BRUSH_UPDATE_MARGIN));

					if(brush->num_scatter > 0)
					{
						FLOAT_T range = brush->scatter_range * r * 10;
						FLOAT_T scatter_r;
						FLOAT_T size;
						FLOAT_T flow;
						FLOAT_T scatter_zoom;
						FLOAT_T scatter_x,	scatter_y;
						FLOAT_T direction;

						for(i=0; i<brush->num_scatter; i++)
						{
							direction = (rand() % 2 == 0) ? 1 : -1;
							scatter_x = ((FLOAT_T)rand() / RAND_MAX) * range * direction + draw_x;
							direction = (rand() % 2 == 0) ? 1 : -1;
							scatter_y = ((FLOAT_T)rand() / RAND_MAX) * range * direction + draw_y;
							scatter_zoom = (1 - (((FLOAT_T)rand() / RAND_MAX) * brush->scatter_random_size)) * brush->scatter_size;
							scatter_r = scatter_zoom * r;
							size = scatter_zoom * r;
							flow = (1 - ((FLOAT_T)rand() / RAND_MAX) * brush->scatter_random_flow) * alpha;

							UpdateBrushScatterDrawArea(window, &area, core, scatter_x, scatter_y, size, &brush->update);

							// 通常のブラシとして扱う場合
							if(brush->brush_mode == CUSTOM_BRUSH_MODE_NORMAL)
							{
								if(brush->brush_shape == CUSTOM_BRUSH_SHAPE_CIRCLE)
								{
									DrawCircleBrushWorkLayer(window, core, scatter_x - scatter_r, scatter_y - scatter_r, area.width,
										area.height, &draw_pixel, scatter_zoom, flow);
								}
								else
								{
									DrawImageBrushWorkLayer(window, core, scatter_x, scatter_y, area.width, area.height, scatter_zoom,
										scatter_r, brush->start_angle, brush->image_width, brush->image_height, &draw_pixel, flow);
								}
								AdaptNormalBrush(window, draw_pixel, (int)area.width, (int)area.height,
									area.start_x, area.start_y, brush->flags & (1 << CUSTOM_BRUSH_FLAG_ANTI_ALIAS));
							}
							else
							{
								if(brush->brush_shape == CUSTOM_BRUSH_SHAPE_CIRCLE)
								{
									DrawCircleBrush(window, core, scatter_x - scatter_r, scatter_y - scatter_r, area.width,
										area.height, &draw_pixel, scatter_zoom, flow, brush->blend_mode);
								}
								else
								{
									DrawImageBrush(window, core, scatter_x, scatter_y, area.width, area.height, scatter_zoom,
										scatter_r, brush->start_angle, brush->image_width, brush->image_height, &draw_pixel, flow, brush->blend_mode);
								}

								switch(brush->brush_mode)
								{
								case CUSTOM_BRUSH_MODE_BLEND:
									AdaptBlendBrush(window, draw_pixel, (int)area.width, (int)area.height,
										area.start_x, area.start_y, brush->flags & (1 << CUSTOM_BRUSH_FLAG_ANTI_ALIAS), brush->blend_mode);
									break;
								case CUSTOM_BRUSH_MODE_SMUDGE:
									AdaptSmudge(window, area.start_x, area.start_y, (int)area.width, (int)area.height,
										brush->before_width, brush->before_height, draw_pixel, brush->extend, brush->draw_finished
									);
									break;
								case CUSTOM_BRUSH_MODE_PICKER:
									AdaptPickerBrush(window, draw_pixel, (int)area.width, (int)area.height,
										area.start_x, area.start_y, brush->flags & (1 << CUSTOM_BRUSH_FLAG_ANTI_ALIAS),
											brush->picker_mode, brush->blend_target, brush->picker_mode, brush->hue, brush->saturation, brush->brightness);
									break;
								case CUSTOM_BRUSH_MODE_WATER_BRUSH:
									BlendWaterBrush(window, core, scatter_x, scatter_y, scatter_x, scatter_y, scatter_r, area.start_x, area.start_y,
										(int)area.width, (int)area.height, window->work_layer->pixels, draw_pixel, brush->alpha, brush->before_color,
											brush->mix, brush->extend
									);
									break;
								}
							}

							update_r = scatter_r * window->zoom_rate;
							update_x = ((scatter_x-window->width/2)*window->cos_value + (scatter_y-window->height/2)*window->sin_value) * window->zoom_rate
								+ window->rev_add_cursor_x;
							update_y = (- (scatter_x-window->width/2)*window->sin_value + (scatter_y-window->height/2)*window->cos_value) * window->zoom_rate
								+ window->rev_add_cursor_y;
							gtk_widget_queue_draw_area(window->window, (gint)(update_x-update_r), (gint)(update_y-update_r),
								(gint)(update_r * 2 + BRUSH_UPDATE_MARGIN), (gint)(update_r * 2 + BRUSH_UPDATE_MARGIN));
						}
					}

skip_draw:
					dx -= brush->distance;
					brush->draw_distance -= brush->distance;
					if(dx < brush->distance)
					{
						break;
					}
					else
					{
						draw_x += diff_x, draw_y += diff_y;
					}
				} while(1);
			}

			brush->finish_length += d;
			brush->travel += d;
			brush->draw_finished++;
			ref_point = brush->draw_finished % BRUSH_POINT_BUFFER_SIZE;
		}	// while(brush->ref_point > brush->draw_finished)

		AddBrushHistory(core, window->active_layer);

		window->update.x = brush->update.min_x;
		window->update.y = brush->update.min_y;
		window->update.width = brush->update.max_x - brush->update.min_x;
		window->update.height = brush->update.max_y - brush->update.min_y;
		window->update.surface_p = cairo_surface_create_for_rectangle(
			window->active_layer->surface_p, window->update.x, window->update.y,
				window->update.width, window->update.height);
		window->update.cairo_p = cairo_create(window->update.surface_p);
		window->part_layer_blend_functions[window->work_layer->layer_mode](window->work_layer, &window->update);
		cairo_destroy(window->update.cairo_p);
		cairo_surface_destroy(window->update.surface_p);

		(void)memset(window->work_layer->pixels, 0, window->pixel_buf_size);

		window->work_layer->layer_mode = LAYER_BLEND_NORMAL;

		brush->angle= brush->start_angle;

		window->flags |= DRAW_WINDOW_UPDATE_PART;
	}	// マウスの左ボタンなら
		// if(((GdkEventButton*)state)->button == 1)
}

static void CustomBrushEditSelectionRelease(
	DRAW_WINDOW* window,
	FLOAT_T x,
	FLOAT_T y,
	FLOAT_T pressure,
	BRUSH_CORE* core,
	void* state
)
{
	// マウスの左ボタンなら
	if(((GdkEventButton*)state)->button == 1)
	{
		// ブラシの詳細情報にキャスト
		CUSTOM_BRUSH *brush = (CUSTOM_BRUSH*)core->brush_data;
		// ブラシの半径と不透明度
		FLOAT_T r, alpha;
		// 更新範囲
		BRUSH_UPDATE_INFO area;
		// X、Y方向の移動量
		FLOAT_T dx, dy;
		// ブラシの傾き用
		FLOAT_T diff_x, diff_y;
		// ブラシの移動量
		FLOAT_T d;
		// 描画を行う座標
		FLOAT_T draw_x, draw_y;
		// 画面更新を行う座標、範囲
		FLOAT_T update_x, update_y, update_r;
		// 入り、抜き時の色補正
		FLOAT_T enter_alpha, out_alpha;
		// 描画する幅、高さ、一行分のバイト数
		int width, height, stride;
		// 作業レイヤーの一行分のバイト数
		int layer_stride = window->work_layer->stride;
		// 作業レイヤーのピクセル
		uint8 *work_pixel = window->work_layer->pixels;
		// 画像の拡大率
		FLOAT_T zoom;
		// 画像の幅・高さの半分
		FLOAT_T half_width, half_height;
		// 参照ピクセル
		uint8 *draw_pixel;
		uint8 *mask_pixel = window->mask->pixels;
		// 配列のインデックス用
		int ref_point;
		int before_point;
		int i;	// for文用のカウンタ

		ref_point = brush->ref_point % BRUSH_POINT_BUFFER_SIZE;
		brush->points[ref_point][1] = x, brush->points[ref_point][2] = y;
		brush->ref_point++;

		while(brush->ref_point > brush->draw_finished)
		{
			ref_point = brush->draw_finished % BRUSH_POINT_BUFFER_SIZE;

			if(brush->finish_length < brush->enter_length)
			{
				enter_alpha = brush->finish_length / brush->enter_length;
				r = brush->enter_size + brush->finish_length * 0.25;
			}
			else
			{
				enter_alpha = 1;
				r = 1;
			}

			if((brush->flags & (1 << CUSTOM_BRUSH_FLAG_PRESSURE_SIZE)) != 0)
			{
				r *= brush->points[ref_point][3];
			}
			if((brush->flags & (1 << CUSTOM_BRUSH_FLAG_RANDOM_SIZE)) != 0)
			{
				r *= 1 - (brush->random_size * (rand() / (FLOAT_T)RAND_MAX));
			}
			if(r < MIN_BRUSH_STEP)
			{
				r = MIN_BRUSH_STEP;
			}

			if((brush->flags & (1 << CUSTOM_BRUSH_FLAG_RANDOM_ROTATE)) != 0)
			{
				brush->angle = (rand() / (FLOAT_T)RAND_MAX) * (2*G_PI);
			}

			zoom = r;
			half_width = brush->half_width * r;
			half_height = brush->half_height * r;
			//r *= (brush->brush_shape == CUSTOM_BRUSH_SHAPE_CIRCLE) ?
			//	brush->r * 0.5 : brush->r;
			r *= brush->r * 0.5;

			if(brush->sum_distance < brush->draw_start)
			{
				out_alpha = brush->sum_distance / brush->draw_start;
				r -= (brush->draw_start - brush->sum_distance) * 0.25;
			}
			else
			{
				out_alpha = 1;
			}

			if(r < 0.0)
			{
				brush->draw_finished++;
				continue;
			}

			alpha = ((brush->flags & (1 << CUSTOM_BRUSH_FLAG_PRESSURE_FLOW)) == 0)
				? 1 : brush->points[ref_point][3];
			alpha *= enter_alpha;

			before_point = (ref_point == 0) ? BRUSH_POINT_BUFFER_SIZE - 1 : ref_point - 1;
			d = brush->points[ref_point][0];
			brush->sum_distance -= d;
			if(brush->draw_finished == 0)
			{
				draw_x = brush->points[0][1], draw_y = brush->points[0][2];
			}
			else
			{
				draw_x = brush->points[before_point][1];
				draw_y = brush->points[before_point][2];
			}
			dx = brush->points[ref_point][1] - draw_x;
			dy = brush->points[ref_point][2] - draw_y;

			if((brush->flags & (1 << CUSTOM_BRUSH_FLAG_RANDOM_ROTATE)) != 0)
			{
				brush->angle = brush->start_angle +
					(rand() / (FLOAT_T)RAND_MAX) * brush->rotate_direction * brush->random_angle;
				if((brush->flags & (1 << CUSTOM_BRUSH_FLAG_ROTATE_BY_CURSOR)) != 0)
				{
					brush->angle += brush->rotate_direction * atan2(dy, dx);
				}
			}
			else if((brush->flags & (1 << CUSTOM_BRUSH_FLAG_ROTATE_BY_CURSOR)) != 0)
			{
				brush->angle = brush->start_angle + brush->rotate_direction * atan2(dy, dx);
			}
			else
			{
				brush->angle = brush->start_angle;
			}
			diff_x = dx/d, diff_y = dy/d;

			UpdateBrushMotionDrawArea(window, &area, core, brush->points[ref_point][1],
				brush->points[ref_point][2], draw_x, draw_y, r, &brush->update);

			if(brush->draw_distance > brush->distance || brush->draw_finished == 0)
			{
				dx = d;
				do
				{
					area.start_x = (int)(draw_x - r);
					area.start_y = (int)(draw_y - r);
					width = (int)(draw_x + r);
					height = (int)(draw_y + r);

					if(area.start_x < 0)
					{
						area.start_x = 0;
					}
					else if(area.start_x > window->work_layer->width)
					{
						goto skip_draw;
					}
					if(area.start_y < 0)
					{
						area.start_y = 0;
					}
					else if(area.start_y > window->work_layer->height)
					{
						goto skip_draw;
					}
					if(width > window->work_layer->width)
					{
						width = window->work_layer->width - area.start_x;
					}
					else
					{
						width = width - area.start_x;
					}
					if(height > window->work_layer->height)
					{
						height = window->work_layer->height - area.start_y;
					}
					else
					{
						height = height - area.start_y;
					}

					if(width < 0 || height < 0)
					{
						goto skip_draw;
					}

					stride = width*4;

					for(i=0; i<height; i++)
					{
						(void)memset(&window->mask_temp->pixels[(i+area.start_y)*window->mask_temp->stride+area.start_x*4],
							0, stride);
					}

					if((brush->flags & (1 << CUSTOM_BRUSH_FLAG_DRAW_ONLY_SCATTER)) == 0)
					{
						if(brush->brush_mode == CUSTOM_BRUSH_MODE_NORMAL)
						{
							if(brush->brush_shape == CUSTOM_BRUSH_SHAPE_CIRCLE)
							{
								DrawCircleBrushWorkLayer(window, core, draw_x - r, draw_y - r, width, height,
									&draw_pixel, zoom, alpha);
							}
							else
							{
								DrawImageBrushWorkLayer(window, core, draw_x, draw_y, width, height,
									zoom, r, brush->angle, brush->image_width, brush->image_height, &draw_pixel, alpha);
							}
							AdaptNormalBrush(window, draw_pixel, (int)width, (int)height,
								area.start_x, area.start_y, brush->flags & CUSTOM_BRUSH_FLAG_ANTI_ALIAS);
						}
						else
						{
							if(brush->brush_shape == CUSTOM_BRUSH_SHAPE_CIRCLE)
							{
								DrawCircleBrush(window, core, draw_x - r, draw_y - r, width, height,
									&draw_pixel, zoom, alpha, brush->blend_mode);
							}
							else
							{
								DrawImageBrush(window, core, draw_x, draw_y, width, height,
									zoom, r, brush->angle, brush->image_width, brush->image_height, &draw_pixel, alpha, brush->blend_mode);
							}

							switch(brush->brush_mode)
							{
							case CUSTOM_BRUSH_MODE_BLEND:
								AdaptBlendBrush(window, draw_pixel, (int)width, (int)height,
									area.start_x, area.start_y, brush->flags & (1 << CUSTOM_BRUSH_FLAG_ANTI_ALIAS), brush->blend_mode);
								break;
							case CUSTOM_BRUSH_MODE_SMUDGE:
								AdaptSmudge(window, area.start_x, area.start_y, width, height,
									brush->before_width, brush->before_height, draw_pixel, brush->extend, brush->draw_finished
								);
								brush->before_width = width;
								brush->before_height = height;
								break;
							case CUSTOM_BRUSH_MODE_PICKER:
								AdaptPickerBrush(window, draw_pixel, (int)area.width, (int)area.height,
									area.start_x, area.start_y, brush->flags & (1 << CUSTOM_BRUSH_FLAG_ANTI_ALIAS),
										brush->picker_mode, brush->blend_target, brush->picker_mode, brush->hue, brush->saturation, brush->brightness);
								break;
							case CUSTOM_BRUSH_MODE_WATER_BRUSH:
								BlendWaterBrush(window, core, draw_x, draw_y, brush->last_draw_x, brush->last_draw_y, r, area.start_x, area.start_y,
									(int)area.width, (int)area.height, window->work_layer->pixels, draw_pixel, brush->alpha, brush->before_color,
										brush->mix, brush->extend
								);
								brush->last_draw_x = draw_x;
								brush->last_draw_y = draw_y;
								break;
							}
						}
					}

					update_r = r * window->zoom_rate;
					update_x = ((draw_x-window->width/2)*window->cos_value + (draw_y-window->height/2)*window->sin_value) * window->zoom_rate
						+ window->rev_add_cursor_x;
					update_y = (- (draw_x-window->width/2)*window->sin_value + (draw_y-window->height/2)*window->cos_value) * window->zoom_rate
						+ window->rev_add_cursor_y;
					gtk_widget_queue_draw_area(window->window, (gint)(update_x-update_r), (gint)(update_y-update_r),
						(gint)(update_r * 2 + BRUSH_UPDATE_MARGIN), (gint)(update_r * 2 + BRUSH_UPDATE_MARGIN));

					if(brush->num_scatter > 0)
					{
						FLOAT_T range = brush->scatter_range * r * 10;
						FLOAT_T scatter_r;
						FLOAT_T size;
						FLOAT_T flow;
						FLOAT_T scatter_zoom;
						FLOAT_T scatter_x,	scatter_y;
						FLOAT_T direction;

						for(i=0; i<brush->num_scatter; i++)
						{
							direction = (rand() % 2 == 0) ? 1 : -1;
							scatter_x = ((FLOAT_T)rand() / RAND_MAX) * range * direction + draw_x;
							direction = (rand() % 2 == 0) ? 1 : -1;
							scatter_y = ((FLOAT_T)rand() / RAND_MAX) * range * direction + draw_y;
							scatter_zoom = (1 - (((FLOAT_T)rand() / RAND_MAX) * brush->scatter_random_size)) * brush->scatter_size;
							scatter_r = scatter_zoom * r;
							size = scatter_zoom * r;
							flow = (1 - ((FLOAT_T)rand() / RAND_MAX) * brush->scatter_random_flow) * alpha;

							UpdateBrushScatterDrawArea(window, &area, core, scatter_x, scatter_y, size, &brush->update);

							// 通常のブラシとして扱う場合
							if(brush->brush_mode == CUSTOM_BRUSH_MODE_NORMAL)
							{
								if(brush->brush_shape == CUSTOM_BRUSH_SHAPE_CIRCLE)
								{
									DrawCircleBrushWorkLayer(window, core, scatter_x - scatter_r, scatter_y - scatter_r, area.width,
										area.height, &draw_pixel, scatter_zoom, flow);
								}
								else
								{
									DrawImageBrushWorkLayer(window, core, scatter_x, scatter_y, area.width, area.height, scatter_zoom,
										scatter_r, brush->start_angle, brush->image_width, brush->image_height, &draw_pixel, flow);
								}
								AdaptNormalBrush(window, draw_pixel, (int)area.width, (int)area.height,
									area.start_x, area.start_y, brush->flags & (1 << CUSTOM_BRUSH_FLAG_ANTI_ALIAS));
							}
							else
							{
								if(brush->brush_shape == CUSTOM_BRUSH_SHAPE_CIRCLE)
								{
									DrawCircleBrush(window, core, scatter_x - scatter_r, scatter_y - scatter_r, area.width,
										area.height, &draw_pixel, scatter_zoom, flow, brush->blend_mode);
								}
								else
								{
									DrawImageBrush(window, core, scatter_x, scatter_y, area.width, area.height, scatter_zoom,
										scatter_r, brush->start_angle, brush->image_width, brush->image_height, &draw_pixel, flow, brush->blend_mode);
								}

								switch(brush->brush_mode)
								{
								case CUSTOM_BRUSH_MODE_BLEND:
									AdaptBlendBrush(window, draw_pixel, (int)area.width, (int)area.height,
										area.start_x, area.start_y, brush->flags & (1 << CUSTOM_BRUSH_FLAG_ANTI_ALIAS), brush->blend_mode);
									break;
								case CUSTOM_BRUSH_MODE_SMUDGE:
									AdaptSmudge(window, area.start_x, area.start_y, (int)area.width, (int)area.height,
										brush->before_width, brush->before_height, draw_pixel, brush->extend, brush->draw_finished
									);
									break;
								case CUSTOM_BRUSH_MODE_PICKER:
									AdaptPickerBrush(window, draw_pixel, (int)area.width, (int)area.height,
										area.start_x, area.start_y, brush->flags & (1 << CUSTOM_BRUSH_FLAG_ANTI_ALIAS),
											brush->picker_mode, brush->blend_target, brush->picker_mode, brush->hue, brush->saturation, brush->brightness);
									break;
								case CUSTOM_BRUSH_MODE_WATER_BRUSH:
									BlendWaterBrush(window, core, scatter_x, scatter_y, scatter_x, scatter_y, scatter_r, area.start_x, area.start_y,
										(int)area.width, (int)area.height, window->work_layer->pixels, draw_pixel, brush->alpha, brush->before_color,
										brush->mix, brush->extend
									);
									break;
								}
							}

							update_r = scatter_r * window->zoom_rate;
							update_x = ((scatter_x-window->width/2)*window->cos_value + (scatter_y-window->height/2)*window->sin_value) * window->zoom_rate
								+ window->rev_add_cursor_x;
							update_y = (- (scatter_x-window->width/2)*window->sin_value + (scatter_y-window->height/2)*window->cos_value) * window->zoom_rate
								+ window->rev_add_cursor_y;
							gtk_widget_queue_draw_area(window->window, (gint)(update_x-update_r), (gint)(update_y-update_r),
								(gint)(update_r * 2 + BRUSH_UPDATE_MARGIN), (gint)(update_r * 2 + BRUSH_UPDATE_MARGIN));
						}
					}

skip_draw:
					dx -= brush->distance;
					brush->draw_distance -= brush->distance;
					if(dx < brush->distance)
					{
						break;
					}
					else
					{
						draw_x += diff_x, draw_y += diff_y;
					}
				} while(1);
			}

			brush->finish_length += d;
			brush->travel += d;
			brush->draw_finished++;
			ref_point = brush->draw_finished % BRUSH_POINT_BUFFER_SIZE;
		}	// while(brush->ref_point > brush->draw_finished)

		AddSelectionEditHistory(core, window->selection);

		g_blend_selection_funcs[window->selection->layer_mode](window->work_layer, window->selection);

		(void)memset(window->work_layer->pixels, 0, window->work_layer->stride*window->work_layer->height);

		window->work_layer->layer_mode = LAYER_BLEND_NORMAL;

		brush->angle = brush->start_angle;
	}	// マウスの左ボタンなら
		// if(((GdkEventButton*)state)->button == 1)
}

static void GetPolygonPoints(
	double (*points)[2],
	int num_vertices,
	double center_x,
	double center_y,
	double radius
)
{
	double radian;
	int i;

	for(i=0; i<num_vertices; i++)
	{
		radian = (90.0 + 360.0 / num_vertices * i) / 180.0 * G_PI;
		points[i][0] = center_x + (radius * cos(radian) + 0.5);
		points[i][1] = center_y - (radius * sin(radian) + 0.5);
	}
}

/*******************************************************
* CreateCustomBrushSurface関数                         *
* カスタムブラシ用のCAIROサーフェース作成              *
* 引数                                                 *
* brush		: カスタムブラシを管理する構造体のアドレス *
* rgb		: 現在の描画色                             *
* back_rgb	: 現在の背景色                             *
* is_cursor	: カーソル用のサーフェースか否か           *
* 返り値                                               *
*	作成したサーフェース                               *
*******************************************************/
static cairo_surface_t* CreateCustomBrushSurface(
	CUSTOM_BRUSH* brush,
	uint8 rgb[3],
	uint8 back_rgb[3],
	gboolean is_cursor
)
{
	// CAIROを使ってピクセルデータをサーフェースに
	cairo_t* cairo_p;
	// 返り値
	cairo_surface_t *surface_p;
	// パターンのピクセルデータサーフェース
	cairo_surface_t *image;
	// 作成するサーフェースの幅、高さ
	gint32 width, height;
	// ピクセルデータをコピーしない時のフラグ
	int no_copy_pixels = 0;
	// 濃度
	FLOAT_T flow = brush->alpha;
	// 作成するサーフェースのフォーマット
	cairo_format_t format =
		(brush->image_channel == 4) ? CAIRO_FORMAT_ARGB32 :
			(brush->image_channel == 3) ? CAIRO_FORMAT_RGB24 : CAIRO_FORMAT_A8;
	// パターンのマスク処理用ピクセルデータ
	uint8 *mask_pixel = NULL;
	// for文用のカウンタ
	int i, j, k;

	if(brush->brush_shape == CUSTOM_BRUSH_SHAPE_PATTERN
		|| brush->brush_shape == CUSTOM_BRUSH_SHAPE_IMAGE)
	{
		// 使用するパターン
		PATTERN *pattern;

		if(brush->pattern_id >= brush->core->app->stamps.num_pattern)
		{
			brush->pattern_id = 0;
		}
		pattern = &brush->core->app->stamps.patterns[brush->pattern_id];
		width = pattern->width;
		height = pattern->height;

		{
			size_t allocate_size =
				((width > brush->image_width) ? width : brush->image_width)
					* ((height > brush->image_height) ? height : brush->image_height) * 4;
			brush->brush_pixel = (uint8*)MEM_REALLOC_FUNC(brush->brush_pixel, allocate_size);
			brush->temp_pixel = (uint8*)MEM_REALLOC_FUNC(brush->temp_pixel, allocate_size);
		}

		if(brush->brush_shape == CUSTOM_BRUSH_SHAPE_PATTERN)
		{
			brush->image_pixel = (uint8*)MEM_REALLOC_FUNC(
				brush->image_pixel, pattern->width * pattern->stride);
			(void)memcpy(brush->image_pixel, pattern->pixels,
				pattern->width * pattern->stride);
			brush->image_width = width = pattern->width;
			brush->image_height = height = pattern->height;
			brush->image_channel = pattern->channel;
		}
		else
		{
			if(brush->image_path != NULL)
			{
				FILE *fp;
				char *system_path;
				char *utf8_path;

				if(brush->image_path[0] == '.' && brush->image_path[1] == '/')
				{
					utf8_path = g_build_filename(brush->core->app->current_path, &brush->image_path[2], NULL);
				}
				else
				{
					utf8_path = g_strdup(brush->image_path);
				}

				system_path = g_locale_from_utf8(utf8_path, -1, NULL, NULL, NULL);

				fp = fopen(system_path, "rb");
				if(fp != NULL)
				{
					gint32 stride;
					MEM_FREE_FUNC(brush->image_pixel);
					brush->image_pixel = ReadPNGStream((void*)fp, (stream_func_t)fread,
						&width, &height, &stride);
					brush->image_width = width;
					brush->image_height = height;
					brush->image_channel = stride / width;
					(void)fclose(fp);
				}
				else
				{
					brush->image_pixel = (uint8*)MEM_REALLOC_FUNC(
						brush->image_pixel, pattern->width * pattern->stride);
					(void)memcpy(brush->image_pixel, brush->core->app->stamps.active_pattern->pixels,
						pattern->width * pattern->stride);
					brush->image_width = width = pattern->width;
					brush->image_height = height = pattern->height;
					brush->image_channel = pattern->channel;
				}

				g_free(system_path);
				g_free(utf8_path);
			}
			else if(brush->image_pixel == NULL)
			{
				brush->image_pixel = (uint8*)MEM_REALLOC_FUNC(
					brush->image_pixel, pattern->width * pattern->stride);
				(void)memcpy(brush->image_pixel, brush->core->app->stamps.active_pattern->pixels,
					pattern->width * pattern->stride);
				brush->image_width = width = pattern->width;
				brush->image_height = height = pattern->height;
				brush->image_channel = pattern->channel;
			}
		}

		// 幅または高さ0なら終了
		if(width == 0 || height == 0)
		{
			return NULL;
		}

		// 左右反転
		if((brush->flags & (1 << CUSTOM_BRUSH_FLAG_IMAGE_FLIP_HORIZONTALLY)) != 0)
		{
			int stride = cairo_format_stride_for_width(format, brush->image_width);
			int row = (brush->image_channel <= 2) ? stride :
						stride / brush->image_channel;

			if(brush->image_channel == 2)
			{
				stride *= 2;
			}

			no_copy_pixels++;
			for(i=0; i<brush->image_height; i++)
			{
				for(j=0; j<brush->image_width; j++)
				{
					for(k=0; k<brush->image_channel; k++)
					{
						brush->brush_pixel[i*stride
							+j*brush->image_channel+k] =
								brush->image_pixel[i*stride
									+(brush->image_width-j-1)*brush->image_channel+k];
					}
				}
			}
		}
		// 上下反転
		if((brush->flags & (1 << CUSTOM_BRUSH_FLAG_IMAGE_FLIP_VERTICALLY)) != 0)
		{
			int stride = cairo_format_stride_for_width(format, brush->image_width);
			int row = (brush->image_channel <= 2) ? stride :
						stride / brush->image_channel;
			if(brush->image_channel == 2)
			{
				stride *= 2;
			}

			no_copy_pixels++;
			if((brush->flags & (1 << CUSTOM_BRUSH_FLAG_IMAGE_FLIP_HORIZONTALLY)) != 0)
			{
				for(i=0; i<brush->image_height; i++)
				{
					for(j=0; j<row; j++)
					{
						for(k=0; k<brush->image_channel; k++)
						{
							brush->temp_pixel[i*stride
								+j*brush->image_channel+k] =
									brush->image_pixel[(brush->image_height-i-1)*stride
										+j*brush->image_channel+k];
						}
					}
				}

				(void)memcpy(brush->brush_pixel, brush->temp_pixel,
					brush->image_width*brush->image_channel*brush->image_height);
			}
			else
			{
				for(i=0; i<brush->image_height; i++)
				{
					for(j=0; j<row; j++)
					{
						for(k=0; k<brush->image_channel; k++)
						{
							brush->brush_pixel[i*stride
								+j*brush->image_channel+k] =
								brush->image_pixel[(brush->image_height-i-1)*stride
									+j*brush->image_channel+k];
						}
					}
				}
			}
		}
		if(no_copy_pixels == 0)
		{
			(void)memcpy(brush->brush_pixel, brush->image_pixel,
				brush->image_width*brush->image_channel*brush->image_height);
		}

		// 返り値作成
		surface_p = cairo_image_surface_create(CAIRO_FORMAT_ARGB32, width, height);
		cairo_p = cairo_create(surface_p);

		// 無頼パターンのチャンネル数で処理切り替え
		switch(brush->image_channel)
		{
		case 1:	// チャンネル数1なら描画色で塗り潰してパターンでマスク
			// 不透明度設定
			for(i=0; i<brush->image_width*brush->image_channel*brush->image_height; i++)
			{
				brush->brush_pixel[i] = (uint8)(brush->image_pixel[i]*flow);
			}
			image = cairo_image_surface_create_for_data(brush->brush_pixel,
				format, width, height, cairo_format_stride_for_width(format, width));
			cairo_set_source_rgb(cairo_p, rgb[0]*DIV_PIXEL, rgb[1]*DIV_PIXEL, rgb[2]*DIV_PIXEL);
			cairo_rectangle(cairo_p, 0, 0, width, height);
			cairo_mask_surface(cairo_p, image, 0, 0);
			break;
		case 2:	// チャンネル数2ならモードによって処理切り替え
			{
				// 色設定用
				HSV hsv;
				uint8 color[3];
				// 画像のαチャンネルでマスクする
				cairo_surface_t* mask;
				// 1行分のバイト数
				int stride;

				mask_pixel = (uint8*)MEM_REALLOC_FUNC(
					mask_pixel, brush->image_width * brush->image_height * 4);

				// RGBをHSVに変換
#if defined(USE_BGR_COLOR_SPACE) && USE_BGR_COLOR_SPACE != 0
				if(brush->color_mode == PATTERN_MODE_FORE_TO_BACK)
				{
					color[0] = rgb[0], color[1] = rgb[1], color[2] = rgb[2];
				}
				else
				{
					color[0] = rgb[2], color[1] = rgb[1], color[2] = rgb[0];
				}
#else
				color[0] = rgb[0], color[1] = rgb[1], color[2] = rgb[2];
#endif
				RGB2HSV_Pixel(color, &hsv);

				stride = cairo_format_stride_for_width(CAIRO_FORMAT_A8, brush->image_width);

				// 不透明度設定
				for(i=0; i<brush->image_height; i++)
				{
					for(j=0; j<brush->image_width; j++)
					{
						mask_pixel[i*stride+j] =
							(uint8)(brush->image_pixel[i*stride*2+j*2+1]*flow);
					}
				}
		
				switch(brush->color_mode)
				{
				case PATTERN_MODE_SATURATION:	// 彩度でパターン作成
					for(i=0; i<brush->image_height; i++)
					{
						for(j=0; j<brush->image_width; j++)
						{
							hsv.s = 0xff - brush->image_pixel[i*stride*2+j*2];
							HSV2RGB_Pixel(&hsv, &brush->temp_pixel[i*brush->image_width*4+j*4]);
							brush->temp_pixel[i*brush->image_width*4+j*4+3] = 0xff;
						}
					}
					break;
				case PATTERN_MODE_BRIGHTNESS:	// 明度でパターン作成
					for(i=0; i<brush->image_height; i++)
					{
						for(j=0; j<brush->image_width; j++)
						{
							hsv.v = 0xff - brush->image_pixel[i*stride*2+j*2];
							HSV2RGB_Pixel(&hsv, &brush->temp_pixel[i*brush->image_width*4+j*4]);
							brush->temp_pixel[i*brush->image_width*4+j*4+3] = 0xff;
						}
					}
					break;
				case PATTERN_MODE_FORE_TO_BACK:	// 描画色から背景色へ
					for(i=0; i<brush->image_height; i++)
					{
						for(j=0; j<brush->image_width; j++)
						{
#if defined(USE_BGR_COLOR_SPACE) && USE_BGR_COLOR_SPACE != 0
							brush->temp_pixel[i*brush->image_width*4+j*4+2] = ((brush->image_pixel[i*stride*2+j*2]+1)*color[0] +
								(0xff - brush->image_pixel[i*stride*2+j*2]+1)*back_rgb[0]) >> 8;
							brush->temp_pixel[i*brush->image_width*4+j*4+1] = ((brush->image_pixel[i*stride*2+j*2]+1)*color[1] +
								(0xff - brush->image_pixel[i*stride*2+j*2]+1)*back_rgb[1]) >> 8;
							brush->temp_pixel[i*brush->image_width*4+j*4] = ((brush->image_pixel[i*stride*2+j*2]+1)*color[2] +
								(0xff - brush->image_pixel[i*stride*2+j*2]+1)*back_rgb[2]) >> 8;
#else
							brush->temp_pixel[i*brush->image_width*4+j*4] = ((brush->image_pixel[i*stride*2+j*2]+1)*color[0] +
								(0xff - brush->image_pixel[i*stride*2+j*2]+1)*back_rgb[0]) >> 8;
							brush->temp_pixel[i*brush->image_width*4+j*4+1] = ((brush->image_pixel[i*stride*2+j*2]+1)*color[1] +
								(0xff - brush->image_pixel[i*stride*2+j*2]+1)*back_rgb[1]) >> 8;
							brush->temp_pixel[i*brush->image_width*4+j*4+2] = ((brush->image_pixel[i*stride*2+j*2]+1)*color[2] +
								(0xff - brush->image_pixel[i*stride*2+j*2]+1)*back_rgb[2]) >> 8;
#endif
							brush->temp_pixel[i*brush->image_width*4+j*4+3] = 0xff;
						}
					}
					break;
				}
				mask = cairo_image_surface_create_for_data(mask_pixel, format,
					brush->image_width, brush->image_height, stride);
				image = cairo_image_surface_create_for_data(brush->temp_pixel, CAIRO_FORMAT_ARGB32,
					brush->image_width, brush->image_height, brush->image_width*4);
				cairo_set_source_surface(cairo_p, image, 0, 0);
				cairo_mask_surface(cairo_p, mask, 0, 0);
				cairo_surface_destroy(mask);
			}
			break;
		default:
			image = cairo_image_surface_create_for_data(brush->image_pixel,
				format, brush->image_width, brush->image_height, cairo_format_stride_for_width(format, brush->image_width));
			cairo_set_source_surface(cairo_p, image, 0, 0);
			cairo_paint_with_alpha(cairo_p, flow);
		}

		if(is_cursor == FALSE && brush->blur > 0 && brush->outline_hardness < 1)
		{
			uint8 *target_pixel = cairo_image_surface_get_data(surface_p);

			if(target_pixel != NULL)
			{
				uint8 *temp_pixel = (uint8*)MEM_ALLOC_FUNC(width * height * 4);
				cairo_surface_t *mask_surface = cairo_image_surface_create(CAIRO_FORMAT_ARGB32, width, height);
				cairo_t *mask_cairo = cairo_create(mask_surface);
				cairo_surface_t *temp_surface;
				cairo_pattern_t *pattern;
				FLOAT_T radius = brush->r * 0.5;

				(void)memcpy(temp_pixel, target_pixel, width * height * 4);
				(void)memset(target_pixel, 0, width * height * 4);

				pattern = cairo_pattern_create_radial(radius, radius,
					0, radius, radius, radius);
				cairo_pattern_add_color_stop_rgba(pattern, 0,
					1, 1, 1, 1);
				cairo_pattern_add_color_stop_rgba(pattern, 1-brush->blur,
					1, 1, 1, 1);
				cairo_pattern_add_color_stop_rgba(pattern, 1,
					1, 1, 1, brush->outline_hardness);
				if(width >= height)
				{
					cairo_scale(mask_cairo, 1, (FLOAT_T)height / width);
				}
				else
				{
					cairo_scale(mask_cairo, (FLOAT_T)width / height, 1);
				}

				cairo_set_source(mask_cairo, pattern);
				cairo_paint(mask_cairo);

				temp_surface = cairo_image_surface_create_for_data(temp_pixel,
					CAIRO_FORMAT_ARGB32, width, height, width * 4);

				cairo_set_source_surface(cairo_p, temp_surface, 0, 0);
				cairo_mask_surface(cairo_p, mask_surface, 0, 0);

				cairo_surface_destroy(temp_surface);
				cairo_pattern_destroy(pattern);
				cairo_destroy(mask_cairo);
				cairo_surface_destroy(mask_surface);
				MEM_FREE_FUNC(temp_pixel);
			}
		}

		// 不要になったデータを削除
		MEM_FREE_FUNC(mask_pixel);
		cairo_surface_destroy(image);

		if(brush->scale != 100.0 || brush->image_width != brush->image_height)
		{
			FLOAT_T zoom = brush->scale * 0.01;
			FLOAT_T rev_zoom = 1 / zoom;
			cairo_t *scale_cairo;
			cairo_matrix_t scale_matrix;
			cairo_pattern_t *scale_pattern;
			int src_width = brush->image_width, src_height = brush->image_height,
				src_channel = brush->image_channel;
			if(src_width > src_height)
			{
				brush->image_width = brush->image_height = (int)(src_width * zoom + 0.9);
				cairo_matrix_init_translate(&scale_matrix, (src_width - src_height) * zoom, 0);
			}
			else
			{
				brush->image_width = brush->image_height = (int)(src_height * zoom + 0.9);
				cairo_matrix_init_translate(&scale_matrix, 0, (src_height - src_width) * zoom);
			}
			cairo_matrix_scale(&scale_matrix, rev_zoom, rev_zoom);
			brush->r = brush->image_width;
			brush->half_width = brush->half_height = brush->r * 0.5;
			image = surface_p;
			surface_p = cairo_image_surface_create(CAIRO_FORMAT_ARGB32, brush->image_width, brush->image_height);
			scale_cairo = cairo_create(surface_p);

			scale_pattern = cairo_pattern_create_for_surface(image);
			cairo_pattern_set_matrix(scale_pattern, &scale_matrix);
			cairo_set_source(scale_cairo, scale_pattern);
			cairo_paint(scale_cairo);

			cairo_pattern_destroy(scale_pattern);
			cairo_destroy(scale_cairo);
			cairo_surface_destroy(image);
		}
		else
		{
			brush->r = brush->image_width;
			brush->half_width = brush->half_height = brush->r * 0.5;
		}
	}
	else
	{
		cairo_pattern_t *pattern;
		FLOAT_T radius = brush->r * 0.5;

		brush->image_width = width = (int)brush->r;
		brush->image_height = height = (int)brush->r;

		switch(brush->brush_shape)
		{
		case CUSTOM_BRUSH_SHAPE_CIRCLE:
			if(is_cursor == FALSE)
			{
				width = brush->image_width,	height = brush->image_height;
				surface_p = cairo_image_surface_create(CAIRO_FORMAT_ARGB32, width, height);
				cairo_p = cairo_create(surface_p);

				pattern = cairo_pattern_create_radial(radius, radius,
					0, radius, radius, radius);
				cairo_pattern_add_color_stop_rgba(pattern, 0,
					rgb[0] * DIV_PIXEL, rgb[1] * DIV_PIXEL, rgb[2] * DIV_PIXEL, 1);
				cairo_pattern_add_color_stop_rgba(pattern, 1-brush->blur,
					rgb[0] * DIV_PIXEL, rgb[1] * DIV_PIXEL, rgb[2] * DIV_PIXEL, 1);
				cairo_pattern_add_color_stop_rgba(pattern, 1,
					rgb[0] * DIV_PIXEL, rgb[1] * DIV_PIXEL, rgb[2] * DIV_PIXEL, brush->outline_hardness);

				cairo_set_source(cairo_p, pattern);
				cairo_arc(cairo_p, radius, radius, radius, 0, 2 * G_PI);
				cairo_fill(cairo_p);

				cairo_pattern_destroy(pattern);
			}
			else
			{
				surface_p = cairo_image_surface_create(CAIRO_FORMAT_ARGB32, width, height);
				cairo_p = cairo_create(surface_p);
				cairo_arc(cairo_p, radius, radius, radius, 0, 2*G_PI);
				cairo_set_line_width(cairo_p, 1);
				cairo_stroke(cairo_p);
			}
			break;
		case CUSTOM_BRUSH_SHAPE_TRIANGLE:
			surface_p = cairo_image_surface_create(CAIRO_FORMAT_ARGB32, width, height);
			cairo_p = cairo_create(surface_p);
			cairo_set_source_rgb(cairo_p, rgb[0] * DIV_PIXEL, rgb[1] * DIV_PIXEL, rgb[2] * DIV_PIXEL);
			cairo_move_to(cairo_p, radius, 0);
			cairo_line_to(cairo_p, 0, brush->r);
			cairo_line_to(cairo_p, brush->r, brush->r);
			cairo_close_path(cairo_p);
			if(is_cursor == FALSE)
			{
				cairo_fill(cairo_p);
			}
			else
			{
				cairo_set_line_width(cairo_p, 1);
				cairo_stroke(cairo_p);
			}
			break;
		case CUSTOM_BRUSH_SHAPE_SQUARE:
			surface_p = cairo_image_surface_create(CAIRO_FORMAT_ARGB32, width, height);
			cairo_p = cairo_create(surface_p);
			cairo_set_source_rgb(cairo_p, rgb[0] * DIV_PIXEL, rgb[1] * DIV_PIXEL, rgb[2] * DIV_PIXEL);
			cairo_move_to(cairo_p, 0, 0);
			cairo_line_to(cairo_p, 0, brush->r);
			cairo_line_to(cairo_p, brush->r, brush->r);
			cairo_line_to(cairo_p, brush->r, 0);
			cairo_close_path(cairo_p);
			if(is_cursor == FALSE)
			{
				cairo_fill(cairo_p);
			}
			else
			{
				cairo_set_line_width(cairo_p, 1);
				cairo_stroke(cairo_p);
			}
			break;
		case CUSTOM_BRUSH_SHAPE_HEXIAGON:
			{
				double root3 = sqrt(3.0);
				surface_p = cairo_image_surface_create(CAIRO_FORMAT_ARGB32, width, height);
				cairo_p = cairo_create(surface_p);
				cairo_set_source_rgb(cairo_p, rgb[0] * DIV_PIXEL, rgb[1] * DIV_PIXEL, rgb[2] * DIV_PIXEL);
				cairo_move_to(cairo_p, radius, 0);
				cairo_line_to(cairo_p, radius - root3 * brush->r * 0.25, brush->r * 0.25);
				cairo_line_to(cairo_p, radius - root3 * brush->r * 0.25, (brush->r * 0.25) * 3.0);
				cairo_line_to(cairo_p, radius, brush->r);
				cairo_line_to(cairo_p, radius + root3 * brush->r * 0.25, (brush->r * 0.25) * 3.0);
				cairo_line_to(cairo_p, radius + root3 * brush->r * 0.25, brush->r * 0.25);
				cairo_close_path(cairo_p);
				if(is_cursor == FALSE)
				{
					cairo_fill(cairo_p);
				}
				else
				{
					cairo_set_line_width(cairo_p, 1);
					cairo_stroke(cairo_p);
				}
			}
			break;
		case CUSTOM_BRUSH_SHAPE_STAR:
			{
				double points[5][2];
				surface_p = cairo_image_surface_create(CAIRO_FORMAT_ARGB32, width, height);
				cairo_p = cairo_create(surface_p);
				GetPolygonPoints(points, 5, radius, radius, radius);
				cairo_set_source_rgb(cairo_p, rgb[0] * DIV_PIXEL, rgb[1] * DIV_PIXEL, rgb[2] * DIV_PIXEL);
				cairo_move_to(cairo_p, points[0][0], points[0][1]);
				for(i=1; i<5; i++)
				{
					cairo_line_to(cairo_p, points[(i*2)%5][0], points[(i*2)%5][1]);
				}
				if(is_cursor == FALSE)
				{
					cairo_fill(cairo_p);
				}
				else
				{
					int cursor_width = cairo_image_surface_get_width(surface_p);
					int cursor_height = cairo_image_surface_get_height(surface_p);
					int cursor_stride = cairo_image_surface_get_stride(surface_p);
					int length = cursor_width * cursor_height;
					uint8 *cursor_pixels = cairo_image_surface_get_data(surface_p);
					uint8 *temp_pixels = (uint8*)MEM_ALLOC_FUNC(length);
					cairo_fill(cairo_p);

					for(i=0; i<length; i++)
					{
						temp_pixels[i] = cursor_pixels[i*4+3];
					}
					LaplacianFilter(temp_pixels, cursor_width, cursor_height,
						cursor_width, cursor_pixels);
					(void)memcpy(temp_pixels, cursor_pixels, length);
					for(i=0; i<length; i++)
					{
						cursor_pixels[i*4+3] = temp_pixels[i];
					}

					MEM_FREE_FUNC(temp_pixels);
				}
			}
			break;
		}

		if(is_cursor == FALSE && brush->blur > 0
			&& brush->outline_hardness < 1 && brush->brush_shape != CUSTOM_BRUSH_SHAPE_CIRCLE)
		{
			uint8 *target_pixel = cairo_image_surface_get_data(surface_p);

			if(target_pixel != NULL)
			{
				uint8 *temp_pixel = (uint8*)MEM_ALLOC_FUNC(width * height * 4);
				cairo_surface_t *mask_surface = cairo_image_surface_create(CAIRO_FORMAT_ARGB32, width, height);
				cairo_t *mask_cairo = cairo_create(mask_surface);
				cairo_surface_t *temp_surface;
				cairo_pattern_t *pattern;
				FLOAT_T radius = brush->r * 0.5;

				(void)memcpy(temp_pixel, target_pixel, width * height * 4);
				(void)memset(target_pixel, 0, width * height * 4);

				pattern = cairo_pattern_create_radial(radius, radius,
					0, radius, radius, radius);
				cairo_pattern_add_color_stop_rgba(pattern, 0,
					1, 1, 1, 1);
				cairo_pattern_add_color_stop_rgba(pattern, 1-brush->blur,
					1, 1, 1, 1);
				cairo_pattern_add_color_stop_rgba(pattern, 1,
					1, 1, 1, brush->outline_hardness);
				if(width >= height)
				{
					cairo_scale(mask_cairo, 1, (FLOAT_T)height / width);
				}
				else
				{
					cairo_scale(mask_cairo, (FLOAT_T)width / height, 1);
				}

				cairo_set_source(mask_cairo, pattern);
				cairo_paint(mask_cairo);

				temp_surface = cairo_image_surface_create_for_data(temp_pixel,
					CAIRO_FORMAT_ARGB32, width, height, width * 4);

				cairo_set_source_surface(cairo_p, temp_surface, 0, 0);
				cairo_mask_surface(cairo_p, mask_surface, 0, 0);

				cairo_surface_destroy(temp_surface);
				cairo_pattern_destroy(pattern);
				cairo_destroy(mask_cairo);
				cairo_surface_destroy(mask_surface);
				MEM_FREE_FUNC(temp_pixel);
			}
		}
	}

	cairo_destroy(cairo_p);

	return surface_p;
}

/*****************************************
* CustomBrushDrawCursor関数              *
* カスタムブラシのカーソルを描画         *
* 引数                                   *
* window	: 描画領域の情報             *
* x			: カーソルのX座標            *
* y			: カーソルのY座標            *
* brush		: ブラシの詳細情報           *
*****************************************/
static void CustomBrushDrawCursor(
	DRAW_WINDOW* window,
	FLOAT_T x,
	FLOAT_T y,
	CUSTOM_BRUSH* brush
)
{
	// カーソルパターン
	cairo_pattern_t* pattern;
	// カーソルの拡大縮小、回転・平行移動用の行列
	cairo_matrix_t matrix;
	// カーソルの平行・回転移動用
	FLOAT_T trans_x, trans_y;
	FLOAT_T cos_value, sin_value;
	FLOAT_T half_width, half_height;
	FLOAT_T rev_zoom = window->rev_zoom;

	// 平行移動する座標を計算
	half_width = brush->half_width * window->zoom_rate;
	half_height = brush->half_height * window->zoom_rate;
	cos_value = cos(brush->angle), sin_value = sin(brush->angle);
	trans_x = x - (half_width * cos_value + half_height * sin_value);
	trans_y = y + (half_width * sin_value - half_height * cos_value);
	// 拡大縮小率、回転角をセット
	pattern = cairo_pattern_create_for_surface(brush->cursor_surface);
	cairo_pattern_set_extend(pattern, CAIRO_EXTEND_NONE);
	cairo_matrix_init_scale(&matrix, rev_zoom, rev_zoom);
	cairo_matrix_rotate(&matrix, brush->angle);
	cairo_matrix_translate(&matrix, - trans_x, - trans_y);
	cairo_pattern_set_matrix(pattern, &matrix);

	cairo_set_source_rgb(window->disp_temp->cairo_p, 1, 1, 1);
	cairo_mask(window->disp_temp->cairo_p, pattern);

	cairo_rectangle(window->disp_layer->cairo_p, (int)(x - half_width - 1),
		(int)(y - half_height - 1), (int)half_width*2+2, (int)half_height*2+2);
	cairo_clip(window->disp_layer->cairo_p);

	cairo_pattern_destroy(pattern);
}

static void CustomBrushButtonUpdate(DRAW_WINDOW* window, FLOAT_T x, FLOAT_T y, CUSTOM_BRUSH* brush)
{
	FLOAT_T r;

	if(brush->half_width > brush->half_height)
	{
		r = brush->half_width * 2 * window->zoom_rate + 1;
	}
	else
	{
		r = brush->half_height * 2 * window->zoom_rate + 1;
	}

	gtk_widget_queue_draw_area(window->window, (gint)(x - r - 1),
		(gint)(y - r - 1), (gint)(r * 2) + 2, (gint)(r * 2) + 2);
}

static void CustomBrushMotionUpdate(DRAW_WINDOW* window, FLOAT_T x, FLOAT_T y, CUSTOM_BRUSH* brush)
{
	FLOAT_T start_x, start_y;
	FLOAT_T width, height;
	FLOAT_T r;
	FLOAT_T enter = (brush->enter_length + brush->draw_start) * window->zoom_rate;

	if(brush->half_width > brush->half_height)
	{
		r = brush->half_width * 2 * window->zoom_rate + 1;
	}
	else
	{
		r = brush->half_height * 2 * window->zoom_rate + 1;
	}

	if(window->before_cursor_x < x)
	{
		start_x = window->before_cursor_x - r;
		width = r * 2 + (x - window->before_cursor_x) * r;
	}
	else
	{
		start_x = x - r;
		width = r * 2 + (window->before_cursor_x - x) * r;
	}

	if(window->before_cursor_y < y)
	{
		start_y = window->before_cursor_y - r;
		height = r * 2 + (y - window->before_cursor_y) * r;
	}
	else
	{
		start_y = y - r;
		height = r * 2 + (window->before_cursor_y - y) * r;
	}

	start_x -= enter * 4;
	width += enter * 4 * 2 + 2;
	start_y -= enter * 4;
	height += enter * 4 * 2 + 2;

	gtk_widget_queue_draw_area(window->window,
		(gint)start_x, (gint)start_y, (gint)width, (gint)height);
}

static GtkWidget* CustomBrushSettingWidgetNew(APPLICATION* app, CUSTOM_BRUSH* brush, gboolean is_shape_change);

static void InitializeCustomBrush(CUSTOM_BRUSH* brush)
{
	// アプリケーションの情報
	APPLICATION *app = brush->core->app;
	// カーソルサーフェース作成用にパターンサーフェースを作成
	cairo_surface_t *surface_p;
	// パターンサーフェースのピクセルデータ
	uint8 *pixels;
	// パターンピクセルデータの一行分のバイト数
	int stride;
	// カーソルの幅
	int cursor_width;
	// 描画する幅
	int draw_width;
	// for文用のカウンタ
	int i;

	// 幅、高さの内、大きい方で半径セット
	if(brush->brush_shape == CUSTOM_BRUSH_SHAPE_PATTERN)
	{
		brush->image_width = app->stamps.active_pattern->width;
		brush->image_height = app->stamps.active_pattern->height;
		brush->image_channel = app->stamps.active_pattern->channel;
	}
	else if(brush->brush_shape != CUSTOM_BRUSH_SHAPE_IMAGE)
	{
		brush->image_channel = 2;
	}

	if(brush->brush_shape == CUSTOM_BRUSH_SHAPE_PATTERN
		|| brush->brush_shape == CUSTOM_BRUSH_SHAPE_IMAGE)
	{
		if(brush->image_width > brush->image_height)
		{
			brush->r = brush->image_width * (1 / brush->scale);
			brush->image_size = brush->image_width;
		}
		else
		{
			brush->r = brush->image_height * (1 / brush->scale);
			brush->image_size = brush->image_height;
		}

		// パターンのサイズセット
		brush->half_width = brush->image_width * (1 / brush->scale) * 0.5;
		brush->half_height = brush->image_height * (1 / brush->scale) * 0.5;
	}
	else
	{
		brush->r = brush->scale;
		brush->image_size = brush->image_width = brush->image_height = (int)brush->r;
		brush->half_width = brush->half_height = (int)(brush->r * 0.5);
	}


	// ピクセルデータ用のメモリ確保
	brush->brush_pixel = (uint8*)MEM_REALLOC_FUNC(
		brush->brush_pixel, brush->image_width * brush->image_height * 4);
	brush->temp_pixel = (uint8*)MEM_REALLOC_FUNC(
		brush->temp_pixel, brush->image_width * brush->image_height * 4);

	// スタンプ間の距離決定
	brush->distance = brush->brush_distance *
		sqrt(brush->half_width*brush->half_width + brush->half_height*brush->half_height);

	if(brush->distance < 1)
	{
		brush->distance = 1;
	}

	// 開始回転角を決定
	brush->start_angle = fabs(brush->start_angle);
	if(brush->rotate_direction < 0)
	{
		brush->start_angle = - brush->start_angle;
	}
	brush->angle = brush->start_angle;

	// 回転速度を決定
	// core->rotate_speed = core->rotate_direction * fabs(core->rotate_speed);

	// スタンプのカーソルを更新
	if(brush->cursor_surface != NULL)
	{
		cairo_surface_destroy(brush->cursor_surface);
	}
	if(app->stamp_buff_size < app->stamps.pattern_max_byte)
	{
		app->stamp_buff_size = app->stamps.pattern_max_byte;
		app->stamp_shape = (uint8*)MEM_REALLOC_FUNC(app->stamp_shape, app->stamp_buff_size);
	}

	// パターンサーフェースを作成してカーソル作成
	surface_p = CreateCustomBrushSurface(brush, app->tool_window.color_chooser->rgb,
		app->tool_window.color_chooser->back_rgb, TRUE);
	if(surface_p != NULL)
	{
		pixels = cairo_image_surface_get_data(surface_p);
		stride = cairo_image_surface_get_stride(surface_p);
		// カーソルの幅決定
		cursor_width = brush->image_width;
		cursor_width += (4 - (cursor_width % 4)) % 4;
		(void)memset(brush->temp_pixel, 0, cursor_width * brush->image_height);

		draw_width = brush->image_width;
#ifdef _OPENMP
#pragma omp parallel for firstprivate(draw_width, cursor_width, pixels)
#endif
		// αチャンネルをコピー
		for(i=0; i<brush->image_height; i++)
		{
			int j;
			for(j=0; j<draw_width; j++)
			{
				if(pixels[i*stride+j*4+3] > 0)
				{
					brush->temp_pixel[i*cursor_width+j] = 0xff;
				}
				else
				{
					brush->temp_pixel[i*cursor_width+j] = 0;
				}
			}
		}

		brush->cursor_pixel = (uint8*)MEM_REALLOC_FUNC(
			brush->cursor_pixel, cursor_width * brush->image_height);

		if(brush->brush_shape == CUSTOM_BRUSH_SHAPE_PATTERN
			|| brush->brush_shape == CUSTOM_BRUSH_SHAPE_IMAGE)
		{
			// エッジ検出
			LaplacianFilter(brush->temp_pixel, cursor_width, brush->image_height,
			cursor_width, brush->cursor_pixel);
		}
		else
		{
			(void)memcpy(brush->cursor_pixel, brush->temp_pixel, cursor_width * brush->image_height);
		}
		// エッジ検出したデータでサーフェース作成
		brush->cursor_surface = cairo_image_surface_create_for_data(brush->cursor_pixel,
			CAIRO_FORMAT_A8, cursor_width, brush->image_height, cursor_width);
		cairo_surface_destroy(surface_p);
	}

	if((app->flags & APPLICATION_INITIALIZED) != 0 && app != NULL)
	{
		// ブラシパターンサーフェースを更新
		if(brush->core->brush_surface != NULL)
		{
			cairo_surface_destroy(brush->core->brush_surface);
		}
		if(brush->core->brush_pattern != NULL)
		{
			cairo_pattern_destroy(brush->core->brush_pattern);
		}
		brush->core->brush_surface = CreateCustomBrushSurface(
			brush, app->tool_window.color_chooser->rgb, app->tool_window.color_chooser->back_rgb, FALSE);
		brush->core->brush_pattern = cairo_pattern_create_for_surface(
			brush->core->brush_surface);
		cairo_pattern_set_extend(brush->core->brush_pattern, CAIRO_EXTEND_NONE);
		brush->core->temp_surface = cairo_image_surface_create_for_data(
			brush->temp_pixel, CAIRO_FORMAT_ARGB32,
				brush->image_width, brush->image_height, brush->image_width*4
		);
		brush->core->temp_cairo = cairo_create(brush->core->temp_surface);
		cairo_set_operator(brush->core->temp_cairo, CAIRO_OPERATOR_SOURCE);
		brush->core->temp_pattern = cairo_pattern_create_for_surface(brush->core->temp_surface);
		cairo_pattern_set_extend(brush->core->temp_pattern, CAIRO_EXTEND_NONE);
	}

	brush->distance = brush->brush_distance *
		sqrt(brush->half_width*brush->half_width + brush->half_height*brush->half_height);
}

static void UpdateCustomBrushButtonImage(CUSTOM_BRUSH* brush)
{
#define ICON_SIZE 32
	GdkPixbuf *pixbuf;
	cairo_t *cairo_p;
	cairo_surface_t *surface_p;
	uint8 *pixel;
	gint stride;
	int i;

	if(brush->button_image == NULL)
	{
		return;
	}

	pixbuf = gdk_pixbuf_new(GDK_COLORSPACE_RGB, TRUE, 8,
		ICON_SIZE, ICON_SIZE);
	pixel = gdk_pixbuf_get_pixels(pixbuf);
	stride = gdk_pixbuf_get_rowstride(pixbuf);
	(void)memset(pixel, 0, ICON_SIZE * stride);
	surface_p = cairo_image_surface_create_for_data(pixel,
		CAIRO_FORMAT_ARGB32, ICON_SIZE, ICON_SIZE, stride);
	cairo_p = cairo_create(surface_p);
	cairo_scale(cairo_p, (FLOAT_T)ICON_SIZE / brush->image_width,
		(FLOAT_T)ICON_SIZE / brush->image_height);
	cairo_set_source_surface(cairo_p, brush->core->brush_surface, 0, 0);
	cairo_paint(cairo_p);

#if defined(USE_BGR_COLOR_SPACE) && USE_BGR_COLOR_SPACE != 0
	{
		uint8 r;
		for(i=0; i<ICON_SIZE*ICON_SIZE; i++)
		{
			r = pixel[i*4];
			pixel[i*4] = pixel[i*4+2];
			pixel[i*4+2] = r;
		}
	}
#endif

	gtk_image_set_from_pixbuf(GTK_IMAGE(brush->button_image), pixbuf);
#undef ICON_SIZE
}

static void CustomBrushColorChange(const uint8 color[3], void* data)
{
	CUSTOM_BRUSH *brush = (CUSTOM_BRUSH*)data;
	InitializeCustomBrush(brush);
	UpdateCustomBrushButtonImage(brush);
}

static void CustomBrushImageFileSelected(GtkFileChooserButton* chooser, CUSTOM_BRUSH* brush)
{
	FILE *fp;
	gchar *file_path = gtk_file_chooser_get_filename(GTK_FILE_CHOOSER(chooser));
	uint8 *image_data;
	uint8 *pixel;
	uint8 *system_path;
	char *file_type;
	char *str;
	size_t data_size;
	int width, height, channel;

	system_path = g_locale_from_utf8(file_path, -1, NULL, NULL, NULL);
	fp = fopen(system_path, "rb");

	(void)fseek(fp, 0, SEEK_END);
	data_size = ftell(fp);
	rewind(fp);

	file_type = str = file_path;
	while(*str != '\0')
	{
		if(*str == '.')
		{
			file_type = str;
		}
		str = g_utf8_next_char(str);
	}

	image_data = (uint8*)MEM_ALLOC_FUNC(data_size);
	(void)fread(image_data, 1, data_size, fp);
	(void)fclose(fp);

	pixel = DecodeImageData(image_data, data_size, file_type,
		&width, &height, &channel, NULL, NULL, NULL, NULL);
	if(pixel != NULL)
	{
		MEM_FREE_FUNC(brush->image_path);
		brush->image_path = MEM_STRDUP_FUNC(system_path);

		brush->image_pixel = pixel;
		brush->image_width = width;
		brush->image_height = height;
		brush->image_channel = channel;

		InitializeCustomBrush(brush);
	}

	MEM_FREE_FUNC(image_data);
	g_free(system_path);
	g_free(file_path);

	UpdateBrushPreviewWindow(
		brush->core->app->brush_preview_canvas,
		brush->core,
		CustomBrushButtonPressCallBack,
		CustomBrushMotionCallBack,
		CustomBrushButtonReleaseCallBack
	);
}

/*******************************************************************************
* CustomBrushPatternSelectButtonClicked関数                                    *
* カスタムブラシのパターン選択用のボタンがクリックされたときのコールバック関数 *
* 引数                                                                         *
* button	: ボタンウィジェット                                               *
* stamp		: スタンプ系ツールの基本情報                                       *
*******************************************************************************/
static void CustomBrushPatternSelectButtonClicked(GtkWidget* button, CUSTOM_BRUSH* brush)
{
	// アプリケーションを管理する情報
	APPLICATION *app = brush->core->app;
	// 選択されたパターンの情報
	PATTERN *pattern;
	// パターンIDをウィジェットに登録されたデータから取得
	int pattern_id = GPOINTER_TO_INT(g_object_get_data(G_OBJECT(button), "pattern-id"));
	// ボタンID調整用
	int button_add = (app->stamps.has_clip_board_pattern == FALSE) ? 0 : -1;
	// for文用のカウンタ
	int i;

	// 使用パターンと押されたボタンが一致していたらボタンをアクティブにして終了
	if(pattern_id == brush->pattern_id)
	{
		if(gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(button)) == FALSE)
		{
			gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(button), TRUE);
		}
		return;
	}
	else if(gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(button)) == FALSE)
	{	// 使用パターンと不一致でボタンが非アクティブなら終了
		return;
	}

	// 使用パターンを設定
	brush->pattern_id = pattern_id;
	if(app->stamps.has_clip_board_pattern != FALSE)
	{
		if(pattern_id == 0)
		{
			pattern = &app->stamps.clip_board;
		}
		else
		{
			pattern = &app->stamps.patterns[pattern_id+1];
		}
	}
	else
	{
		pattern = &app->stamps.patterns[pattern_id];
	}
	brush->image_pixel = pattern->pixels;
	brush->image_width = pattern->width;
	brush->image_height = pattern->height;
	brush->image_channel = pattern->channel;

	InitializeCustomBrush(brush);
	UpdateBrushPreviewWindow(
		app->brush_preview_canvas,
		brush->core,
		CustomBrushButtonPressCallBack,
		CustomBrushMotionCallBack,
		CustomBrushButtonReleaseCallBack
	);

	// 他のボタンを非アクティブにする
	for(i=0; i<brush->num_pattern_buttons; i++)
	{
		if(i == brush->pattern_id)
		{
			if(gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(brush->pattern_buttons[i])) == FALSE)
			{
				gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(brush->pattern_buttons[i]), TRUE);
			}
		}
		else
		{
			if(gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(brush->pattern_buttons[i])) != FALSE)
			{
				gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(brush->pattern_buttons[i]), FALSE);
			}
		}
	}
}

// パターン選択用テーブルの幅
#define STAMP_SELECT_TABLE_WIDTH 4

static void OnDestroyCustomBrushPatternTable(CUSTOM_BRUSH* brush)
{
	MEM_FREE_FUNC(brush->pattern_buttons);
}

/***********************************************************
* CreateCustomBrushPatternSelectTable関数                  *
* カスタムブラシのパターン選択用のボタンテーブルを作成する *
* 引数                                                     *
* brush	: カスタムブラシの基本情報                         *
* 返り値                                                   *
*	作成したボタンテーブルのウィジェット                   *
***********************************************************/
static GtkWidget* CreateCustomBrushPatternSelectTable(CUSTOM_BRUSH* brush)
{
// ボタンに表示するアイコンのサイズ
#define ICON_SIZE 32
	// アプリケーションを管理する情報
	APPLICATION *app = brush->core->app;
	// 返り値
	GtkWidget *table;
	// ボタンに登録するイメージウィジェット
	GtkWidget *image;
	// テーブルの高さ
	int height;
	// ボタンのイメージ作成用ピクセルバッファ
	GdkPixbuf *pixbuf, *scaled_buf;
	// チャンネル数が1のときに使用するピクセルデータ
	uint8 *pixels;
	// BGR→RGB変換用
	uint8 *swap_pixels;
	// イメージの幅、高さ
	int image_width, image_height;
	// イメージの一行分のバイト数
	int image_stride;
	// イメージのピクセル
	uint8 *image_pixel;
	// イメージの拡大率
	FLOAT_T zoom;
	// ボタンID調整用
	int button_add = 0;
	// テーブルの座標
	int x = 0, y = 0;
	// for文用のカウンタ
	int i = 0, j;

	// ボタン配列作成
	brush->pattern_buttons = (GtkWidget**)MEM_ALLOC_FUNC(
		sizeof(*brush->pattern_buttons)*(app->stamps.num_pattern+1));
	brush->num_pattern_buttons = app->stamps.num_pattern;

	// テーブルの高さを決定して作成
	height = brush->num_pattern_buttons / STAMP_SELECT_TABLE_WIDTH;
	if((brush->num_pattern_buttons+1) % STAMP_SELECT_TABLE_WIDTH != 0)
	{
		height++;
	}
	table = gtk_table_new(height, STAMP_SELECT_TABLE_WIDTH, TRUE);
	(void)g_signal_connect_swapped(G_OBJECT(table), "destroy",
		G_CALLBACK(OnDestroyCustomBrushPatternTable), brush);

	// クリップボードのパターンがあるならば
	if(app->stamps.has_clip_board_pattern != FALSE)
	{
		PATTERN *pattern = &app->stamps.clip_board;

		pixbuf = gdk_pixbuf_new_from_data(pattern->pixels,
			GDK_COLORSPACE_RGB, TRUE, 8, pattern->width, pattern->height,
			pattern->stride, NULL, NULL
		);

		// 拡大率を計算
		if(pattern->width > pattern->height)
		{
			zoom = ICON_SIZE / (FLOAT_T)pattern->width;
		}
		else
		{
			zoom = ICON_SIZE / (FLOAT_T)pattern->height;
		}

		// ピクセルバッファを拡大縮小してイメージウィジェット作成
		image = gtk_image_new_from_pixbuf(
			gdk_pixbuf_scale_simple(pixbuf, (int)(pattern->width*zoom),
			(int)(pattern->height*zoom), GDK_INTERP_BILINEAR)
		);

		// ボタン作成
		brush->pattern_buttons[i] = gtk_toggle_button_new();
		// 現在の使用パターンと一致していたらアクティブに
		if(i == brush->pattern_id + button_add)
		{
			gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(brush->pattern_buttons[i]), TRUE);
		}

		// コールバック関数とデータをセット
		(void)g_signal_connect(G_OBJECT(brush->pattern_buttons[i]), "toggled", G_CALLBACK(CustomBrushPatternSelectButtonClicked), brush);
		g_object_set_data(G_OBJECT(brush->pattern_buttons[i]), "pattern-id", GINT_TO_POINTER(i));

		// テーブルにボタン追加
		gtk_table_attach(GTK_TABLE(table), brush->pattern_buttons[i], x, x+1, y, y+1, GTK_SHRINK, GTK_SHRINK, 0, 0);

		// イメージウィジェットをボタンに登録
		gtk_container_add(GTK_CONTAINER(brush->pattern_buttons[i]), image);

		g_object_unref(pixbuf);
		brush->num_pattern_buttons++;
		button_add = -1;
		i++, x++;
	}

	// ボタンを作成してテーブルに入れる
	for( ; i<brush->num_pattern_buttons; i++, x++)
	{
		// ボタンに入れるパターン
		PATTERN* pattern = &app->stamps.patterns[i+button_add];

		// 一行分埋まったら次の行へ
		if(x == STAMP_SELECT_TABLE_WIDTH)
		{
			x = 0;
			y++;
		}

		pixels = NULL;
		// グレースケールならRGBにする
		if(pattern->channel == 1)
		{
			pixels = (uint8*)MEM_ALLOC_FUNC(pattern->stride*pattern->height*3);

#ifdef _OPENMP
#pragma omp parallel for firstprivate(pixels)
#endif
			for(j=0; j<pattern->stride*pattern->height; j++)
			{
				uint8 pixel_value = 0xff - pattern->pixels[j];
				pixels[j*3] = pixel_value;
				pixels[j*3+1] = pixel_value;
				pixels[j*3+2] = pixel_value;
			}
			pixbuf = gdk_pixbuf_new_from_data(
				pixels, GDK_COLORSPACE_RGB, FALSE, 8,
				pattern->width, pattern->height, pattern->stride*3, NULL, NULL
			);
		}
		else if(pattern->channel == 2)
		{
			pixels = (uint8*)MEM_ALLOC_FUNC(pattern->width*pattern->height*4);

			image_width = pattern->width;
			image_stride = pattern->stride;
			image_pixel = pattern->pixels;
#ifdef _OPENMP
#pragma omp parallel for firstprivate(image_width, image_stride, pixels, image_pixel)
#endif
			for(j=0; j<pattern->height; j++)
			{
				uint8 pixel_value;
				int k;

				for(k=0; k<image_width; k++)
				{
					pixel_value = image_pixel[j*image_stride+k*2];
					pixels[j*image_width*4+k*4] = pixel_value;
					pixels[j*image_width*4+k*4+1] = pixel_value;
					pixels[j*image_width*4+k*4+2] = pixel_value;
					pixels[j*image_width*4+k*4+3] = image_pixel[j*pattern->stride+k*2+1];
				}
			}
			pixbuf = gdk_pixbuf_new_from_data(
				pixels, GDK_COLORSPACE_RGB, TRUE, 8,
				pattern->width, pattern->height, pattern->width*4, NULL, NULL
			);
		}
		else
		{
			// パターンのピクセルデータからピクセルバッファ作成
			pixbuf = gdk_pixbuf_new_from_data(pattern->pixels, GDK_COLORSPACE_RGB,
				pattern->channel == 4, 8, pattern->width, pattern->height, pattern->width*pattern->channel,
				NULL, NULL
			);
		}

		// 拡大率を計算
		if(pattern->width > pattern->height)
		{
			zoom = ICON_SIZE / (FLOAT_T)pattern->width;
		}
		else
		{
			zoom = ICON_SIZE / (FLOAT_T)pattern->height;
		}

		scaled_buf = gdk_pixbuf_scale_simple(pixbuf, (int)(pattern->width*zoom),
			(int)(pattern->height*zoom), GDK_INTERP_BILINEAR);
		swap_pixels = gdk_pixbuf_get_pixels(scaled_buf);
		if(swap_pixels != NULL)
		{
			int channel;
			image_width = gdk_pixbuf_get_width(scaled_buf);
			image_height = gdk_pixbuf_get_height(scaled_buf);

			if(gdk_pixbuf_get_has_alpha(scaled_buf) == FALSE)
			{
				channel = 3;
			}
			else
			{
				channel = 4;
			}

#ifdef _OPENMP
#pragma omp parallel for
#endif
			for(j=0; j<image_width*image_height; j++)
			{
				uint8 r = swap_pixels[j*channel];
				swap_pixels[j*channel] = swap_pixels[j*channel+2];
				swap_pixels[j*channel+2] = r;
			}
		}
		// ピクセルバッファを拡大縮小してイメージウィジェット作成
		image = gtk_image_new_from_pixbuf(scaled_buf);

		// ボタン作成
		brush->pattern_buttons[i] = gtk_toggle_button_new();
		// 現在の使用パターンと一致していたらアクティブに
		if(i == brush->pattern_id + button_add)
		{
			gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(brush->pattern_buttons[i]), TRUE);
		}

		// コールバック関数とデータをセット
		(void)g_signal_connect(G_OBJECT(brush->pattern_buttons[i]), "toggled", G_CALLBACK(CustomBrushPatternSelectButtonClicked), brush);
		g_object_set_data(G_OBJECT(brush->pattern_buttons[i]), "pattern-id", GINT_TO_POINTER(i));

		// テーブルにボタン追加
		gtk_table_attach(GTK_TABLE(table), brush->pattern_buttons[i], x, x+1, y, y+1, GTK_SHRINK, GTK_SHRINK, 0, 0);

		// イメージウィジェットをボタンに登録
		gtk_container_add(GTK_CONTAINER(brush->pattern_buttons[i]), image);

		g_object_unref(pixbuf);
		g_object_unref(scaled_buf);
		MEM_FREE_FUNC(pixels);
	}

	return table;
}

static GtkWidget* CustomBrushShapeSelectWidgetNew(CUSTOM_BRUSH* brush)
{
	GtkWidget *vbox = gtk_vbox_new(FALSE, 0);
	switch(brush->brush_shape)
	{
	case CUSTOM_BRUSH_SHAPE_PATTERN:
		{
			GtkWidget *scroll = gtk_scrolled_window_new(NULL, NULL);
			GtkWidget *table = CreateCustomBrushPatternSelectTable(brush);
			gtk_widget_set_size_request(scroll, 320, 240);
			gtk_scrolled_window_add_with_viewport(GTK_SCROLLED_WINDOW(scroll), table);
			gtk_box_pack_start(GTK_BOX(vbox), scroll, FALSE, TRUE, 0);
		}
		break;
	case CUSTOM_BRUSH_SHAPE_IMAGE:
		{
			GtkWidget *chooser = gtk_file_chooser_button_new(
				brush->core->app->labels->menu.file, GTK_FILE_CHOOSER_ACTION_OPEN);
			(void)gtk_file_chooser_set_filename(GTK_FILE_CHOOSER(chooser), brush->image_path);
			(void)g_signal_connect(G_OBJECT(chooser), "file-set",
				G_CALLBACK(CustomBrushImageFileSelected), brush);
			gtk_box_pack_start(GTK_BOX(vbox), chooser, FALSE, FALSE, 0);
		}
		break;
	}
	return vbox;
}

static void ChangeCustomBrushShapeType(GtkWidget* combo, CUSTOM_BRUSH* brush)
{
	GtkWidget *setting = GTK_WIDGET(g_object_get_data(G_OBJECT(combo), "detail_setting"));
	GtkWidget *box = GTK_WIDGET(g_object_get_data(G_OBJECT(combo), "detail_setting_box"));

	gtk_widget_destroy(setting);

	brush->brush_shape = (uint8)gtk_combo_box_get_active(GTK_COMBO_BOX(combo));
	setting = CustomBrushShapeSelectWidgetNew(brush);
	g_object_set_data(G_OBJECT(combo), "detail_setting", setting);
	gtk_box_pack_start(GTK_BOX(box), setting, FALSE, FALSE, 0);
	gtk_widget_show_all(box);

	InitializeCustomBrush(brush);

	UpdateBrushPreviewWindow(
		brush->core->app->brush_preview_canvas,
		brush->core,
		CustomBrushButtonPressCallBack,
		CustomBrushMotionCallBack,
		CustomBrushButtonReleaseCallBack
	);
}

static void CustomBrushDialogRealized(CUSTOM_BRUSH* brush)
{
	UpdateBrushPreviewWindow(
		brush->core->app->brush_preview_canvas,
		brush->core,
		CustomBrushButtonPressCallBack,
		CustomBrushMotionCallBack,
		CustomBrushButtonReleaseCallBack
	);
}

static GtkWidget* CustomBrushShapeWidgetNew(CUSTOM_BRUSH* brush)
{
	APPLICATION *app = brush->core->app;
	const char *shape_names[] = {app->labels->tool_box.shape.circle,
		app->labels->tool_box.shape.triangle, app->labels->tool_box.shape.square,
		app->labels->tool_box.shape.hexagon, app->labels->tool_box.shape.star,
		app->labels->tool_box.shape.pattern, app->labels->tool_box.shape.image
	};
	GtkWidget *vbox = gtk_vbox_new(FALSE, 0);
	GtkWidget *shape_detail_box = gtk_vbox_new(FALSE, 0);
	GtkWidget *shape_detail_setting;
	GtkWidget *combo;
	int i;

#if GTK_MAJOR_VERSION <= 2
	combo = gtk_combo_box_new_text();
	for(i=0; i<sizeof(shape_names)/sizeof(*shape_names); i++)
	{
		gtk_combo_box_append_text(GTK_COMBO_BOX(combo), shape_names[i]);
	}
#else
	combo = gtk_combo_box_text_new();
	for(i=0; i<sizeof(shape_names)/sizeof(*shape_names); i++)
	{
		gtk_combo_box_text_append_text(GTK_COMBO_BOX_TEXT(combo), shape_names[i]);
	}
#endif

	shape_detail_setting = CustomBrushShapeSelectWidgetNew(brush);
	gtk_box_pack_start(GTK_BOX(vbox), combo, FALSE, FALSE, 0);
	g_object_set_data(G_OBJECT(combo), "detail_setting_box", shape_detail_box);
	g_object_set_data(G_OBJECT(combo), "detail_setting", shape_detail_setting);
	gtk_box_pack_start(GTK_BOX(shape_detail_box), shape_detail_setting, FALSE, FALSE, 0);
	gtk_box_pack_start(GTK_BOX(vbox), shape_detail_box, FALSE, TRUE, 0);
	gtk_combo_box_set_active(GTK_COMBO_BOX(combo), brush->brush_shape);
	(void)g_signal_connect(G_OBJECT(combo), "changed",
		G_CALLBACK(ChangeCustomBrushShapeType), brush);

	return vbox;
}

static void OnDestroyCustomBrushShapeDialog(GtkWidget* dialog, CUSTOM_BRUSH* brush)
{
	if(brush->core->app != NULL)
	{
		GList *children;
		GList *ref;
		children = gtk_container_get_children(GTK_CONTAINER(brush->core->app->tool_window.detail_ui));
		ref = children;
		while(ref != NULL)
		{
			if(GTK_IS_BOX(ref->data) != FALSE)
			{
				gtk_widget_destroy(GTK_WIDGET(ref->data));
				break;
			}
			ref = ref->next;
		}
		g_list_free(children);
		gtk_box_pack_start(GTK_BOX(brush->core->app->tool_window.detail_ui),
			CustomBrushSettingWidgetNew(brush->core->app, brush, FALSE), FALSE, FALSE, 0);
		gtk_widget_show_all(brush->core->app->tool_window.detail_ui);
	}
}

static void ChangeCustomBrushShapeButtonClicked(GtkWidget* button, CUSTOM_BRUSH* brush)
{
	APPLICATION *app = brush->core->app;
	GtkWidget *vbox;
	GtkWidget *setting_dialog;
	GtkWidget *shape_widget;
	GtkWidget *scroll;

	if(app == NULL)
	{
		return;
	}

	scroll = gtk_scrolled_window_new(NULL, NULL);
	gtk_widget_set_size_request(scroll, 600, 600);
	gtk_scrolled_window_set_policy(GTK_SCROLLED_WINDOW(scroll),
		GTK_POLICY_AUTOMATIC, GTK_POLICY_AUTOMATIC);
	vbox = gtk_vbox_new(FALSE, 0);
	gtk_scrolled_window_add_with_viewport(GTK_SCROLLED_WINDOW(scroll), vbox);

	setting_dialog = gtk_dialog_new_with_buttons(
		app->labels->tool_box.preference,
		GTK_WINDOW(app->widgets->window), GTK_DIALOG_DESTROY_WITH_PARENT | GTK_DIALOG_MODAL,
			GTK_STOCK_OK, GTK_RESPONSE_OK, NULL
	);
	gtk_window_set_transient_for(GTK_WINDOW(setting_dialog), GTK_WINDOW(app->widgets->window));
	(void)g_signal_connect(G_OBJECT(setting_dialog), "destroy",
		G_CALLBACK(OnDestroyCustomBrushShapeDialog), brush);
	gtk_box_pack_start(GTK_BOX(gtk_dialog_get_content_area(GTK_DIALOG(setting_dialog))),
		scroll, TRUE, TRUE, 0);

	app->brush_preview_canvas->window = gtk_drawing_area_new();
	gtk_widget_set_size_request(app->brush_preview_canvas->window,
		BRUSH_PREVIEW_CANVAS_WIDTH, BRUSH_PREVIEW_CANVAS_HEIGHT);
	gtk_widget_set_events(app->brush_preview_canvas->window, GDK_EXPOSURE_MASK);
#if GTK_MAJOR_VERSION <= 2	
	(void)g_signal_connect(G_OBJECT(app->brush_preview_canvas->window),
		"expose_event", G_CALLBACK(DisplayBrushPreview), app->brush_preview_canvas);
#else
	(void)g_signal_connect(G_OBJECT(app->brush_preview_canvas->window),
		"draw", G_CALLBACK(DisplayBrushPreview), app->brush_preview_canvas);
#endif

	gtk_box_pack_start(GTK_BOX(vbox), app->brush_preview_canvas->window, FALSE, FALSE, 0);

	shape_widget = CustomBrushShapeWidgetNew(brush);
	gtk_box_pack_start(GTK_BOX(vbox), shape_widget, FALSE, FALSE, 0);

	(void)g_signal_connect_swapped(G_OBJECT(app->brush_preview_canvas->window), "realize",
		G_CALLBACK(CustomBrushDialogRealized), brush);

	gtk_box_pack_start(GTK_BOX(vbox), CustomBrushSettingWidgetNew(app, brush, TRUE),
		FALSE, FALSE, 0);

	gtk_widget_show_all(setting_dialog);
	(void)gtk_dialog_run(GTK_DIALOG(setting_dialog));
	gtk_widget_destroy(setting_dialog);
}

static void ChangeCustomBrushFlow(GtkAdjustment* scale, CUSTOM_BRUSH* brush)
{
	brush->alpha = gtk_adjustment_get_value(scale) * 0.01;
	UpdateCustomBrushButtonImage(brush);
}

static void ChangeCustomBrushOutlineHardness(GtkAdjustment* scale, CUSTOM_BRUSH* brush)
{
	brush->outline_hardness = gtk_adjustment_get_value(scale) * 0.01;
	InitializeCustomBrush(brush);
	UpdateCustomBrushButtonImage(brush);
}

static void ChangeCustomBrushBlur(GtkAdjustment* scale, CUSTOM_BRUSH* brush)
{
	brush->blur = gtk_adjustment_get_value(scale) * 0.01;
	InitializeCustomBrush(brush);
	UpdateCustomBrushButtonImage(brush);
}

static void ChangeCustomBrushEnter(GtkAdjustment* scale, CUSTOM_BRUSH* brush)
{
	brush->enter = gtk_adjustment_get_value(scale) * 0.01;
}

static void ChangeCustomBrushOut(GtkAdjustment* scale, CUSTOM_BRUSH* brush)
{
	brush->out = gtk_adjustment_get_value(scale) * 0.01;
}

static void ChangeCustomBrushBlendMode(GtkComboBox* combo, CUSTOM_BRUSH* brush)
{
	brush->blend_mode = (uint16)gtk_combo_box_get_active(combo);
}

static void ChangeCustomBrushStartAngle(GtkAdjustment* scale, CUSTOM_BRUSH* brush)
{
	brush->angle = brush->start_angle = gtk_adjustment_get_value(scale) * G_PI / 180;
	InitializeCustomBrush(brush);
	UpdateCustomBrushButtonImage(brush);
}

static void ChangeCustomBrushRotateSpeed(GtkAdjustment* scale, CUSTOM_BRUSH* brush)
{
	brush->rotate_speed = gtk_adjustment_get_value(scale) * G_PI / 180;
	InitializeCustomBrush(brush);
}

static void CustomBrushCoreSetMode(GtkWidget* widget, CUSTOM_BRUSH* brush)
{
	brush->color_mode = (uint8)GPOINTER_TO_UINT(g_object_get_data(G_OBJECT(widget), "mode"));
	InitializeCustomBrush(brush);
}

static void CustomBrushSetRotateDirection(GtkWidget* button, CUSTOM_BRUSH* brush)
{
	if(gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(button)) != FALSE)
	{
		brush->rotate_direction = GPOINTER_TO_INT(g_object_get_data(
			G_OBJECT(button), "rotate_direction"));
	}
}

static void ChangeCustomBrushScatterRange(GtkAdjustment* scale, CUSTOM_BRUSH* brush)
{
	brush->scatter_range = gtk_adjustment_get_value(scale) * 0.01;
}

static void ChangeCustomBrushScatterSize(GtkAdjustment* scale, CUSTOM_BRUSH* brush)
{
	brush->scatter_size = gtk_adjustment_get_value(scale) * 0.01;
}

static void ChangeCustomBrushScatterRandomSize(GtkAdjustment* scale, CUSTOM_BRUSH* brush)
{
	brush->scatter_random_size = gtk_adjustment_get_value(scale) * 0.01;
}

static void ChangeCustomBrushScatterRandomFlow(GtkAdjustment* scale, CUSTOM_BRUSH* brush)
{
	brush->scatter_random_flow = gtk_adjustment_get_value(scale) * 0.01;
}

static void ChangeCustomBrushBlendTarget(GtkWidget* button, CUSTOM_BRUSH* brush)
{
	int target = GPOINTER_TO_INT(g_object_get_data(G_OBJECT(button), "target"));
	if(gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(button)) != FALSE)
	{
		brush->blend_target = (uint8)target;
	}
}

static void ChangeCustomBrushExtend(GtkAdjustment* scale, CUSTOM_BRUSH* brush)
{
	brush->extend = (uint8)(gtk_adjustment_get_value(scale) * 2.555);
}

static void ChangeCustomBrushHue(GtkAdjustment* scale, CUSTOM_BRUSH* brush)
{
	brush->hue = (int16)gtk_adjustment_get_value(scale);
}

static void ChangeCustomBrushSaturation(GtkAdjustment* scale, CUSTOM_BRUSH* brush)
{
	brush->saturation = (uint8)(gtk_adjustment_get_value(scale) * 2.555);
}

static void ChangeCustomBrushBrightness(GtkAdjustment* scale, CUSTOM_BRUSH* brush)
{
	brush->brightness = (uint8)(gtk_adjustment_get_value(scale) * 2.555);
}

static void ChangeCustomBrushMix(GtkAdjustment* scale, CUSTOM_BRUSH* brush)
{
	brush->mix = (uint8)(gtk_adjustment_get_value(scale) * 2.555);
}

static GtkWidget* CustomBrushModeDetailSettingWidgetNew(CUSTOM_BRUSH* brush)
{
#define UI_FONT_SIZE 8.0
	APPLICATION *app = brush->core->app;
	GtkWidget *vbox = gtk_vbox_new(FALSE, 0);
	GtkWidget *scale;
	GtkWidget *label;
	GtkWidget *buttons[3];
	GtkWidget *hbox;
	GtkAdjustment *adjustment;
	char mark_up_buff[256];

	switch(brush->brush_mode)
	{
	case CUSTOM_BRUSH_MODE_NORMAL:
		break;
	case CUSTOM_BRUSH_MODE_BLEND:
		label = gtk_label_new("");
		(void)sprintf(mark_up_buff, "<span font_desc=\"%.2f\">%s : </span>",
			UI_FONT_SIZE * app->gui_scale, app->labels->tool_box.select.target);
		gtk_label_set_markup(GTK_LABEL(label), mark_up_buff);
		hbox = gtk_hbox_new(FALSE, 0);
		gtk_box_pack_start(GTK_BOX(hbox), label, FALSE, FALSE, 0);
		gtk_box_pack_start(GTK_BOX(vbox), hbox, FALSE, FALSE, 0);
		buttons[0] = gtk_radio_button_new_with_label(NULL, app->labels->tool_box.select.under_layer);
		g_object_set_data(G_OBJECT(buttons[0]), "target", GINT_TO_POINTER(BLEND_BRUSH_TARGET_UNDER_LAYER));
		(void)g_signal_connect(G_OBJECT(buttons[0]), "toggled", G_CALLBACK(ChangeCustomBrushBlendTarget), brush);
		buttons[1] = gtk_radio_button_new_with_label(gtk_radio_button_get_group(
			GTK_RADIO_BUTTON(buttons[0])), app->labels->tool_box.select.canvas);
		g_object_set_data(G_OBJECT(buttons[1]), "target", GINT_TO_POINTER(BLEND_BRUSH_TARGET_CANVAS));
		(void)g_signal_connect(G_OBJECT(buttons[1]), "toggled", G_CALLBACK(ChangeCustomBrushBlendTarget), brush);
		gtk_box_pack_start(GTK_BOX(vbox), buttons[0], FALSE, FALSE, 0);
		gtk_box_pack_start(GTK_BOX(vbox), buttons[1], FALSE, FALSE, 0);
		gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(buttons[brush->blend_target]), TRUE);
		break;
	case CUSTOM_BRUSH_MODE_SMUDGE:
		adjustment = GTK_ADJUSTMENT(gtk_adjustment_new(
			brush->extend / 2.55, 0, 100, 1, 1, 0));
		scale = SpinScaleNew(adjustment, app->labels->tool_box.color_extend, 0);
		(void)g_signal_connect(G_OBJECT(adjustment), "value_changed",
			G_CALLBACK(ChangeCustomBrushExtend), brush);
		gtk_box_pack_start(GTK_BOX(vbox), scale, FALSE, FALSE, 0);
		break;
	case CUSTOM_BRUSH_MODE_PICKER:
		adjustment = GTK_ADJUSTMENT(gtk_adjustment_new(
			brush->hue, -180, 180, 1, 1, 0));
		scale = SpinScaleNew(adjustment, app->labels->tool_box.hue, 0);
		(void)g_signal_connect(G_OBJECT(adjustment), "value_changed",
			G_CALLBACK(ChangeCustomBrushHue), brush);
		gtk_box_pack_start(GTK_BOX(vbox), scale, FALSE, FALSE, 0);
		adjustment = GTK_ADJUSTMENT(gtk_adjustment_new(
			brush->saturation, -100, 100, 1, 1, 0));
		scale = SpinScaleNew(adjustment, app->labels->tool_box.saturation, 0);
		(void)g_signal_connect(G_OBJECT(adjustment), "value_changed",
			G_CALLBACK(ChangeCustomBrushSaturation), brush);
		gtk_box_pack_start(GTK_BOX(vbox), scale, FALSE, FALSE, 0);
		adjustment = GTK_ADJUSTMENT(gtk_adjustment_new(
			brush->brightness, -100, 100, 1, 1, 0));
		scale = SpinScaleNew(adjustment, app->labels->tool_box.brightness, 0);
		(void)g_signal_connect(G_OBJECT(adjustment), "value_changed",
			G_CALLBACK(ChangeCustomBrushBrightness), brush);
		gtk_box_pack_start(GTK_BOX(vbox), scale, FALSE, FALSE, 0);

		label = gtk_label_new("");
		(void)sprintf(mark_up_buff, "<span font_desc=\"%.2f\">%s : </span>",
			UI_FONT_SIZE * app->gui_scale, app->labels->tool_box.select.target);
		gtk_label_set_markup(GTK_LABEL(label), mark_up_buff);
		hbox = gtk_hbox_new(FALSE, 0);
		gtk_box_pack_start(GTK_BOX(hbox), label, FALSE, FALSE, 0);
		gtk_box_pack_start(GTK_BOX(vbox), hbox, FALSE, FALSE, 0);
		buttons[0] = gtk_radio_button_new_with_label(NULL, app->labels->tool_box.select.under_layer);
		g_object_set_data(G_OBJECT(buttons[0]), "target", GINT_TO_POINTER(BLEND_BRUSH_TARGET_UNDER_LAYER));
		(void)g_signal_connect(G_OBJECT(buttons[0]), "toggled", G_CALLBACK(ChangeCustomBrushBlendTarget), brush);
		buttons[1] = gtk_radio_button_new_with_label(gtk_radio_button_get_group(
			GTK_RADIO_BUTTON(buttons[0])), app->labels->tool_box.select.canvas);
		g_object_set_data(G_OBJECT(buttons[1]), "target", GINT_TO_POINTER(BLEND_BRUSH_TARGET_CANVAS));
		(void)g_signal_connect(G_OBJECT(buttons[1]), "toggled", G_CALLBACK(ChangeCustomBrushBlendTarget), brush);
		gtk_box_pack_start(GTK_BOX(vbox), buttons[0], FALSE, FALSE, 0);
		gtk_box_pack_start(GTK_BOX(vbox), buttons[1], FALSE, FALSE, 0);
		gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(buttons[brush->blend_target]), TRUE);
		break;
	case CUSTOM_BRUSH_MODE_WATER_BRUSH:
		adjustment = GTK_ADJUSTMENT(gtk_adjustment_new(
			brush->mix / 2.55, 0, 100, 1, 1, 0));
		scale = SpinScaleNew(adjustment, app->labels->tool_box.mix, 0);
		(void)g_signal_connect(G_OBJECT(adjustment), "value_changed",
			G_CALLBACK(ChangeCustomBrushMix), brush);
		gtk_box_pack_start(GTK_BOX(vbox), scale, FALSE, FALSE, 0);
		adjustment = GTK_ADJUSTMENT(gtk_adjustment_new(
			brush->extend / 2.55, 0, 100, 1, 1, 0));
		scale = SpinScaleNew(adjustment, app->labels->tool_box.color_extend, 0);
		(void)g_signal_connect(G_OBJECT(adjustment), "value_changed",
			G_CALLBACK(ChangeCustomBrushExtend), brush);
		gtk_box_pack_start(GTK_BOX(vbox), scale, FALSE, FALSE, 0);
		break;
	}
#undef UI_FONT_SIZE

	return vbox;
}

static void ChangeCustomBrushMode(GtkWidget* button, CUSTOM_BRUSH* brush)
{
	if(gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(button)) != FALSE)
	{
		brush->brush_mode = (uint8)GPOINTER_TO_UINT(g_object_get_data(G_OBJECT(button), "brush_mode"));
		if(brush->vbox != NULL)
		{
			if(brush->mode_detail_setting != NULL)
			{
				gtk_widget_destroy(brush->mode_detail_setting);
			}
			brush->mode_detail_setting = CustomBrushModeDetailSettingWidgetNew(brush);
			gtk_box_pack_start(GTK_BOX(brush->vbox), brush->mode_detail_setting, FALSE, FALSE, 0);
			gtk_widget_show_all(brush->vbox);
		}
	}
}

static GtkWidget* CustomBrushSettingWidgetNew(APPLICATION* app, CUSTOM_BRUSH* brush, gboolean is_shape_change)
{
#define UI_FONT_SIZE 8.0
	GtkWidget *vbox = gtk_vbox_new(FALSE, 0);
	GtkWidget *inner_box;
	GtkWidget *container;
	GtkWidget *combo;
	GtkWidget *hbox;
	GtkWidget *check_button;
	GtkWidget *label;
	GtkWidget *scale;
	GtkWidget *radio_buttons[6];
	GtkAdjustment *adjustment;
	char mark_up_buff[256];
	int i;

	InitializeCustomBrush(brush);

	{
		const char *mag_str[] = {"x 0.1", "x 1", "x 10"};
		hbox = gtk_hbox_new(FALSE, 0);
		(void)sprintf(mark_up_buff, "<span font_desc=\"%.2f\">%s : </span>",
			UI_FONT_SIZE * app->gui_scale, app->labels->tool_box.base_scale);
		label = gtk_label_new("");
		gtk_label_set_markup(GTK_LABEL(label), mark_up_buff);
		gtk_box_pack_start(GTK_BOX(hbox), label, FALSE, FALSE, 0);
#if GTK_MAJOR_VERSION <= 2
		combo = gtk_combo_box_new_text();
		gtk_combo_box_append_text(GTK_COMBO_BOX(combo), mag_str[0]);
		gtk_combo_box_append_text(GTK_COMBO_BOX(combo), mag_str[1]);
		gtk_combo_box_append_text(GTK_COMBO_BOX(combo), mag_str[2]);
#else
		combo = gtk_combo_box_text_new();
		gtk_combo_box_text_append_text(GTK_COMBO_BOX_TEXT(combo), mag_str[0]);
		gtk_combo_box_text_append_text(GTK_COMBO_BOX_TEXT(combo), mag_str[1]);
		gtk_combo_box_text_append_text(GTK_COMBO_BOX_TEXT(combo), mag_str[2]);
#endif
		gtk_combo_box_set_active(GTK_COMBO_BOX(combo), brush->base_scale);
		gtk_box_pack_start(GTK_BOX(hbox), combo, TRUE, TRUE, 0);
		gtk_box_pack_start(GTK_BOX(vbox), hbox, FALSE, FALSE, 0);
	}

	switch(brush->base_scale)
	{
	case 0:
		adjustment = GTK_ADJUSTMENT(gtk_adjustment_new(
			brush->r * 2, 0.1, 10.0, 0.1, 0.1, 0.0));
		break;
	case 1:
		adjustment = GTK_ADJUSTMENT(gtk_adjustment_new(
			brush->r * 2, 1.0, 100.0, 1.0, 1.0, 0.0));
		break;
	default:
		adjustment = GTK_ADJUSTMENT(gtk_adjustment_new(
			brush->r * 2, 5.0, 500.0, 1.0, 1.0, 0.0));
	}

	(void)g_signal_connect(G_OBJECT(adjustment), "value_changed",
		G_CALLBACK(AdjustmentChangeValueCallBackDouble), &brush->scale);
	SetAdjustmentChangeValueCallBack(adjustment,
		(void (*)(void*))InitializeCustomBrush, brush);
	scale = SpinScaleNew(adjustment, app->labels->tool_box.brush_scale, 1);
	gtk_box_pack_start(GTK_BOX(vbox), scale, FALSE, FALSE, 0);

	g_object_set_data(G_OBJECT(combo), "scale", scale);
	(void)g_signal_connect(G_OBJECT(combo), "changed", G_CALLBACK(SetBrushBaseScale), &brush->base_scale);

	if(is_shape_change == FALSE)
	{
		GtkWidget *button;
		GtkWidget *image;
		GdkPixbuf *pixbuf;
		cairo_t *cairo_p;
		cairo_surface_t *surface_p;
		uint8 *pixel;
		gint stride;

		pixbuf = gdk_pixbuf_new(GDK_COLORSPACE_RGB, TRUE, 8,
			ICON_SIZE, ICON_SIZE);
		pixel = gdk_pixbuf_get_pixels(pixbuf);
		stride = gdk_pixbuf_get_rowstride(pixbuf);
		(void)memset(pixel, 0, ICON_SIZE * stride);
		surface_p = cairo_image_surface_create_for_data(pixel,
			CAIRO_FORMAT_ARGB32, ICON_SIZE, ICON_SIZE, stride);
		cairo_p = cairo_create(surface_p);
		cairo_scale(cairo_p, (FLOAT_T)ICON_SIZE / brush->image_width,
			(FLOAT_T)ICON_SIZE / brush->image_height);
		cairo_set_source_surface(cairo_p, brush->core->brush_surface, 0, 0);
		cairo_paint(cairo_p);

#if defined(USE_BGR_COLOR_SPACE) && USE_BGR_COLOR_SPACE != 0
		{
			uint8 r;
			for(i=0; i<ICON_SIZE*ICON_SIZE; i++)
			{
				r = pixel[i*4];
				pixel[i*4] = pixel[i*4+2];
				pixel[i*4+2] = r;
			}
		}
#endif

		image = gtk_image_new_from_pixbuf(pixbuf);
		button = gtk_button_new();
		gtk_container_add(GTK_CONTAINER(button), image);
		gtk_box_pack_start(GTK_BOX(vbox), button, FALSE, FALSE, 0);
		(void)g_signal_connect(G_OBJECT(button), "clicked",
			G_CALLBACK(ChangeCustomBrushShapeButtonClicked), brush);

		cairo_destroy(cairo_p);
		cairo_surface_destroy(surface_p);

		brush->button_image = image;
	}
	else
	{
		brush->button_image = NULL;
	}

	adjustment = GTK_ADJUSTMENT(gtk_adjustment_new(
		brush->alpha * 100, 0.0, 100.0, 1.0, 1.0, 0.0));
	(void)g_signal_connect(G_OBJECT(adjustment), "value_changed",
		G_CALLBACK(ChangeCustomBrushFlow), brush);
	scale = SpinScaleNew(adjustment, app->labels->tool_box.flow, 1);
	gtk_box_pack_start(GTK_BOX(vbox), scale, FALSE, FALSE, 0);

	adjustment = GTK_ADJUSTMENT(gtk_adjustment_new(
		brush->outline_hardness * 100, 0.0, 100.0, 1.0, 1.0, 0.0));
	(void)g_signal_connect(G_OBJECT(adjustment), "value_changed",
		G_CALLBACK(ChangeCustomBrushOutlineHardness), brush);
	scale = SpinScaleNew(adjustment, app->labels->tool_box.outline_hardness, 1);
	gtk_box_pack_start(GTK_BOX(vbox), scale, FALSE, FALSE, 0);

	adjustment = GTK_ADJUSTMENT(gtk_adjustment_new(
		brush->blur * 100, 0.0, 100.0, 1.0, 1.0, 0.0));
	(void)g_signal_connect(G_OBJECT(adjustment), "value_changed",
		G_CALLBACK(ChangeCustomBrushBlur), brush);
	scale = SpinScaleNew(adjustment, app->labels->tool_box.blur, 1);
	gtk_box_pack_start(GTK_BOX(vbox), scale, FALSE, FALSE, 0);

	// 開始回転角変更用ウィジェット
	adjustment = GTK_ADJUSTMENT(gtk_adjustment_new(
		fabs(brush->start_angle) * 180 / G_PI, 0, 360, 0.1, 0.1, 0));
	scale = SpinScaleNew(adjustment,
		app->labels->tool_box.rotate_start, 1);
	(void)g_signal_connect(G_OBJECT(adjustment), "value_changed",
		G_CALLBACK(ChangeCustomBrushStartAngle), brush);
	gtk_box_pack_start(GTK_BOX(vbox), scale, FALSE, FALSE, 0);

	// 回転速度変更用ウィジェット
	adjustment = GTK_ADJUSTMENT(gtk_adjustment_new(
		fabs(brush->rotate_speed) * 180 / G_PI, 0, 360, 0.1, 0.1, 0));
	scale = SpinScaleNew(adjustment,
		app->labels->tool_box.rotate_speed, 1);
	(void)g_signal_connect(G_OBJECT(adjustment), "value_changed",
		G_CALLBACK(ChangeCustomBrushRotateSpeed), brush);
	gtk_box_pack_start(GTK_BOX(vbox), scale, FALSE, FALSE, 0);

	// 間隔変更用ウィジェット
	adjustment = GTK_ADJUSTMENT(gtk_adjustment_new(
		brush->brush_distance, 0.1, 20, 0.1, 0.1, 0));
	scale = SpinScaleNew(adjustment,
		app->labels->tool_box.distance, 1);
	(void)g_signal_connect(G_OBJECT(adjustment), "value_changed",
		G_CALLBACK(AdjustmentChangeValueCallBackDouble), &brush->brush_distance);
	SetAdjustmentChangeValueCallBack(adjustment,
		(void (*)(void*))InitializeCustomBrush, brush);
	gtk_box_pack_start(GTK_BOX(vbox), scale, FALSE, FALSE, 0);

	radio_buttons[0] = gtk_radio_button_new_with_label(NULL, app->labels->tool_box.saturation);
	radio_buttons[1] = gtk_radio_button_new_with_label(
		gtk_radio_button_get_group(GTK_RADIO_BUTTON(radio_buttons[0])),
		app->labels->tool_box.brightness
	);
	radio_buttons[2] = gtk_radio_button_new_with_label(
		gtk_radio_button_get_group(GTK_RADIO_BUTTON(radio_buttons[0])),
		app->labels->tool_box.gradation_reverse
	);
	gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(radio_buttons[brush->color_mode]), TRUE);
	g_object_set_data(G_OBJECT(radio_buttons[0]), "mode", GINT_TO_POINTER(0));
	(void)g_signal_connect(G_OBJECT(radio_buttons[0]), "toggled", G_CALLBACK(CustomBrushCoreSetMode), brush);
	g_object_set_data(G_OBJECT(radio_buttons[1]), "mode", GINT_TO_POINTER(1));
	(void)g_signal_connect(G_OBJECT(radio_buttons[1]), "toggled", G_CALLBACK(CustomBrushCoreSetMode), brush);
	g_object_set_data(G_OBJECT(radio_buttons[2]), "mode", GINT_TO_POINTER(2));
	(void)g_signal_connect(G_OBJECT(radio_buttons[2]), "toggled", G_CALLBACK(CustomBrushCoreSetMode), brush);
	hbox = gtk_hbox_new(FALSE, 0);
	gtk_box_pack_start(GTK_BOX(hbox), radio_buttons[0], FALSE, TRUE, 0);
	gtk_box_pack_start(GTK_BOX(hbox), radio_buttons[1], FALSE, TRUE, 0);
	gtk_box_pack_start(GTK_BOX(vbox), radio_buttons[2], FALSE, TRUE, 0);
	gtk_box_pack_start(GTK_BOX(vbox), hbox, FALSE, TRUE, 0);

	// 左右反転、上下反転選択用チェックボックス
	hbox = gtk_hbox_new(FALSE, 0);
	label = gtk_label_new("");
	(void)sprintf(mark_up_buff, "<span font_desc=\"%.2f\">%s : </span>",
		UI_FONT_SIZE * app->gui_scale, app->labels->tool_box.reverse);
	gtk_label_set_markup(GTK_LABEL(label), mark_up_buff);
	gtk_box_pack_start(GTK_BOX(hbox), label, FALSE, FALSE, 0);
	check_button = gtk_check_button_new_with_label(app->labels->tool_box.reverse_horizontally);
	CheckButtonSetFlagsCallBack(check_button, &brush->flags, 1 << CUSTOM_BRUSH_FLAG_IMAGE_FLIP_HORIZONTALLY);
	gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(check_button),
		brush->flags & CUSTOM_BRUSH_FLAG_IMAGE_FLIP_HORIZONTALLY);
	gtk_box_pack_start(GTK_BOX(hbox), check_button, FALSE, TRUE, 0);
	check_button = gtk_check_button_new_with_label(app->labels->tool_box.reverse_vertically);
	CheckButtonSetFlagsCallBack(check_button, &brush->flags, 1 << CUSTOM_BRUSH_FLAG_IMAGE_FLIP_VERTICALLY);
	gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(check_button),
		brush->flags & CUSTOM_BRUSH_FLAG_IMAGE_FLIP_VERTICALLY);
	gtk_box_pack_start(GTK_BOX(hbox), check_button, FALSE, TRUE, 0);
	gtk_box_pack_start(GTK_BOX(vbox), hbox, FALSE, TRUE, 0);

	// ブラシの動きに合わせて回転するか否か
	check_button = gtk_check_button_new_with_label(app->labels->tool_box.rotate_to_brush_direction);
	gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(check_button), brush->flags & (1 << CUSTOM_BRUSH_FLAG_ROTATE_BY_CURSOR));
	CheckButtonSetFlagsCallBack(check_button, &brush->flags, 1 << CUSTOM_BRUSH_FLAG_ROTATE_BY_CURSOR);
	hbox = gtk_hbox_new(FALSE, 0);
	gtk_box_pack_start(GTK_BOX(vbox), hbox, FALSE, FALSE, 0);
	gtk_box_pack_start(GTK_BOX(hbox), check_button, FALSE, FALSE, 0);

	// 回転方向変更用ウィジェット
	radio_buttons[0] = gtk_radio_button_new_with_label(NULL, app->labels->tool_box.clockwise);
	radio_buttons[1] = gtk_radio_button_new_with_label(
		gtk_radio_button_get_group(GTK_RADIO_BUTTON(radio_buttons[0])),
		app->labels->tool_box.counter_clockwise
	);

	if(brush->rotate_direction >= 0)
	{
		gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(radio_buttons[0]), TRUE);
	}
	else
	{
		gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(radio_buttons[1]), TRUE);
	}

	hbox = gtk_hbox_new(FALSE, 0);
	g_object_set_data(G_OBJECT(radio_buttons[0]), "rotate_direction", GINT_TO_POINTER(1));
	g_object_set_data(G_OBJECT(radio_buttons[1]), "rotate_direction", GINT_TO_POINTER(-1));
	(void)g_signal_connect(G_OBJECT(radio_buttons[0]), "toggled",
		G_CALLBACK(CustomBrushSetRotateDirection), brush);
	(void)g_signal_connect(G_OBJECT(radio_buttons[1]), "toggled",
		G_CALLBACK(CustomBrushSetRotateDirection), brush);
	gtk_box_pack_start(GTK_BOX(hbox), radio_buttons[0], FALSE, TRUE, 0);
	gtk_box_pack_start(GTK_BOX(hbox), radio_buttons[1], FALSE, TRUE, 0);
	gtk_box_pack_start(GTK_BOX(vbox), hbox, FALSE, TRUE, 0);

	container = gtk_expander_new(app->labels->tool_box.enter_out);
	inner_box = gtk_vbox_new(FALSE, 0);
	gtk_box_pack_start(GTK_BOX(vbox), container, FALSE, FALSE, 0);
	gtk_container_add(GTK_CONTAINER(container), inner_box);
	adjustment = GTK_ADJUSTMENT(gtk_adjustment_new(
		brush->enter * 100, 0.0, 100.0, 1.0, 1.0, 0.0));
	(void)g_signal_connect(G_OBJECT(adjustment), "value_changed",
		G_CALLBACK(ChangeCustomBrushEnter), brush);
	scale = SpinScaleNew(adjustment, app->labels->tool_box.enter, 1);
	gtk_box_pack_start(GTK_BOX(inner_box), scale, FALSE, FALSE, 0);
	adjustment = GTK_ADJUSTMENT(gtk_adjustment_new(
		brush->out * 100, 0.0, 100.0, 1.0, 1.0, 0.0));
	(void)g_signal_connect(G_OBJECT(adjustment), "value_changed",
		G_CALLBACK(ChangeCustomBrushOut), brush);
	scale = SpinScaleNew(adjustment, app->labels->tool_box.out, 1);
	gtk_box_pack_start(GTK_BOX(inner_box), scale, FALSE, FALSE, 0);
	hbox = gtk_hbox_new(FALSE, 0);
	check_button = gtk_check_button_new_with_label(app->labels->tool_box.scale);
	CheckButtonSetFlagsCallBack(check_button, &brush->flags, 1 << CUSTOM_BRUSH_FLAG_ENTER_OUT_SIZE);
	gtk_box_pack_start(GTK_BOX(hbox), check_button, FALSE, FALSE, 0);
	check_button = gtk_check_button_new_with_label(app->labels->tool_box.flow);
	CheckButtonSetFlagsCallBack(check_button, &brush->flags, 1 << CUSTOM_BRUSH_FLAG_ENTER_OUT_FLOW);
	gtk_box_pack_start(GTK_BOX(hbox), check_button, FALSE, FALSE, 0);
	gtk_box_pack_start(GTK_BOX(inner_box), hbox, FALSE, FALSE, 0);

	hbox = gtk_hbox_new(FALSE, 0);
	label = gtk_label_new("");
#if GTK_MAJOR_VERSION <= 2
	combo = gtk_combo_box_new_text();
#else
	combo = gtk_combo_box_text_new();
#endif
	(void)sprintf(mark_up_buff, "<span font_desc=\"%.2f\">%s : </span>",
		UI_FONT_SIZE * app->gui_scale, app->labels->layer_window.blend_mode);
	gtk_label_set_markup(GTK_LABEL(label), mark_up_buff);
	gtk_box_pack_start(GTK_BOX(hbox), label, FALSE, FALSE, 0);
	for(i=0; i<LAYER_BLEND_SLELECTABLE_NUM; i++)
	{
#if GTK_MAJOR_VERSION <= 2
		gtk_combo_box_append_text(GTK_COMBO_BOX(combo), app->labels->layer_window.blend_modes[i]);
#else
		gtk_combo_box_text_append_text(GTK_COMBO_BOX_TEXT(combo), app->labels->layer_window.blend_modes[i]);
#endif
	}
	gtk_combo_box_set_active(GTK_COMBO_BOX(combo), brush->blend_mode);
	(void)g_signal_connect(G_OBJECT(combo), "changed",
		G_CALLBACK(ChangeCustomBrushBlendMode), brush);
	gtk_box_pack_start(GTK_BOX(hbox), combo, FALSE, TRUE, 0);
	gtk_box_pack_start(GTK_BOX(vbox), hbox, FALSE, TRUE, 0);

	// 散布設定
	container = gtk_expander_new(app->labels->tool_box.scatter);
	inner_box = gtk_vbox_new(FALSE, 0);
	gtk_box_pack_start(GTK_BOX(vbox), container, FALSE, TRUE, 0);
	gtk_container_add(GTK_CONTAINER(container), inner_box);
	adjustment = GTK_ADJUSTMENT(gtk_adjustment_new(
		brush->scatter_range * 100, 0.0, 100.0, 1.0, 1.0, 0.0));
	scale = SpinScaleNew(adjustment, app->labels->tool_box.scatter_range, 0);
	(void)g_signal_connect(G_OBJECT(adjustment), "value_changed",
		G_CALLBACK(ChangeCustomBrushScatterRange), brush);
	gtk_box_pack_start(GTK_BOX(inner_box), scale, FALSE, TRUE, 0);
	adjustment = GTK_ADJUSTMENT(gtk_adjustment_new(
		brush->num_scatter, 0.0, 50.0, 1.0, 1.0, 0.0));
	scale = SpinScaleNew(adjustment, app->labels->tool_box.scatter_amount, 0);
	(void)g_signal_connect(G_OBJECT(adjustment), "value_changed",
		G_CALLBACK(AdjustmentChangeValueCallBackInt), &brush->num_scatter);
	gtk_box_pack_start(GTK_BOX(inner_box), scale, FALSE, TRUE, 0);
	adjustment = GTK_ADJUSTMENT(gtk_adjustment_new(
		brush->scatter_size * 100, 0.0, 100.0, 1.0, 1.0, 0.0));
	scale = SpinScaleNew(adjustment, app->labels->tool_box.scatter_size, 0);
	(void)g_signal_connect(G_OBJECT(adjustment), "value_changed",
		G_CALLBACK(ChangeCustomBrushScatterSize), brush);
	gtk_box_pack_start(GTK_BOX(inner_box), scale, FALSE, TRUE, 0);
	adjustment = GTK_ADJUSTMENT(gtk_adjustment_new(
		brush->scatter_random_size * 100, 0.0, 100.0, 1.0, 1.0, 0.0));
	scale = SpinScaleNew(adjustment, app->labels->tool_box.scatter_random_size, 0);
	(void)g_signal_connect(G_OBJECT(adjustment), "value_changed",
		G_CALLBACK(ChangeCustomBrushScatterRandomSize), brush);
	gtk_box_pack_start(GTK_BOX(inner_box), scale, FALSE, TRUE, 0);
	check_button = gtk_check_button_new_with_label(app->labels->tool_box.draw_scatter_only);
	CheckButtonSetFlagsCallBack(check_button, &brush->flags, (1 << CUSTOM_BRUSH_FLAG_DRAW_ONLY_SCATTER));
	gtk_box_pack_start(GTK_BOX(inner_box), check_button, FALSE, FALSE, 0);

	// 筆圧設定
	hbox = gtk_hbox_new(FALSE, 0);
	label = gtk_label_new("");
	(void)sprintf(mark_up_buff, "<span font_desc=\"%.2f\">%s : </span>",
		UI_FONT_SIZE * app->gui_scale, app->labels->tool_box.pressure);
	gtk_label_set_markup(GTK_LABEL(label), mark_up_buff);
	gtk_box_pack_start(GTK_BOX(hbox), label, FALSE, FALSE, 0);
	check_button = gtk_check_button_new_with_label(app->labels->tool_box.scale);
	CheckButtonSetFlagsCallBack(check_button, &brush->flags, (1 << CUSTOM_BRUSH_FLAG_PRESSURE_SIZE));
	gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(check_button), brush->flags & (1 << CUSTOM_BRUSH_FLAG_PRESSURE_SIZE));
	gtk_box_pack_start(GTK_BOX(hbox), check_button, FALSE, TRUE, 0);
	check_button = gtk_check_button_new_with_label(app->labels->tool_box.flow);
	CheckButtonSetFlagsCallBack(check_button, &brush->flags, (1 << CUSTOM_BRUSH_FLAG_PRESSURE_FLOW));
	gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(check_button), brush->flags & (1 << CUSTOM_BRUSH_FLAG_PRESSURE_FLOW));
	gtk_box_pack_start(GTK_BOX(hbox), check_button, FALSE, TRUE, 0);
	gtk_box_pack_start(GTK_BOX(vbox), hbox, FALSE, TRUE, 0);

	check_button = gtk_check_button_new_with_label(app->labels->tool_box.anti_alias);
	CheckButtonSetFlagsCallBack(check_button, &brush->flags, (1 << CUSTOM_BRUSH_FLAG_ANTI_ALIAS));
	gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(check_button), brush->flags & (1 << CUSTOM_BRUSH_FLAG_ANTI_ALIAS));
	gtk_box_pack_start(GTK_BOX(vbox), check_button, FALSE, TRUE, 0);

	radio_buttons[0] = gtk_radio_button_new_with_label(NULL, app->labels->tool_box.normal_brush);
	gtk_box_pack_start(GTK_BOX(vbox), radio_buttons[0], FALSE, FALSE, 0);
	g_object_set_data(G_OBJECT(radio_buttons[0]), "brush_mode", GUINT_TO_POINTER(CUSTOM_BRUSH_MODE_NORMAL));
	(void)g_signal_connect(G_OBJECT(radio_buttons[0]), "toggled",
		G_CALLBACK(ChangeCustomBrushMode), brush);
	radio_buttons[1] = gtk_radio_button_new_with_label(
		gtk_radio_button_get_group(GTK_RADIO_BUTTON(radio_buttons[0])), app->labels->tool_box.brush_default_names[BRUSH_TYPE_BLEND_BRUSH]);
	gtk_box_pack_start(GTK_BOX(vbox), radio_buttons[1], FALSE, FALSE, 0);
	g_object_set_data(G_OBJECT(radio_buttons[1]), "brush_mode", GUINT_TO_POINTER(CUSTOM_BRUSH_MODE_BLEND));
	(void)g_signal_connect(G_OBJECT(radio_buttons[1]), "toggled",
		G_CALLBACK(ChangeCustomBrushMode), brush);
	radio_buttons[2] = gtk_radio_button_new_with_label(
		gtk_radio_button_get_group(GTK_RADIO_BUTTON(radio_buttons[0])), app->labels->tool_box.brush_default_names[BRUSH_TYPE_SMUDGE]);
	gtk_box_pack_start(GTK_BOX(vbox), radio_buttons[2], FALSE, FALSE, 0);
	g_object_set_data(G_OBJECT(radio_buttons[2]), "brush_mode", GUINT_TO_POINTER(CUSTOM_BRUSH_MODE_SMUDGE));
	(void)g_signal_connect(G_OBJECT(radio_buttons[2]), "toggled",
		G_CALLBACK(ChangeCustomBrushMode), brush);
	radio_buttons[3] = gtk_radio_button_new_with_label(
		gtk_radio_button_get_group(GTK_RADIO_BUTTON(radio_buttons[0])), app->labels->tool_box.brush_default_names[BRUSH_TYPE_PICKER_BRUSH]);
	gtk_box_pack_start(GTK_BOX(vbox), radio_buttons[3], FALSE, FALSE, 0);
	g_object_set_data(G_OBJECT(radio_buttons[3]), "brush_mode", GUINT_TO_POINTER(CUSTOM_BRUSH_MODE_PICKER));
	(void)g_signal_connect(G_OBJECT(radio_buttons[3]), "toggled",
		G_CALLBACK(ChangeCustomBrushMode), brush);
	radio_buttons[4] = gtk_radio_button_new_with_label(
		gtk_radio_button_get_group(GTK_RADIO_BUTTON(radio_buttons[0])), app->labels->tool_box.brush_default_names[BRUSH_TYPE_WATER_COLOR_BRUSH]);
	gtk_box_pack_start(GTK_BOX(vbox), radio_buttons[4], FALSE, FALSE, 0);
	g_object_set_data(G_OBJECT(radio_buttons[4]), "brush_mode", GUINT_TO_POINTER(CUSTOM_BRUSH_MODE_WATER_BRUSH));
	(void)g_signal_connect(G_OBJECT(radio_buttons[4]), "toggled",
		G_CALLBACK(ChangeCustomBrushMode), brush);

	gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(radio_buttons[brush->brush_mode]), TRUE);

	(void)g_signal_connect(G_OBJECT(radio_buttons[0]), "toggled",
		G_CALLBACK(ChangeCustomBrushMode), brush);

	brush->mode_detail_setting = CustomBrushModeDetailSettingWidgetNew(brush);
	gtk_box_pack_start(GTK_BOX(vbox), brush->mode_detail_setting, FALSE, FALSE, 0);

	brush->vbox = vbox;

	return vbox;
#undef UI_FONT_SIZE
}

static GtkWidget* CreateCustomBrushDetailUI(APPLICATION* app, BRUSH_CORE* core)
{
	CUSTOM_BRUSH *brush = (CUSTOM_BRUSH*)core->brush_data;
	GtkWidget *vbox = gtk_vbox_new(FALSE, 0);
	GtkWidget *settings;

	brush->core = core;
	settings = CustomBrushSettingWidgetNew(app, brush, FALSE);
	gtk_box_pack_start(GTK_BOX(vbox), settings, FALSE, TRUE, 0);

	return vbox;
}

static void TextToolPressCallBack(
	DRAW_WINDOW* window,
	FLOAT_T x,
	FLOAT_T y,
	FLOAT_T pressure,
	BRUSH_CORE *core,
	void* state
)
{
	if(((GdkEventButton*)state)->button == 1)
	{
		TEXT_TOOL* text = (TEXT_TOOL*)core->brush_data;
		text->start_x = x;
		text->start_y = y;
		text->flags |= TEXT_TOOL_STARTED;
	}
}

static void TextToolMotionCallBack(
	DRAW_WINDOW* window,
	FLOAT_T x,
	FLOAT_T y,
	FLOAT_T pressure,
	BRUSH_CORE *core,
	void* state
)
{
	if(((*(GdkModifierType*)state) & GDK_BUTTON1_MASK) != 0)
	{
		TEXT_TOOL* text = (TEXT_TOOL*)core->brush_data;
		text->end_x = x;
		text->end_y = y;
	}
}

static void TextToolReleaseCallBack(
	DRAW_WINDOW* window,
	FLOAT_T x,
	FLOAT_T y,
	FLOAT_T pressure,
	BRUSH_CORE *core,
	void* state
)
{
	if(((GdkEventButton*)state)->button == 1)
	{
		char name[MAX_LAYER_NAME_LENGTH];
		TEXT_TOOL* text = (TEXT_TOOL*)core->brush_data;
		LAYER* layer;
		FLOAT_T start_x, start_y, width, height;
		uint32 flags = 0;
		int i = 1;

		text->flags &= ~(TEXT_TOOL_STARTED);

		if((text->flags & TEXT_TOOL_VERTICAL) != 0)
		{
			flags |= TEXT_LAYER_VERTICAL;
		}
		if((text->flags & TEXT_TOOL_BOLD) != 0)
		{
			flags |= TEXT_LAYER_BOLD;
		}
		if((text->flags & TEXT_TOOL_ITALIC) != 0)
		{
			flags |= TEXT_LAYER_ITALIC;
		}
		else if((text->flags & TEXT_TOOL_OBLIQUE) != 0)
		{
			flags |= TEXT_LAYER_OBLIQUE;
		}
		if((text->flags & TEXT_TOOL_BALLOON_HAS_EDGE) != 0)
		{
			flags |= TEXT_LAYER_BALLOON_HAS_EDGE;
		}
		if((text->flags & TEXT_TOOL_CENTERING_HORIZONTALLY) != 0)
		{
			flags |= TEXT_LAYER_CENTERING_HORIZONTALLY;
		}
		if((text->flags & TEXT_TOOL_CENTERING_VERTICALLY) != 0)
		{
			flags |= TEXT_LAYER_CENTERING_VERTICALLY;
		}
		if((text->flags & TEXT_TOOL_ADJUST_RANGE_TO_TEXT) != 0)
		{
			flags |= TEXT_LAYER_ADJUST_RANGE_TO_TEXT;
		}

		if(text->start_x > x)
		{
			start_x = x;
			width = text->start_x - x;
		}
		else
		{
			start_x = text->start_x;
			width = x - text->start_x;
		}

		if(text->start_y > y)
		{
			start_y = y;
			height = text->start_y - y;
		}
		else
		{
			start_y = text->start_y;
			height = y - text->start_y;
		}

		do
		{
			(void)sprintf(name, "%s%d", window->app->labels->layer_window.new_text, i);
			i++;
		} while(CorrectLayerName(window->layer, name) == 0);

		layer = CreateLayer(0, 0,
			window->width, window->height, 4, TYPE_TEXT_LAYER,
			window->active_layer, window->active_layer->next, name, window
		);
		window->num_layer++;
		layer->layer_data.text_layer_p = CreateTextLayer(
			window, start_x, start_y, width, height, text->base_size, text->font_size,
				text->font_id, *core->color, text->balloon_type, text->back_color,
					text->line_color, text->line_width, &text->balloon_data, flags
		);

		LayerViewAddLayer(layer, window->layer, window->app->layer_window.view, window->num_layer);
		ChangeActiveLayer(window, layer);
		LayerViewSetActiveLayer(layer, window->app->layer_window.view);
	}
}

static void TextToolDrawCursor(
	DRAW_WINDOW* window,
	FLOAT_T x,
	FLOAT_T y,
	void* data
)
{
	TEXT_TOOL* text = (TEXT_TOOL*)data;
	FLOAT_T start_x, start_y, width, height;

	if((text->flags & TEXT_TOOL_STARTED) == 0)
	{
		return;
	}

	if(text->start_x * window->zoom_rate > x)
	{
		start_x = x;
		width = text->start_x * window->zoom_rate - x;
	}
	else
	{
		start_x = text->start_x * window->zoom_rate;
		width = x - text->start_x * window->zoom_rate;
	}

	if(text->start_y * window->zoom_rate > y)
	{
		start_y = y;
		height = text->start_y * window->zoom_rate - y;
	}
	else
	{
		start_y = text->start_y * window->zoom_rate;
		height = y - text->start_y * window->zoom_rate;
	}

	cairo_set_line_width(window->disp_temp->cairo_p, 1.0);
	cairo_set_source_rgb(window->disp_temp->cairo_p, 1, 1, 1);
	cairo_rectangle(window->disp_temp->cairo_p, start_x, start_y, width, height);
	cairo_stroke(window->disp_temp->cairo_p);
}

static void ChangeTextToolFontFamily(GtkComboBox *combo_box, TEXT_TOOL* text)
{
	text->font_id = gtk_combo_box_get_active(combo_box);
}

static void ChangeTextToolFontSize(GtkAdjustment* slider, TEXT_TOOL* text)
{
	text->font_size = gtk_adjustment_get_value(slider);
}

static void ChangeTextToolWriteDirection(GtkWidget* widget, TEXT_TOOL* text)
{
	if(GPOINTER_TO_INT(g_object_get_data(G_OBJECT(widget), "radio_id")) == 0)
	{
		text->flags &= ~(TEXT_TOOL_VERTICAL);
	}
	else
	{
		text->flags |= TEXT_TOOL_VERTICAL;
	}
}

static void ChangeTextToolBold(GtkWidget* widget, TEXT_TOOL* text)
{
	if(gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(widget)) == FALSE)
	{
		text->flags &= ~(TEXT_TOOL_BOLD);
	}
	else
	{
		text->flags |= TEXT_TOOL_BOLD;
	}
}

static void ChangeTextToolStyle(GtkWidget* widget, TEXT_TOOL* text)
{
	int mode = GPOINTER_TO_INT(g_object_get_data(G_OBJECT(widget), "text-style"));
	switch(mode)
	{
	case TEXT_STYLE_NORMAL:
		text->flags &= ~(TEXT_TOOL_ITALIC | TEXT_TOOL_OBLIQUE);
		break;
	case TEXT_STYLE_ITALIC:
		text->flags &= ~(TEXT_TOOL_OBLIQUE);
		text->flags |= TEXT_TOOL_ITALIC;
		break;
	case TEXT_STYLE_OBLIQUE:
		text->flags &= ~(TEXT_TOOL_ITALIC);
		text->flags |= TEXT_TOOL_OBLIQUE;
		break;
	}
}

static void ChangeTextToolCenteringHorizontally(GtkWidget* button, TEXT_TOOL* text)
{
	if(gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(button)) == FALSE)
	{
		text->flags &= ~(TEXT_TOOL_CENTERING_HORIZONTALLY);
	}
	else
	{
		text->flags |= TEXT_TOOL_CENTERING_HORIZONTALLY;
	}
}

static void ChangeTextToolCenteringVertically(GtkWidget* button, TEXT_TOOL* text)
{
	if(gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(button)) == FALSE)
	{
		text->flags &= ~(TEXT_TOOL_CENTERING_VERTICALLY);
	}
	else
	{
		text->flags |= TEXT_TOOL_CENTERING_VERTICALLY;
	}
}

static void ChangeTextToolBalloonHasEdge(GtkWidget* button, TEXT_TOOL* text)
{
	if(gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(button)) == FALSE)
	{
		text->flags &= ~(TEXT_TOOL_BALLOON_HAS_EDGE);
	}
	else
	{
		text->flags |= TEXT_TOOL_BALLOON_HAS_EDGE;
	}
}

static void ChangeTextToolBackGroundColor(GtkColorButton* button, TEXT_TOOL* text)
{
	GdkColor color;
	guint16 alpha;

	gtk_color_button_get_color(button, &color);
	text->back_color[0] = (uint8)(color.red >> 8);
	text->back_color[1] = (uint8)(color.green >> 8);
	text->back_color[2] = (uint8)(color.blue >> 8);

	alpha = gtk_color_button_get_alpha(button);
	text->back_color[3] = (uint8)(alpha >> 8);
}

static void ChangeTextToolLineColor(GtkColorButton* button, TEXT_TOOL* text)
{
	GdkColor color;
	guint16 alpha;

	gtk_color_button_get_color(button, &color);
	text->line_color[0] = (uint8)(color.red >> 8);
	text->line_color[1] = (uint8)(color.green >> 8);
	text->line_color[2] = (uint8)(color.blue >> 8);

	alpha = gtk_color_button_get_alpha(button);
	text->line_color[3] = (uint8)(alpha >> 8);
}

static void ChangeTextToolLineWidth(GtkAdjustment* slider, TEXT_TOOL* text)
{
	text->line_width = gtk_adjustment_get_value(slider);
}

static void ChangeTextToolAdjust2Text(GtkWidget* button, TEXT_TOOL* text)
{
	if(gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(button)) == FALSE)
	{
		text->flags &= ~(TEXT_TOOL_ADJUST_RANGE_TO_TEXT);
	}
	else
	{
		text->flags |= TEXT_TOOL_ADJUST_RANGE_TO_TEXT;
	}
}

static GtkWidget* CreateTextToolDetailUI(APPLICATION* app, BRUSH_CORE* core)
{
#define MAX_STR_LENGTH 256
#define UI_FONT_SIZE 8.0
	TEXT_TOOL *text = (TEXT_TOOL*)core->brush_data;
	GtkWidget *vbox = gtk_vbox_new(FALSE, 0), *hbox = gtk_hbox_new(FALSE, 0);
#if GTK_MAJOR_VERSION <= 2
	GtkWidget *font_selection = gtk_combo_box_new_text();
#else
	GtkWidget *font_selection = gtk_combo_box_text_new();
#endif
	GtkWidget *control;
	GtkWidget *font_scale, *label;
	GtkWidget *base_scale;
	GtkWidget *scale;
	GtkWidget *radio_buttons[3];
	GtkWidget *button;
	GtkAdjustment *adjust;
	GdkColor color;
	GList *list;
	const gchar *font_name;
	char item_str[MAX_STR_LENGTH];
	int i;

	for(i=0; i<app->num_font; i++)
	{
		font_name = pango_font_family_get_name(app->font_list[i]);
		(void)sprintf(item_str, "<span font_family=\"%s\">%s</span>",
			font_name, font_name);
#if GTK_MAJOR_VERSION <= 2
		gtk_combo_box_append_text(GTK_COMBO_BOX(font_selection), item_str);
#else
		gtk_combo_box_text_append_text(GTK_COMBO_BOX(font_selection), item_str);
#endif
	}
	list = gtk_cell_layout_get_cells(GTK_CELL_LAYOUT(font_selection));
	gtk_cell_layout_set_attributes(GTK_CELL_LAYOUT(font_selection), list->data, "markup", 0, NULL);
	gtk_widget_set_size_request(font_selection, 128, 32);
	gtk_combo_box_set_active(GTK_COMBO_BOX(font_selection), text->font_id);
	(void)g_signal_connect(G_OBJECT(font_selection), "changed", G_CALLBACK(ChangeTextToolFontFamily), core->brush_data);
	gtk_box_pack_start(GTK_BOX(vbox), font_selection, FALSE, TRUE, 0);

	switch(text->base_size)
	{
	case 0:
		adjust = GTK_ADJUSTMENT(gtk_adjustment_new(text->font_size, 0.1, 10, 0.1, 1, 0));
		break;
	case 1:
		adjust = GTK_ADJUSTMENT(gtk_adjustment_new(text->font_size, 1, 100, 1, 10, 0));
		break;
	default:
		adjust = GTK_ADJUSTMENT(gtk_adjustment_new(text->font_size, 5, 500, 1, 10, 0));
	}

	font_scale = SpinScaleNew(adjust,
		app->labels->tool_box.scale, 1);
	(void)g_signal_connect(G_OBJECT(adjust), "value_changed",
		G_CALLBACK(ChangeTextToolFontSize), core->brush_data);

	{
		const char *mag_str[] = {"x 0.1", "x 1", "x 10"};
		label = gtk_label_new("");
		(void)sprintf(item_str, "<span font_desc=\"%.2f\">%s : </span>",
			UI_FONT_SIZE * app->gui_scale, app->labels->tool_box.base_scale);
		gtk_label_set_markup(GTK_LABEL(label), item_str);
		gtk_box_pack_start(GTK_BOX(hbox), label, FALSE, FALSE, 0);
#if GTK_MAJOR_VERSION <= 2
		base_scale = gtk_combo_box_new_text();
		gtk_combo_box_append_text(GTK_COMBO_BOX(base_scale), mag_str[0]);
		gtk_combo_box_append_text(GTK_COMBO_BOX(base_scale), mag_str[1]);
		gtk_combo_box_append_text(GTK_COMBO_BOX(base_scale), mag_str[2]);
#else
		base_scale = gtk_combo_box_text_new();
		gtk_combo_box_text_append_text(GTK_COMBO_BOX_TEXT(base_scale), mag_str[0]);
		gtk_combo_box_text_append_text(GTK_COMBO_BOX_TEXT(base_scale), mag_str[1]);
		gtk_combo_box_text_append_text(GTK_COMBO_BOX_TEXT(base_scale), mag_str[2]);
#endif
		gtk_combo_box_set_active(GTK_COMBO_BOX(base_scale), text->base_size);
		gtk_box_pack_start(GTK_BOX(hbox), base_scale, TRUE, TRUE, 0);
		gtk_box_pack_start(GTK_BOX(vbox), hbox, FALSE, FALSE, 0);
	}

	hbox = gtk_hbox_new(FALSE, 0);
	gtk_box_pack_start(GTK_BOX(hbox), font_scale, TRUE, TRUE, 0);
	gtk_box_pack_start(GTK_BOX(vbox), hbox, FALSE, TRUE, 0);

	g_object_set_data(G_OBJECT(base_scale), "scale", font_scale);
	(void)g_signal_connect(G_OBJECT(base_scale), "changed", G_CALLBACK(SetBrushBaseScale), &text->base_size);

	hbox = gtk_hbox_new(TRUE, 0);
	radio_buttons[0] = gtk_radio_button_new_with_label(
		NULL, app->labels->tool_box.text_horizonal);
	radio_buttons[1] = gtk_radio_button_new_with_label(
		gtk_radio_button_get_group(GTK_RADIO_BUTTON(radio_buttons[0])),
		app->labels->tool_box.text_vertical
	);

	for(i=0; i<2; i++)
	{
		g_object_set_data(G_OBJECT(radio_buttons[i]), "radio_id", GINT_TO_POINTER(i));
		(void)g_signal_connect(G_OBJECT(radio_buttons[i]), "toggled",
			G_CALLBACK(ChangeTextToolWriteDirection), core->brush_data);
		gtk_box_pack_start(GTK_BOX(hbox), radio_buttons[i], FALSE, TRUE, 0);
	}

	if((text->flags & TEXT_TOOL_VERTICAL) == 0)
	{
		gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(radio_buttons[0]), TRUE);
	}
	else
	{
		gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(radio_buttons[1]), TRUE);
	}

	gtk_box_pack_start(GTK_BOX(vbox), hbox, FALSE, TRUE, 0);

	hbox = gtk_hbox_new(FALSE, 2);
	label = gtk_label_new("");
	(void)sprintf(item_str, "<span font_desc=\"%.2f\">%s</span>",
		UI_FONT_SIZE * app->gui_scale, app->labels->tool_box.text_style);
	gtk_label_set_markup(GTK_LABEL(label), item_str);
	gtk_box_pack_start(GTK_BOX(hbox), label, FALSE, FALSE, 0);
	gtk_box_pack_start(GTK_BOX(vbox), hbox, FALSE, TRUE, 0);

	button = gtk_check_button_new_with_label(app->labels->tool_box.text_bold);
	(void)g_signal_connect(G_OBJECT(button), "toggled", G_CALLBACK(ChangeTextToolBold), core->brush_data);
	gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(button), text->flags & TEXT_TOOL_BOLD);
	gtk_box_pack_start(GTK_BOX(hbox), button, FALSE, TRUE, 0);

	hbox = gtk_hbox_new(TRUE, 0);
	radio_buttons[0] = gtk_radio_button_new_with_label(
		NULL, app->labels->tool_box.text_normal);
	radio_buttons[1] = gtk_radio_button_new_with_label(
		gtk_radio_button_get_group(GTK_RADIO_BUTTON(radio_buttons[0])),
		app->labels->tool_box.text_italic
	);
	radio_buttons[2] = gtk_radio_button_new_with_label(
		gtk_radio_button_get_group(GTK_RADIO_BUTTON(radio_buttons[0])),
		app->labels->tool_box.text_oblique
	);

	for(i=0; i<3; i++)
	{
		g_object_set_data(G_OBJECT(radio_buttons[i]), "text-style",
			GINT_TO_POINTER(i));
		(void)g_signal_connect(G_OBJECT(radio_buttons[i]), "toggled",
			G_CALLBACK(ChangeTextToolStyle), core->brush_data);
	}
	gtk_box_pack_start(GTK_BOX(hbox), radio_buttons[0], FALSE, TRUE, 0);
	gtk_box_pack_start(GTK_BOX(hbox), radio_buttons[1], FALSE, TRUE, 0);
	if((text->flags & TEXT_TOOL_ITALIC) != 0)
	{
		gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(radio_buttons[1]), TRUE);
	}
	else if((text->flags & TEXT_TOOL_OBLIQUE) != 0)
	{
		gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(radio_buttons[2]), TRUE);
	}
	else
	{
		gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(radio_buttons[0]), TRUE);
	}
	gtk_box_pack_start(GTK_BOX(vbox), hbox, FALSE, TRUE, 0);
	gtk_box_pack_start(GTK_BOX(vbox), radio_buttons[2], FALSE, TRUE, 0);

	button = gtk_check_button_new_with_label(app->labels->tool_box.centering_horizontally);
	gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(button),
		text->flags & TEXT_TOOL_CENTERING_HORIZONTALLY);
	(void)g_signal_connect(G_OBJECT(button), "toggled",
		G_CALLBACK(ChangeTextToolCenteringHorizontally), text);
	gtk_box_pack_start(GTK_BOX(vbox), button, FALSE, FALSE, 0);

	button = gtk_check_button_new_with_label(app->labels->tool_box.centering_vertically);
	gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(button),
		text->flags & TEXT_TOOL_CENTERING_VERTICALLY);
	(void)g_signal_connect(G_OBJECT(button), "toggled",
		G_CALLBACK(ChangeTextToolCenteringVertically), text);
	gtk_box_pack_start(GTK_BOX(vbox), button, FALSE, FALSE, 0);

	control = TextLayerSelectBalloonTypeWidgetNew(
		&text->balloon_type, NULL, NULL, &text->balloon_widgets, app);
	gtk_box_pack_start(GTK_BOX(vbox), control, FALSE, FALSE, 0);

	hbox = gtk_hbox_new(FALSE, 0);
	(void)sprintf(item_str, "%s : ", app->labels->unit.bg);
	color.red = (text->back_color[0] << 8) | text->back_color[0];
	color.green = (text->back_color[1] << 8) | text->back_color[1];
	color.blue = (text->back_color[2] << 8) | text->back_color[2];
	button = gtk_color_button_new_with_color(&color);
	gtk_color_button_set_use_alpha(GTK_COLOR_BUTTON(button), TRUE);
	gtk_color_button_set_alpha(GTK_COLOR_BUTTON(button), (text->back_color[3] << 8) | text->back_color[3]);
	(void)g_signal_connect(G_OBJECT(button), "color-set",
		G_CALLBACK(ChangeTextToolBackGroundColor), text);
	gtk_box_pack_start(GTK_BOX(hbox), gtk_label_new(item_str), FALSE, FALSE, 0);
	gtk_box_pack_start(GTK_BOX(hbox), button, FALSE, TRUE, 0);
	gtk_box_pack_start(GTK_BOX(vbox), hbox, FALSE, FALSE, 0);

	hbox = gtk_hbox_new(FALSE, 0);
	(void)sprintf(item_str, "%s : ", app->labels->tool_box.line_color);
	color.red = (text->line_color[0] << 8) | text->line_color[0];
	color.green = (text->line_color[1] << 8) | text->line_color[1];
	color.blue = (text->line_color[2] << 8) | text->line_color[2];
	button = gtk_color_button_new_with_color(&color);
	gtk_color_button_set_use_alpha(GTK_COLOR_BUTTON(button), TRUE);
	gtk_color_button_set_alpha(GTK_COLOR_BUTTON(button), (text->line_color[3] << 8) | text->line_color[3]);
	(void)g_signal_connect(G_OBJECT(button), "color-set",
		G_CALLBACK(ChangeTextToolLineColor), text);
	gtk_box_pack_start(GTK_BOX(hbox), gtk_label_new(item_str), FALSE, FALSE, 0);
	gtk_box_pack_start(GTK_BOX(hbox), button, FALSE, TRUE, 0);
	gtk_box_pack_start(GTK_BOX(vbox), hbox, FALSE, FALSE, 0);

	button = gtk_check_button_new_with_label(app->labels->tool_box.balloon_has_edge);
	gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(button),
		text->flags & TEXT_TOOL_BALLOON_HAS_EDGE);
	(void)g_signal_connect(G_OBJECT(button), "toggled",
		G_CALLBACK(ChangeTextToolBalloonHasEdge), text);
	gtk_box_pack_start(GTK_BOX(vbox), button, FALSE, FALSE, 0);

	adjust = GTK_ADJUSTMENT(gtk_adjustment_new(text->line_width, 0.1, 100, 1, 1, 0));
	scale = SpinScaleNew(adjust, app->labels->tool_box.line_width, 1);
	(void)g_signal_connect(G_OBJECT(adjust), "value_changed",
		G_CALLBACK(ChangeTextToolLineWidth), text);
	gtk_box_pack_start(GTK_BOX(vbox), scale, FALSE, FALSE, 0);

	button = gtk_check_button_new_with_label(app->labels->tool_box.adjust_range_to_text);
	gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(button),
		text->flags & TEXT_TOOL_ADJUST_RANGE_TO_TEXT);
	(void)g_signal_connect(G_OBJECT(button), "toggled",
		G_CALLBACK(ChangeTextToolAdjust2Text), text);
	gtk_box_pack_start(GTK_BOX(vbox), button, FALSE, FALSE, 0);

	gtk_box_pack_start(GTK_BOX(vbox), CreateBalloonDetailSettinWidget(&text->balloon_data, &text->balloon_widgets,
		NULL, NULL, app), FALSE, FALSE, 0);

	g_list_free(list);

	return vbox;
#undef UI_FONT_SIZE
}

static void ScriptBrushButtonPressCallBack(
	DRAW_WINDOW* window,
	FLOAT_T x,
	FLOAT_T y,
	FLOAT_T pressure,
	BRUSH_CORE *core,
	void* state
)
{
	// 左クリックなら
	if(((GdkEventButton*)state)->button == 1)
	{
		SCRIPT *script = (SCRIPT*)core->brush_data;
		script->brush_data->flags &= ~(SCRIPT_BRUSH_STARTED);
		window->work_layer->layer_mode = script->brush_data->blend_mode;
		script->brush_data->distance = 0;
		script->brush_data->before_x = x;
		script->brush_data->before_y = y;

		lua_getglobal(script->state, "button_press");

		lua_pushnumber(script->state, x);
		lua_pushnumber(script->state, y);
		lua_pushnumber(script->state, pressure);

		lua_createtable(script->state, 0, 3);
		lua_pushinteger(script->state, ((GdkEventButton*)state)->button);
		lua_setfield(script->state, -2, "button");
		lua_pushunsigned(script->state, ((GdkEventButton*)state)->time);
		lua_setfield(script->state, -2, "event_time");
		lua_pushunsigned(script->state, ((GdkEventButton*)state)->state);
		lua_setfield(script->state, -2, "state");

		lua_call(script->state, 4, 0);
	}
}

static void ScriptBrushMotionCallBack(
	DRAW_WINDOW* window,
	FLOAT_T x,
	FLOAT_T y,
	FLOAT_T pressure,
	BRUSH_CORE *core,
	void* state
)
{
	if(((*(GdkModifierType*)state) & GDK_BUTTON1_MASK) != 0)
	{
		SCRIPT *script = (SCRIPT*)core->brush_data;
		script->brush_data->distance = 0;

		script->brush_data->distance += sqrt(
			(script->brush_data->before_x-x)*(script->brush_data->before_x-x)
				+(script->brush_data->before_y-y)*(script->brush_data->before_y-y)
		);
		script->brush_data->before_x = x;
		script->brush_data->before_y = y;

		lua_getglobal(script->state, "motion_notify");

		lua_pushnumber(script->state, x);
		lua_pushnumber(script->state, y);
		lua_pushnumber(script->state, pressure);

		lua_createtable(script->state, 0, 2);
		lua_pushunsigned(script->state, gtk_get_current_event_time());
		lua_setfield(script->state, -2, "event_time");
		lua_pushunsigned(script->state, *(GdkModifierType*)state);
		lua_setfield(script->state, -2, "state");

		lua_call(script->state, 4, 0);
	}
}

static void ScriptBrushButtonReleaseCallBack(
	DRAW_WINDOW* window,
	FLOAT_T x,
	FLOAT_T y,
	FLOAT_T pressure,
	BRUSH_CORE *core,
	void* state
)
{
	// 左クリックなら
	if(((GdkEventButton*)state)->button == 1)
	{
		SCRIPT *script = (SCRIPT*)core->brush_data;

		lua_getglobal(script->state, "button_release");

		lua_pushnumber(script->state, x);
		lua_pushnumber(script->state, y);
		lua_pushnumber(script->state, pressure);

		lua_createtable(script->state, 0, 3);
		lua_pushinteger(script->state, ((GdkEventButton*)state)->button);
		lua_setfield(script->state, -2, "button");
		lua_pushunsigned(script->state, ((GdkEventButton*)state)->time);
		lua_setfield(script->state, -2, "event_time");
		lua_pushunsigned(script->state, ((GdkEventButton*)state)->state);
		lua_setfield(script->state, -2, "state");

		lua_call(script->state, 4, 0);

		AddBrushHistory(core, window->active_layer);

		window->update.surface_p = cairo_surface_create_for_rectangle(
			window->active_layer->surface_p, window->update.x, window->update.y,
				window->update.width, window->update.height);
		window->update.cairo_p = cairo_create(window->update.surface_p);

		window->part_layer_blend_functions[window->work_layer->layer_mode](window->work_layer, &window->update);

		(void)memset(window->work_layer->pixels, 0, window->work_layer->stride*window->work_layer->height);

		cairo_surface_destroy(window->update.surface_p);
		cairo_destroy(window->update.cairo_p);

		window->work_layer->layer_mode = LAYER_BLEND_NORMAL;
	}
}

static void ScriptBrushDrawCursor(DRAW_WINDOW* window, FLOAT_T x, FLOAT_T y, void *data)
{
	SCRIPT *script = (SCRIPT*)data;
	SCRIPT_BRUSH *brush = script->brush_data;
	if(script->brush_data->cursor_pixels == NULL)
	{
		FLOAT_T r = brush->r * window->zoom_rate;
		cairo_set_line_width(window->disp_temp->cairo_p, 1.0);
		cairo_set_source_rgb(window->disp_temp->cairo_p, 1, 1, 1);
		cairo_arc(window->disp_temp->cairo_p, x, y, r, 0, 2*G_PI);
		cairo_stroke(window->disp_temp->cairo_p);

		cairo_rectangle(window->disp_layer->cairo_p, x - r, y - r,
			(r + BRUSH_UPDATE_MARGIN) * 2, (r + BRUSH_UPDATE_MARGIN) * 2);
		cairo_clip(window->disp_layer->cairo_p);
	}
	else
	{
		// カーソルブラシ
		cairo_pattern_t *cursor_pattern;
		// カーソルの拡大縮小、回転・平行移動用の行列
		cairo_matrix_t matrix;
		// カーソルの平行・回転移動用
		FLOAT_T trans_x, trans_y;
		FLOAT_T cos_x, sin_y;
		FLOAT_T half_width, half_height;
		FLOAT_T rev_zoom = window->rev_zoom * (1 / brush->zoom);

		// 平行移動する座標を計算
		half_width = brush->width * 0.5 * brush->zoom * window->zoom_rate;
		half_height = brush->height * 0.5 * brush->zoom * window->zoom_rate;
		cos_x = cos(brush->arg), sin_y = sin(brush->arg);
		trans_x = x - (half_width * cos_x + half_height * sin_y);
		trans_y = y + (half_width * sin_y - half_height * cos_x);
		// 拡大縮小率、回転角をセット
		cursor_pattern = cairo_pattern_create_for_surface(brush->cursor_surface);
		cairo_pattern_set_extend(cursor_pattern, CAIRO_EXTEND_NONE);
		cairo_matrix_init_scale(&matrix, rev_zoom, rev_zoom);
		cairo_matrix_rotate(&matrix, brush->arg);
		cairo_matrix_translate(&matrix, - trans_x, - trans_y);
		cairo_pattern_set_matrix(cursor_pattern, &matrix);

		cairo_set_source_rgb(window->disp_temp->cairo_p, 1, 1, 1);
		cairo_mask(window->disp_temp->cairo_p, cursor_pattern);

		cairo_rectangle(window->disp_layer->cairo_p, (int)(x - half_width - 1),
			(int)(y - half_height - 1), (int)half_width*2+2, (int)half_height*2+2);
		cairo_clip(window->disp_layer->cairo_p);

		cairo_pattern_destroy(cursor_pattern);
	}
}

static void ScriptBrushButtonUpdate(DRAW_WINDOW* window, FLOAT_T x, FLOAT_T y, SCRIPT* script)
{
	FLOAT_T r = script->brush_data->r * window->zoom_rate + 3;
	gtk_widget_queue_draw_area(window->window, (gint)(x - r - 1),
		(gint)(y - r - 1), (gint)(r * 2 + 3), (gint)(r * 2 + 3));
}

static void ScriptBrushMotionUpdate(DRAW_WINDOW* window, FLOAT_T x, FLOAT_T y, SCRIPT* script)
{
	FLOAT_T start_x, start_y;
	FLOAT_T width, height;
	FLOAT_T r = script->brush_data->r * script->brush_data->zoom
		* window->zoom_rate  * 1.275 + BRUSH_UPDATE_MARGIN;

	if(window->before_cursor_x < x)
	{
		start_x = window->before_cursor_x - r;
		width = r * 2 + x - window->before_cursor_x;
	}
	else
	{
		start_x = x - r;
		width = r * 2 + window->before_cursor_x - x;
	}

	if(window->before_cursor_y < y)
	{
		start_y = window->before_cursor_y - r;
		height = r * 2 + y - window->before_cursor_y;
	}
	else
	{
		start_y = y - r;
		height = r * 2 + window->before_cursor_y - y;
	}

	gtk_widget_queue_draw_area(window->window,
		(gint)start_x, (gint)start_y, (gint)width + 2, (gint)height + 2);
}

static void ScriptBrushColorChange(const uint8 color[3], void* data)
{
	SCRIPT *script = (SCRIPT*)data;
	ScriptBrushPatternNew(script);
}

static GtkWidget* CreateScriptBrushDetailUI(APPLICATION* app, BRUSH_CORE* core)
{
	SCRIPT *script = (SCRIPT*)core->brush_data;
	GtkWidget *ui;

	script->brush_data->core = core;

	lua_getglobal(script->state, "ui_new");
	lua_call(script->state, 0, 1);
	ui = GTK_WIDGET(lua_topointer(script->state, 1));
	lua_pop(script->state, 1);

	ScriptBrushPatternNew(script);

	return ui;
}

static GtkWidget* CreatePlugInBrushDetailUI(APPLICATION* app, BRUSH_CORE* core);

gboolean LoadPlugInBrushCallbacks(GModule* module, BRUSH_CORE* core, PLUG_IN_BRUSH* brush)
{
	gpointer function;

	if(g_module_symbol(module, "ButtonPress", (gpointer*)&core->press_func) == FALSE)
	{
		return FALSE;
	}

	if(g_module_symbol(module, "Motion", (gpointer*)&core->motion_func) == FALSE)
	{
		return FALSE;
	}

	if(g_module_symbol(module, "ButtonRelease", (gpointer*)&core->release_func) == FALSE)
	{
		return FALSE;
	}

	if(g_module_symbol(module, "DrawCursor", (gpointer*)&core->draw_cursor) == FALSE)
	{
		return FALSE;
	}

	if(g_module_symbol(module, "ButtonUpdate", (gpointer*)&core->button_update) == FALSE)
	{
		core->button_update = DefaultToolUpdate;
	}

	if(g_module_symbol(module, "MotionUpdate", (gpointer*)&core->motion_update) == FALSE)
	{
		core->motion_update = DefaultToolUpdate;
	}

	(void)g_module_symbol(module, "ColorChange", (gpointer*)&core->color_change);

	if(g_module_symbol(module, "SettingWidgetNew", (gpointer*)&function) == FALSE)
	{
		return FALSE;
	}
	else
	{
		if(brush != NULL)
		{
			brush->setting_widget_new = (GtkWidget* (*)(APPLICATION*, BRUSH_CORE*))function;
			core->create_detail_ui = CreatePlugInBrushDetailUI;
		}
	}

	return TRUE;
}

static GtkWidget* CreatePlugInBrushDetailUI(APPLICATION* app, BRUSH_CORE* core)
{
	PLUG_IN_BRUSH *brush = (PLUG_IN_BRUSH*)core->brush_data;
	gchar *file_path;

	if(app->tool_window.plug_in_brush != NULL)
	{
		(void)g_module_close(app->tool_window.plug_in_brush);
	}

	file_path = g_build_filename(app->current_path, PLUG_IN_DIRECTORY, brush->plug_in_name, NULL);

	app->tool_window.plug_in_brush = g_module_open(file_path, G_MODULE_BIND_LOCAL);
	g_free(file_path);

	LoadPlugInBrushCallbacks(app->tool_window.plug_in_brush, core, brush);

	return brush->setting_widget_new(app, core);
}

void LoadBrushDetailData(
	BRUSH_CORE* core,
	INI_FILE_PTR file,
	const char* section_name,
	const char* brush_type,
	APPLICATION* app
)
{
	if(StringCompareIgnoreCase(brush_type, "PENCIL") == 0)
	{
		PENCIL* pen;
		core->brush_type = (uint8)BRUSH_TYPE_PENCIL;
		core->brush_data = MEM_ALLOC_FUNC(sizeof(*pen));
		(void)memset(core->brush_data, 0, sizeof(*pen));
		core->detail_data_size = sizeof(*pen);
		pen = (PENCIL*)core->brush_data;

		pen->base_scale = IniFileGetInteger(file, section_name, "MAGNIFICATION");
		pen->r = IniFileGetInteger(file, section_name, "SIZE") * 0.5;
		pen->alpha = IniFileGetInteger(file, section_name, "FLOW");
		pen->outline_hardness = IniFileGetInteger(file, section_name, "OUTLINE_HARDNESS");
		pen->minimum_pressure = IniFileGetInteger(file, section_name, "MINIMUM_PRESSURE") * 0.01;
		if(pen->minimum_pressure < 0.005)
		{
			pen->minimum_pressure = 0.005;
		}
		core->press_func = PencilPressCallBack;
		core->motion_func = PencilMotionCallBack;
		core->release_func = PencilReleaseCallBack;
		core->draw_cursor = PencilDrawCursor;
		core->button_update = (brush_update_func)PencilButtonUpdate;
		core->motion_update = (brush_update_func)PencilMotionUpdate;
		core->color_change = PencilColorChange;
		core->create_detail_ui = CreatePencilDetailUI;
		if(IniFileGetInteger(file, section_name, "PRESSURE_SIZE") != 0)
		{
			pen->flags |= BRUSH_FLAG_SIZE;
		}
		if(IniFileGetInteger(file, section_name, "PRESSURE_FLOW") != 0)
		{
			pen->flags |= BRUSH_FLAG_FLOW;
		}
		if(IniFileGetInteger(file, section_name, "ANTI_ALIAS") != 0)
		{
			pen->flags |= BRUSH_FLAG_ANTI_ALIAS;
		}
	}
	else if(StringCompareIgnoreCase(brush_type, "HARD_PEN") == 0)
	{
		HARD_PEN *pen;
		core->brush_type = (uint8)BRUSH_TYPE_HARD_PEN;
		core->brush_data = MEM_ALLOC_FUNC(sizeof(*pen));
		(void)memset(core->brush_data, 0, sizeof(*pen));
		core->detail_data_size = sizeof(*pen);
		pen = (HARD_PEN*)core->brush_data;

		pen->base_scale = IniFileGetInteger(file, section_name, "MAGNIFICATION");
		pen->r = IniFileGetInteger(file, section_name, "SIZE") * 0.5;
		pen->alpha = IniFileGetInteger(file, section_name, "FLOW");
		pen->minimum_pressure = IniFileGetInteger(file, section_name, "MINIMUM_PRESSURE") * 0.01;
		if(pen->minimum_pressure < 0.005)
		{
			pen->minimum_pressure = 0.005;
		}
		core->press_func = HardPenButtonPressCallBack;
		core->motion_func = HardPenMotionCallBack;
		core->release_func = HardPenButtonReleaseCallBack;
		core->draw_cursor = HardPenDrawCursor;
		core->button_update = (brush_update_func)HardPenButtonUpdate;
		core->motion_update = (brush_update_func)HardPenMotionUpdate;
		core->create_detail_ui = CreateHardPenDetailUI;
		if(IniFileGetInteger(file, section_name, "PRESSURE_SIZE") != 0)
		{
			pen->flags |= BRUSH_FLAG_SIZE;
		}
		if(IniFileGetInteger(file, section_name, "PRESSURE_FLOW") != 0)
		{
			pen->flags |= BRUSH_FLAG_FLOW;
		}
		if(IniFileGetInteger(file, section_name, "ANTI_ALIAS") != 0)
		{
			pen->flags |= BRUSH_FLAG_ANTI_ALIAS;
		}
	}
	else if(StringCompareIgnoreCase(brush_type, "AIR_BRUSH") == 0)
	{
		AIR_BRUSH* brush;
		core->brush_type = (uint8)BRUSH_TYPE_AIR_BRUSH;
		core->brush_data = MEM_ALLOC_FUNC(sizeof(*brush));
		(void)memset(core->brush_data, 0, sizeof(*brush));
		core->detail_data_size = sizeof(*brush);
		brush = (AIR_BRUSH*)core->brush_data;

		brush->base_scale = IniFileGetInteger(file, section_name, "MAGNIFICATION");
		brush->r = IniFileGetInteger(file, section_name, "SIZE") * 0.5;
		brush->opacity = IniFileGetInteger(file, section_name, "FLOW");
		brush->outline_hardness = IniFileGetInteger(file, section_name, "OUTLINE_HARDNESS");
		brush->blur = IniFileGetInteger(file, section_name, "BLUR");
		brush->enter = IniFileGetInteger(file, section_name, "ENTER_SIZE");
		brush->out = IniFileGetInteger(file, section_name, "OUT_SIZE");
		brush->blend_mode = IniFileGetInteger(file, section_name, "BLEND_MODE");
		brush->core = core;

		core->press_func = AirBrushPressCallBack;
		core->motion_func = AirBrushMotionCallBack;
		core->release_func = AirBrushReleaseCallBack;
		core->draw_cursor = AirBrushDrawCursor;
		core->button_update = (brush_update_func)AirBrushButtonUpdate;
		core->motion_update = (brush_update_func)AirBrushMotionUpdate;
		core->create_detail_ui = CreateAirBrushDetailUI;
		core->color_change = AirBrushColorChange;

		if(IniFileGetInteger(file, section_name, "PRESSURE_SIZE") != 0)
		{
			brush->flags |= BRUSH_FLAG_SIZE;
		}
		if(IniFileGetInteger(file, section_name, "PRESSURE_FLOW") != 0)
		{
			brush->flags |= BRUSH_FLAG_FLOW;
		}
		if(IniFileGetInteger(file, section_name, "ANTI_ALIAS") != 0)
		{
			brush->flags |= BRUSH_FLAG_ANTI_ALIAS;
		}
	}
	else if(StringCompareIgnoreCase(brush_type, "OLD_AIR_BRUSH") == 0)
	{
		OLD_AIR_BRUSH* brush;
		core->brush_type = (uint8)BRUSH_TYPE_OLD_AIR_BRUSH;
		core->brush_data = MEM_ALLOC_FUNC(sizeof(*brush));
		(void)memset(core->brush_data, 0, sizeof(*brush));
		core->detail_data_size = sizeof(*brush);
		brush = (OLD_AIR_BRUSH*)core->brush_data;

		brush->r = IniFileGetInteger(file, section_name, "SIZE") * 0.5;
		brush->opacity = IniFileGetInteger(file, section_name, "FLOW");
		brush->outline_hardness = IniFileGetInteger(file, section_name, "OUTLINE_HARDNESS");
		brush->blur = IniFileGetInteger(file, section_name, "BLUR");

		core->press_func = OldAirBrushPressCallBack;
		core->motion_func = OldAirBrushMotionCallBack;
		core->release_func = OldAirBrushReleaseCallBack;
		core->draw_cursor = OldAirBrushDrawCursor;
		core->create_detail_ui = CreateOldAirBrushDetailUI;
		if(IniFileGetInteger(file, section_name, "PRESSURE_SIZE") != 0)
		{
			brush->flags |= BRUSH_FLAG_SIZE;
		}
		if(IniFileGetInteger(file, section_name, "PRESSURE_FLOW") != 0)
		{
			brush->flags |= BRUSH_FLAG_FLOW;
		}
	}
	else if(StringCompareIgnoreCase(brush_type, "BLEND_BRUSH") == 0)
	{
		BLEND_BRUSH* brush;
		core->brush_type = (uint8)BRUSH_TYPE_BLEND_BRUSH;
		core->brush_data = MEM_ALLOC_FUNC(sizeof(*brush));
		(void)memset(core->brush_data, 0, sizeof(*brush));
		core->detail_data_size = sizeof(*brush);
		brush = (BLEND_BRUSH*)core->brush_data;

		brush->base_scale = IniFileGetInteger(file, section_name, "MAGNIFICATION");
		brush->r = IniFileGetInteger(file, section_name, "SIZE") * 0.5;
		brush->opacity = IniFileGetInteger(file, section_name, "FLOW");
		brush->outline_hardness = IniFileGetInteger(file, section_name, "OUTLINE_HARDNESS");
		brush->blur = IniFileGetInteger(file, section_name, "BLUR");
		brush->enter = IniFileGetInteger(file, section_name, "ENTER_SIZE");
		brush->out = IniFileGetInteger(file, section_name, "OUT_SIZE");
		brush->target = IniFileGetInteger(file, section_name, "TARGET");
		brush->blend_mode = IniFileGetInteger(file, section_name, "BLEND_MODE");
		brush->core = core;

		core->press_func = BlendBrushButtonPressCallBack;
		core->motion_func = BlendBrushMotionCallBack;
		core->release_func = BlendBrushButtonReleaseCallBack;
		core->draw_cursor = BlendBrushDrawCursor;
		core->button_update = BlendBrushButtonUpdate;
		core->motion_update = BlendBrushMotionUpdate;
		core->create_detail_ui = CreateBlendBrushDetailUI;
		core->color_change = BlendBrushColorChange;

		if(IniFileGetInteger(file, section_name, "PRESSURE_SIZE") != 0)
		{
			brush->flags |= BRUSH_FLAG_SIZE;
		}
		if(IniFileGetInteger(file, section_name, "PRESSURE_FLOW") != 0)
		{
			brush->flags |= BRUSH_FLAG_FLOW;
		}
		if(IniFileGetInteger(file, section_name, "ANTI_ALIAS") != 0)
		{
			brush->flags |= BRUSH_FLAG_ANTI_ALIAS;
		}
	}
	else if(StringCompareIgnoreCase(brush_type, "WATER_COLOR_BRUSH") == 0)
	{
		WATER_COLOR_BRUSH *brush;
		core->brush_type = (uint8)BRUSH_TYPE_WATER_COLOR_BRUSH;
		core->brush_data = MEM_ALLOC_FUNC(sizeof(*brush));
		(void)memset(core->brush_data, 0, sizeof(*brush));
		core->detail_data_size = sizeof(*brush);
		brush = (WATER_COLOR_BRUSH*)core->brush_data;

		brush->base_scale = IniFileGetInteger(file, section_name, "MAGNIFICATION");
		brush->r = IniFileGetInteger(file, section_name, "SIZE") * 0.5;
		brush->alpha = IniFileGetInteger(file, section_name, "FLOW");
		brush->outline_hardness = IniFileGetInteger(file, section_name,
			"OUTLINE_HARDNESS");
		brush->blur = IniFileGetInteger(file, section_name, "BLUR");
		brush->mix = IniFileGetInteger(file, section_name, "COLOR_MIX");
		brush->extend = IniFileGetInteger(file, section_name, "COLOR_EXTEND");
		brush->enter = IniFileGetInteger(file, section_name, "ENTER_SIZE");
		brush->out = IniFileGetInteger(file, section_name, "OUT_SIZE");
		if(IniFileGetInteger(file, section_name, "PRESSURE_SIZE") != 0)
		{
			brush->flags |= BRUSH_FLAG_SIZE;
		}
		if(IniFileGetInteger(file, section_name, "PRESSURE_FLOW") != 0)
		{
			brush->flags |= BRUSH_FLAG_FLOW;
		}

		core->press_func = WaterColorBrushPressCallBack;
		core->motion_func = WaterColorBrushMotionCallBack;
		core->release_func = WaterColorBrushReleaseCallBack;
		core->draw_cursor = WaterColorBrushDrawCursor;
		core->button_update = WaterColorBrushButtonUpdate;
		core->motion_update = WaterColorBrushMotionUpdate;
		core->create_detail_ui = CreateWaterColorBrushDetailUI;
	}
	else if(StringCompareIgnoreCase(brush_type, "STAMP_TOOL") == 0)
	{
		STAMP* stamp;
		core->brush_type = (uint8)BRUSH_TYPE_STAMP_TOOL;
		core->brush_data = MEM_ALLOC_FUNC(sizeof(*stamp));
		(void)memset(core->brush_data, 0, sizeof(*stamp));
		core->detail_data_size = sizeof(*stamp);
		stamp = (STAMP*)core->brush_data;

		stamp->core.brush_core = core;
		LoadStampCoreData(file, section_name, &stamp->core, &stamp->mode, app);

		core->press_func = StampToolButtonPressCallBack;
		core->motion_func = StampToolMotionCallBack;
		core->release_func = StampToolReleaseCallBack;
		core->draw_cursor = StampToolDrawCursor;
		core->button_update = StampToolButtonUpdate;
		core->motion_update = StampToolMotionUpdate;
		core->create_detail_ui = CreateStampToolDetailUI;
	}
	else if(StringCompareIgnoreCase(brush_type, "IMAGE_BRUSH") == 0)
	{
		IMAGE_BRUSH* brush;
		core->brush_type = (uint8)BRUSH_TYPE_IMAGE_BRUSH;
		core->brush_data = MEM_ALLOC_FUNC(sizeof(*brush));
		(void)memset(core->brush_data, 0, sizeof(*brush));
		core->detail_data_size = sizeof(*brush);
		brush = (IMAGE_BRUSH*)core->brush_data;

		brush->core.brush_core = core;
		LoadStampCoreData(file, section_name, &brush->core, &brush->mode, app);
		brush->size_range = IniFileGetInteger(file, section_name, "SIZE_RANGE") * 0.01;
		brush->random_rotate_range = IniFileGetInteger(file, section_name, "ROTATE_RANGE");

		if(IniFileGetInteger(file, section_name, "ROTATE_TO_BRUSH_DIRECTION") != 0)
		{
			brush->core.flags |= BRUSH_FLAG_ROTATE;
		}

		core->press_func = ImageBrushPressCallBack;
		core->motion_func = ImageBrushMotionCallBack;
		core->release_func = ImageBrushReleaseCallBack;
		core->draw_cursor = ImageBrushDrawCursor;
		core->button_update = ImageBrushButtonUpdate;
		core->motion_update = ImageBrushMotionUpdate;
		core->create_detail_ui = CreateImageBrushDetailUI;
		core->color_change = ImageBrushChangeColor;
	}
	else if(StringCompareIgnoreCase(brush_type, "BLEND_IMAGE_BRUSH") == 0)
	{
		BLEND_IMAGE_BRUSH* brush;
		core->brush_type = (uint8)BRUSH_TYPE_BLEND_IMAGE_BRUSH;
		core->brush_data = MEM_ALLOC_FUNC(sizeof(*brush));
		(void)memset(core->brush_data, 0, sizeof(*brush));
		core->detail_data_size = sizeof(*brush);
		brush = (BLEND_IMAGE_BRUSH*)core->brush_data;

		brush->core.brush_core = core;
		LoadStampCoreData(file, section_name, &brush->core, &brush->mode, app);
		brush->size_range = IniFileGetInteger(file, section_name, "SIZE_RANGE") * 0.01;
		brush->random_rotate_range = IniFileGetInteger(file, section_name, "ROTATE_RANGE");
		brush->blend_mode = (uint16)IniFileGetInteger(file, section_name, "BLEND_MODE");
		brush->target = (uint8)IniFileGetInteger(file, section_name, "TARGET");

		if(IniFileGetInteger(file, section_name, "ROTATE_TO_BRUSH_DIRECTION") != 0)
		{
			brush->core.flags |= BRUSH_FLAG_ROTATE;
		}

		core->press_func = BlendImageBrushButtonPressCallBack;
		core->motion_func = BlendImageBrushMotionCallBack;
		core->release_func = BlendImageBrushButtonReleaseCallBack;
		core->draw_cursor = BlendImageBrushDrawCursor;
		core->button_update = BlendImageBrushButtonUpdate;
		core->motion_update = BlendImageBrushMotionUpdate;
		core->create_detail_ui = CreateBlendImageBrushDetailUI;
		core->color_change = BlendImageBrushChangeColor;
	}
	else if(StringCompareIgnoreCase(brush_type, "PICKER_BRUSH") == 0)
	{
		PICKER_BRUSH *brush;
		core->brush_type = (uint8)BRUSH_TYPE_PICKER_BRUSH;
		core->brush_data = MEM_ALLOC_FUNC(sizeof(*brush));
		(void)memset(core->brush_data, 0, sizeof(*brush));
		core->detail_data_size = sizeof(*brush);
		brush = (PICKER_BRUSH*)core->brush_data;

		brush->core = core;
		brush->base_scale = IniFileGetInteger(file, section_name, "MAGNIFICATION");
		brush->r = IniFileGetInteger(file, section_name, "SIZE") * 0.5;
		brush->alpha = IniFileGetInteger(file, section_name, "FLOW");
		brush->outline_hardness = IniFileGetInteger(file, section_name, "OUTLINE_HARDNESS");
		brush->blur = IniFileGetInteger(file, section_name, "BLUR");
		brush->picker_mode = IniFileGetInteger(file, section_name, "PICK_MODE");
		brush->picker_source = IniFileGetInteger(file, section_name, "PICK_TARGET");
		brush->blend_mode = IniFileGetInteger(file, section_name, "BLEND_MODE");
		brush->add_h = IniFileGetInteger(file, section_name, "HUE");
		brush->add_s = IniFileGetInteger(file, section_name, "SATURATION");
		brush->add_v = IniFileGetInteger(file, section_name, "BRIGHTNESS");
		if(IniFileGetInteger(file, section_name, "PRESSURE_SIZE") != 0)
		{
			brush->flags |= PICKER_FLAG_PRESSURE_SIZE;
		}
		if(IniFileGetInteger(file, section_name, "PRESSURE_FLOW") != 0)
		{
			brush->flags |= PICKER_FLAG_PRESSURE_FLOW;
		}
		if(IniFileGetInteger(file, section_name, "ANTI_ALIAS") != 0)
		{
			brush->flags |= PICKER_FLAG_ANTI_ALIAS;
		}

		core->press_func = PickerBrushButtonPressCallBack;
		core->motion_func = PickerBrushMotionCallBack;
		core->release_func = PickerBrushButtonReleaseCallBack;
		core->draw_cursor = PickerBrushDrawCursor;
		core->button_update = PickerBrushButtonUpdate;
		core->motion_update = PickerBrushMotionUpdate;
		core->create_detail_ui = CreatePickerBrushDetailUI;
	}
	else if(StringCompareIgnoreCase(brush_type, "PICKER_IMAGE_BRUSH") == 0)
	{
		PICKER_IMAGE_BRUSH* brush;
		core->brush_type = (uint8)BRUSH_TYPE_PICKER_IMAGE_BRUSH;
		core->brush_data = MEM_ALLOC_FUNC(sizeof(*brush));
		(void)memset(core->brush_data, 0, sizeof(*brush));
		core->detail_data_size = sizeof(*brush);
		brush = (PICKER_IMAGE_BRUSH*)core->brush_data;

		brush->core.brush_core = core;
		LoadStampCoreData(file, section_name, &brush->core, NULL, app);
		brush->picker_mode = IniFileGetInteger(file, section_name, "PICK_MODE");
		brush->picker_source = IniFileGetInteger(file, section_name, "PICK_TARGET");
		brush->add_h = IniFileGetInteger(file, section_name, "HUE");
		brush->add_s = IniFileGetInteger(file, section_name, "SATURATION");
		brush->add_v = IniFileGetInteger(file, section_name, "BRIGHTNESS");
		brush->size_range = IniFileGetInteger(file, section_name, "SIZE_RANGE") * 0.01;
		brush->random_rotate_range = IniFileGetInteger(file, section_name, "ROTATE_RANGE");

		if(IniFileGetInteger(file, section_name, "ROTATE_TO_BRUSH_DIRECTION") != 0)
		{
			brush->core.flags |= BRUSH_FLAG_ROTATE;
		}

		core->press_func = PickerImageBrushPressCallBack;
		core->motion_func = PickerImageBrushMotionCallBack;
		core->release_func = PickerImageBrushReleaseCallBack;
		core->draw_cursor = PickerImageBrushDrawCursor;
		core->button_update = PickerImageBrushButtonUpdate;
		core->motion_update = PickerImageBrushMotionUpdate;
		core->create_detail_ui = CreatePickerImageBrushDetailUI;
	}
	else if(StringCompareIgnoreCase(brush_type, "ERASER") == 0)
	{
		ERASER* eraser;
		core->brush_type = (uint8)BRUSH_TYPE_ERASER;
		core->brush_data = MEM_ALLOC_FUNC(sizeof(*eraser));
		(void)memset(core->brush_data, 0, sizeof(*eraser));
		core->detail_data_size = sizeof(*eraser);
		eraser = (ERASER*)core->brush_data;

		eraser->base_scale = IniFileGetInteger(file, section_name, "MAGNIFICATION");
		eraser->r = IniFileGetInteger(file, section_name, "SIZE") * 0.5;
		eraser->alpha = IniFileGetInteger(file, section_name, "FLOW");
		eraser->outline_hardness = IniFileGetInteger(file, section_name, "OUTLINE_HARDNESS");
		eraser->blur = IniFileGetInteger(file, section_name, "BLUR");
		core->press_func = EraserButtonPressCallBack;
		core->motion_func = EraserMotionCallBack;
		core->release_func = EraserReleaseCallBack;
		core->draw_cursor = EraserDrawCursor;
		core->button_update = EraserButtonUpdate;
		core->motion_update = EraserMotionUpdate;
		core->create_detail_ui = CreateEraserDetailUI;
		if(IniFileGetInteger(file, section_name, "PRESSURE_SIZE") != 0)
		{
			eraser->flags |= BRUSH_FLAG_SIZE;
		}
		if(IniFileGetInteger(file, section_name, "PRESSURE_FLOW") != 0)
		{
			eraser->flags |= BRUSH_FLAG_FLOW;
		}
	}
	else if(StringCompareIgnoreCase(brush_type, "BUCKET") == 0)
	{
		BUCKET *bucket;
		core->brush_type = (uint8)BRUSH_TYPE_BUCKET;
		core->brush_data = MEM_ALLOC_FUNC(sizeof(*bucket));
		(void)memset(core->brush_data, 0, sizeof(*bucket));
		core->detail_data_size = sizeof(*bucket);
		bucket = (BUCKET*)core->brush_data;

		bucket->threshold = (uint16)IniFileGetInteger(file, section_name, "THRESHOLD");
		bucket->mode = (uint8)IniFileGetInteger(file, section_name, "MODE");
		bucket->target = (uint8)IniFileGetInteger(file, section_name, "TARGET");
		bucket->extend = (int16)IniFileGetInteger(file, section_name, "EXTEND");

		core->press_func = BucketPressCallBack;
		core->motion_func = BucketMotionCallBack;
		core->release_func = BucketReleaseCallBack;
		core->draw_cursor = BucketDrawCursor;
		core->create_detail_ui = CreateBucketDetailUI;
	}
	else if(StringCompareIgnoreCase(brush_type, "PATTERN_FILL") == 0)
	{
		PATTERN_FILL *fill;
		core->brush_type = (uint8)BRUSH_TYPE_PATTERN_FILL;
		core->brush_data = MEM_ALLOC_FUNC(sizeof(*fill));
		(void)memset(core->brush_data, 0, sizeof(*fill));
		core->detail_data_size = sizeof(*fill);
		fill = (PATTERN_FILL*)core->brush_data;

		fill->threshold = (uint16)IniFileGetInteger(file, section_name, "THRESHOLD");
		fill->mode = (uint8)IniFileGetInteger(file, section_name, "MODE");
		fill->target = (uint8)IniFileGetInteger(file, section_name, "TARGET");
		fill->pattern_id = IniFileGetInteger(file, section_name, "PATTERN_ID");
		fill->scale = IniFileGetInteger(file, section_name, "SIZE");
		fill->flow = IniFileGetInteger(file, section_name, "FLOW") * 0.01;
		fill->extend = (int16)IniFileGetInteger(file, section_name, "EXTEND");

		core->press_func = PatternFillPressCallBack;
		core->motion_func = PatternFillMotionCallBack;
		core->release_func = PatternFillReleaseCallBack;
		core->draw_cursor = PatternFillDrawCursor;
		core->create_detail_ui = CreatePatternFillDetailUI;
	}
	else if(StringCompareIgnoreCase(brush_type, "GRADATION") == 0)
	{
		GRADATION* gradation;
		core->brush_type = (uint8)BRUSH_TYPE_GRADATION;
		core->brush_data = MEM_ALLOC_FUNC(sizeof(*gradation));
		(void)memset(core->brush_data, 0, sizeof(*gradation));
		core->detail_data_size = sizeof(*gradation);
		core->brush_type = BRUSH_TYPE_GRADATION;
		gradation = (GRADATION*)core->brush_data;

		if(IniFileGetInteger(file, section_name, "COLOR_REVERSE") != 0)
		{
			gradation->flags |= GRADATION_COLOR_REVERSE;
		}
		gradation->app = app;

		core->press_func = GradationPressCallBack;
		core->motion_func = GradationMotionCallBack;
		core->release_func = GradationReleaseCallBack;
		core->draw_cursor = DrawGradationCursor;
		core->create_detail_ui = CreateGrationDetailUI;
		core->change_editting_selection = GradationOnChangeEditSelection;
	}
	else if(StringCompareIgnoreCase(brush_type, "BLUR_TOOL") == 0)
	{
		BLUR_TOOL* blur;
		core->brush_type = (uint8)BRUSH_TYPE_BLUR;
		core->brush_data = MEM_ALLOC_FUNC(sizeof(*blur));
		(void)memset(core->brush_data, 0, sizeof(*blur));
		core->detail_data_size = sizeof(*blur);
		blur = (BLUR_TOOL*)core->brush_data;

		blur->base_scale = IniFileGetInteger(file, section_name, "MAGNIFICATION");
		blur->r = IniFileGetInteger(file, section_name, "SIZE") * 0.5;
		blur->alpha = IniFileGetInteger(file, section_name, "FLOW");
		blur->outline_hardness = IniFileGetInteger(file, section_name, "OUTLINE_HARDNESS");
		blur->blur = IniFileGetInteger(file, section_name, "BLUR");
		blur->color_extend = IniFileGetInteger(file, section_name, "COLOR_EXTEND");
		core->press_func = BlurToolPressCallBack;
		core->motion_func = BlurToolMotionCallBack;
		core->release_func = BlurToolReleaseCallBack;
		core->draw_cursor = BlurToolDrawCursor;
		core->button_update = BlurToolButtonUpdate;
		core->motion_update = BlurToolMotionUpdate;
		core->create_detail_ui = CreateBlurToolDetailUI;
		if(IniFileGetInteger(file, section_name, "PRESSURE_SIZE") != 0)
		{
			blur->flags |= BRUSH_FLAG_SIZE;
		}
		if(IniFileGetInteger(file, section_name, "PRESSURE_FLOW") != 0)
		{
			blur->flags |= BRUSH_FLAG_FLOW;
		}
	}
	else if(StringCompareIgnoreCase(brush_type, "SMUDGE") == 0)
	{
		SMUDGE* smudge;
		core->brush_type = (uint8)BRUSH_TYPE_SMUDGE;
		core->brush_data = MEM_ALLOC_FUNC(sizeof(*smudge));
		(void)memset(core->brush_data, 0, sizeof(*smudge));
		core->detail_data_size = sizeof(*smudge);
		smudge = (SMUDGE*)core->brush_data;

		smudge->base_scale = IniFileGetInteger(file, section_name, "MAGNIFICATION");
		smudge->r = IniFileGetInteger(file, section_name, "SIZE") * 0.5;
		smudge->opacity = IniFileGetInteger(file, section_name, "OPACITY");
		smudge->blur = IniFileGetInteger(file, section_name, "BLUR");
		smudge->outline_hardness = IniFileGetInteger(file, section_name, "OUTLINE_HARDNESS");
		smudge->extention = IniFileGetInteger(file, section_name, "COLOR_EXTEND");

		core->press_func = SmudgePressCallBack;
		core->motion_func = SmudgeMotionCallBack;
		core->release_func = SmudgeReleaseCallBack;
		core->draw_cursor = SmudgeDrawCursor;
		core->button_update = SmudgeButtonUpdate;
		core->motion_update = SmudgeMotionUpdate;
		core->create_detail_ui = CreateSmudgeDetailUI;
		if(IniFileGetInteger(file, section_name, "PRESSURE_SIZE") != 0)
		{
			smudge->flags |= SMUDGE_PRESSURE_SIZE;
		}
		if(IniFileGetInteger(file, section_name, "PRESSURE_EXTENTION") != 0)
		{
			smudge->flags |= SMUDGE_PRESSURE_EXTENTION;
		}
	}
	else if(StringCompareIgnoreCase(brush_type, "MIX_BRUSH") == 0)
	{
		MIX_BRUSH *mix;
		core->brush_type = (uint8)BRUSH_TYPE_MIX_BRUSH;
		core->brush_data = MEM_ALLOC_FUNC(sizeof(*mix));
		(void)memset(core->brush_data, 0, sizeof(*mix));
		core->detail_data_size = sizeof(*mix);
		mix = (MIX_BRUSH*)core->brush_data;

		mix->base_scale = IniFileGetInteger(file, section_name, "MAGNIFICATION");
		mix->r = IniFileGetInteger(file, section_name, "SIZE") * 0.5;
		mix->alpha = IniFileGetInteger(file, section_name, "FLOW");
		mix->outline_hardness = IniFileGetInteger(file, section_name, "OUTLINE_HARDNESS");
		mix->blur = IniFileGetInteger(file, section_name, "BLUR");

		if(IniFileGetInteger(file, section_name, "PRESSURE_SIZE") != 0)
		{
			mix->flags |= BRUSH_FLAG_SIZE;
		}
		if(IniFileGetInteger(file, section_name, "PRESSURE_FLOW") != 0)
		{
			mix->flags |= BRUSH_FLAG_FLOW;
		}

		core->press_func = MixBrushPressCallBack;
		core->motion_func = MixBrushMotionCallBack;
		core->release_func = MixBrushReleaseCallBack;
		core->draw_cursor = MixBrushDrawCursor;
		core->button_update = MixBrushButtonUpdate;
		core->motion_update = MixBrushMotionUpdate;
		core->create_detail_ui = CreateMixBrushDetailUI;
	}
	else if(StringCompareIgnoreCase(brush_type, "TEXT_TOOL") == 0)
	{
		TEXT_TOOL* text;
		char str[128];
		char buff[16] = {0};
		PangoFontFamily** search_font;
		char font_name[256];
		int i;

		core->brush_data = MEM_ALLOC_FUNC(sizeof(*text));
		(void)memset(core->brush_data, 0, sizeof(*text));
		core->detail_data_size = sizeof(*text);
		text = (TEXT_TOOL*)core->brush_data;
		core->brush_type = BRUSH_TYPE_TEXT;

		core->press_func = TextToolPressCallBack;
		core->motion_func = TextToolMotionCallBack;
		core->release_func = TextToolReleaseCallBack;
		core->draw_cursor = TextToolDrawCursor;
		core->create_detail_ui = CreateTextToolDetailUI;

		text->base_size = IniFileGetInteger(file, section_name, "MAGNIFICATION");
		text->font_size = IniFileGetInteger(file, section_name, "SIZE");
		if(IniFileGetInteger(file, section_name, "VERTICAL") != 0)
		{
			text->flags |= TEXT_TOOL_VERTICAL;
		}

		(void)IniFileGetString(file, section_name, "FONT_NAME", font_name, 256);
		search_font = (PangoFontFamily**)bsearch(
			font_name, app->font_list, app->num_font, sizeof(*app->font_list),
				(int (*)(const void*, const void*))ForFontFamilySearchCompare);
		if(search_font == NULL)
		{
			text->font_id = 0;
		}
		else
		{
			text->font_id = (int32)(search_font - app->font_list);
		}

		text->balloon_type = (uint16)IniFileGetInteger(file, section_name, "BALLOON_TYPE");
		text->line_width = IniFileGetDouble(file, section_name, "LINE_WIDTH");
		text->balloon_data.num_edge = (uint16)IniFileGetInteger(file, section_name, "NUM_EDGE");
		text->balloon_data.num_children = (uint16)IniFileGetInteger(file, section_name, "NUM_CHILDREN");
		text->balloon_data.edge_size = IniFileGetDouble(file, section_name, "EDGE_SIZE");
		text->balloon_data.random_seed = IniFileGetInteger(file, section_name, "RANDOM_SEED");
		text->balloon_data.edge_random_size = IniFileGetDouble(file, section_name, "RANDOM_EDGE_SIZE") * 0.01;
		text->balloon_data.edge_random_distance = IniFileGetDouble(file, section_name, "RANDOM_EDGE_DISTANCE") * 0.01;
		text->balloon_data.start_child_size = IniFileGetDouble(file, section_name, "START_CHILD_SIZE") * 0.01;
		text->balloon_data.end_child_size = IniFileGetDouble(file, section_name, "END_CHILD_SIZE") * 0.01;

		if(IniFileGetString(file, section_name, "BACK_COLOR", str, (long)sizeof(str)) != 0)
		{
			int value;
			for(i=0; i<4; i++)
			{
				buff[0] = str[i*2];
				buff[1] = str[i*2+1];
				(void)sscanf(buff, "%x", &value);
				text->back_color[i] = (uint8)value;
			}
		}
		if(IniFileGetString(file, section_name, "LINE_COLOR", str, (long)sizeof(str)) != 0)
		{
			int value;
			for(i=0; i<4; i++)
			{
				buff[0] = str[i*2];
				buff[1] = str[i*2+1];
				(void)sscanf(buff, "%x", &value);
				text->line_color[i] = (uint8)value;
			}
		}

		if(IniFileGetInteger(file, section_name, "BALLOON_HAS_EDGE") != 0)
		{
			text->flags |= TEXT_TOOL_BALLOON_HAS_EDGE;
		}
		if(IniFileGetInteger(file, section_name, "CENTERING_HORIZONTALLY") != 0)
		{
			text->flags |= TEXT_TOOL_CENTERING_HORIZONTALLY;
		}
		if(IniFileGetInteger(file, section_name, "CENTERING_VERTICALLY") != 0)
		{
			text->flags |= TEXT_TOOL_CENTERING_VERTICALLY;
		}
		if(IniFileGetInteger(file, section_name, "ADJUST_RANGE_TO_TEXT") != 0)
		{
			text->flags |= TEXT_TOOL_ADJUST_RANGE_TO_TEXT;
		}
	}
	else if(StringCompareIgnoreCase(brush_type, "SCRIPT_BRUSH") == 0)
	{
		SCRIPT *script;
		char *system_name;
		char *script_file_name;
		char *file_path;
		system_name = IniFileStrdup(file, section_name, "FILE_NAME");
		script_file_name = g_locale_to_utf8(system_name, -1, NULL, NULL, NULL);
		file_path = g_build_filename(app->current_path, "brushes", script_file_name, NULL);
		script = CreateScript(app, file_path);
		MEM_FREE_FUNC(system_name);
		g_free(script_file_name);
		g_free(file_path);

		if(script != NULL)
		{
			script->brush_data = (SCRIPT_BRUSH*)MEM_ALLOC_FUNC(sizeof(*script->brush_data));
			(void)memset(script->brush_data, 0, sizeof(*script->brush_data));
			script->brush_data->r = 1;
			script->brush_data->zoom = 1;
			core->brush_type = (uint8)BRUSH_TYPE_SCRIPT_BRUSH;
			core->brush_data = (void*)script;
			core->detail_data_size = sizeof(*script);

			core->press_func = ScriptBrushButtonPressCallBack;
			core->motion_func = ScriptBrushMotionCallBack;
			core->release_func = ScriptBrushButtonReleaseCallBack;
			core->draw_cursor = ScriptBrushDrawCursor;
			core->button_update = (brush_update_func)ScriptBrushButtonUpdate;
			core->motion_update = (brush_update_func)ScriptBrushMotionUpdate;
			core->color_change = ScriptBrushColorChange;
			core->create_detail_ui = CreateScriptBrushDetailUI;
		}
	}
	else if(StringCompareIgnoreCase(brush_type, "CUSTOM_BRUSH") == 0)
	{
		CUSTOM_BRUSH *brush;
		core->brush_type = (uint8)BRUSH_TYPE_CUSTOM_BRUSH;
		core->brush_data = MEM_ALLOC_FUNC(sizeof(*brush));
		(void)memset(core->brush_data, 0, sizeof(*brush));
		core->detail_data_size = sizeof(*brush);
		brush = (CUSTOM_BRUSH*)core->brush_data;

		brush->base_scale =	IniFileGetInteger(file, section_name, "MAGNIFICATION");
		brush->scale = IniFileGetDouble(file, section_name, "SIZE");
		brush->alpha = IniFileGetDouble(file, section_name, "FLOW") * 0.01;
		brush->blur = IniFileGetDouble(file, section_name, "BLUR") * 0.01;
		brush->outline_hardness = IniFileGetDouble(file, section_name, "OUTLINE_HARDNESS") * 0.01;
		brush->enter = IniFileGetDouble(file, section_name, "ENTER") * 0.01;
		brush->out = IniFileGetDouble(file, section_name, "OUT") * 0.01;
		brush->start_angle = IniFileGetDouble(file, section_name, "ANGLE") * G_PI / 180.0;
		brush->rotate_speed = IniFileGetDouble(file, section_name, "ROTATE_SPEED") * G_PI / 180.0;
		brush->random_size = IniFileGetDouble(file, section_name, "RANDOM_SIZE") * 0.01;
		brush->random_angle = IniFileGetDouble(file, section_name, "RANDOM_ANGLE") * G_PI / 180.0;
		brush->brush_distance = IniFileGetDouble(file, section_name, "DRAW_DISTANCE");
		brush->rotate_direction = IniFileGetInteger(file, section_name, "ROTATE_DIRECTION");
		brush->blend_mode = (uint8)IniFileGetInteger(file, section_name, "BLEND_MODE");
		brush->blend_target = (uint8)IniFileGetInteger(file, section_name, "BLEND_TARGET");
		brush->brush_shape = (uint8)IniFileGetInteger(file, section_name, "BRUSH_SHAPE");
		brush->color_mode = (uint8)IniFileGetInteger(file, section_name, "COLOR_MODE");
		brush->brush_mode =	(uint8)IniFileGetInteger(file, section_name, "BRUSH_MODE");
		brush->picker_mode = (uint8)IniFileGetInteger(file, section_name, "PICKER_MODE");
		brush->hue = (int16)IniFileGetInteger(file, section_name, "HUE");
		brush->saturation = (int16)IniFileGetInteger(file, section_name, "SATURATION");
		brush->brightness = (int16)IniFileGetInteger(file, section_name, "BRIGHTNESS");
		brush->extend = (uint8)IniFileGetInteger(file, section_name, "COLOR_EXTEND");
		brush->mix = (uint8)IniFileGetInteger(file, section_name, "COLOR_MIX");
		brush->num_scatter = IniFileGetInteger(file, section_name, "NUM_SCATTER");
		brush->scatter_range = IniFileGetDouble(file, section_name, "SCATTER_RANGE") * 0.01;
		brush->scatter_size = IniFileGetDouble(file, section_name, "SCATTER_SIZE") * 0.01;
		brush->scatter_random_size = IniFileGetDouble(file, section_name, "SCATTER_RANDOM_SIZE") * 0.01;
		brush->scatter_random_flow = IniFileGetDouble(file, section_name, "SCATTER_RANDOM_FLOW") * 0.01;
		brush->pattern_id = IniFileGetInteger(file, section_name, "PATTERN_ID");

		if(brush->brush_shape == CUSTOM_BRUSH_SHAPE_IMAGE)
		{
			FILE *fp;
			size_t data_size;
			gint32 width, height, stride;
			gchar *image_file_path;
			gchar *system_path;

			brush->image_path = IniFileStrdup(file, section_name, "IMAGE_NAME");
			image_file_path = g_build_filename(
				app->current_path, "brushes", brush->image_path, NULL);
			system_path = g_locale_from_utf8(image_file_path, -1, NULL, NULL, NULL);
			fp = fopen(system_path, "rb");
			if(fp != NULL)
			{
				(void)fseek(fp, 0, SEEK_END);
				data_size = ftell(fp);
				rewind(fp);
				ReadPNGStream((void*)fp, (stream_func_t)fread,
					&width, &height, &stride);
				brush->image_width = width;
				brush->image_height = height;
				brush->image_channel = stride / width;

				(void)fclose(fp);
			}
			else
			{
				brush->brush_shape = CUSTOM_BRUSH_SHAPE_CIRCLE;
			}

			g_free(system_path);
			g_free(image_file_path);
		}

		if(IniFileGetInteger(file, section_name, "PRESSURE_SIZE") != 0)
		{
			brush->flags |= 1 << CUSTOM_BRUSH_FLAG_PRESSURE_SIZE;
		}
		if(IniFileGetInteger(file, section_name, "PRESSURE_FLOW") != 0)
		{
			brush->flags |= 1 << CUSTOM_BRUSH_FLAG_PRESSURE_FLOW;
		}
		if(IniFileGetInteger(file, section_name, "ROTATE_BY_CURSOR") != 0)
		{
			brush->flags |= 1 << CUSTOM_BRUSH_FLAG_ROTATE_BY_CURSOR;
		}
		if(IniFileGetInteger(file, section_name, "RANDOM_SIZE") != 0)
		{
			brush->flags |= 1 << CUSTOM_BRUSH_FLAG_RANDOM_SIZE;
		}
		if(IniFileGetInteger(file, section_name, "RANDOM_ROTATE") != 0)
		{
			brush->flags |= 1 << CUSTOM_BRUSH_FLAG_RANDOM_ROTATE;
		}
		if(IniFileGetInteger(file, section_name, "ANTI_ALIAS") != 0)
		{
			brush->flags |= 1 << CUSTOM_BRUSH_FLAG_ANTI_ALIAS;
		}
		if(IniFileGetInteger(file, section_name, "FLIP_HORIZONTALLY") != 0)
		{
			brush->flags |= 1 << CUSTOM_BRUSH_FLAG_IMAGE_FLIP_HORIZONTALLY;
		}
		if(IniFileGetInteger(file, section_name, "FLIP_VERTICALLY") != 0)
		{
			brush->flags |= 1 << CUSTOM_BRUSH_FLAG_IMAGE_FLIP_VERTICALLY;
		}
		if(IniFileGetInteger(file, section_name, "DRAW_SCATTER_ONLY") != 0)
		{
			brush->flags |= 1 << CUSTOM_BRUSH_FLAG_DRAW_ONLY_SCATTER;
		}

		core->press_func = CustomBrushButtonPressCallBack;
		core->motion_func = CustomBrushMotionCallBack;
		core->release_func = CustomBrushButtonReleaseCallBack;
		core->draw_cursor = CustomBrushDrawCursor;
		core->button_update = CustomBrushButtonUpdate;
		core->motion_update = CustomBrushMotionUpdate;
		core->create_detail_ui = CreateCustomBrushDetailUI;
		core->color_change = CustomBrushColorChange;
	}
	else if(StringCompareIgnoreCase(brush_type, "PLUG_IN_BRUSH") == 0)
	{
		PLUG_IN_BRUSH *brush = (PLUG_IN_BRUSH*)MEM_ALLOC_FUNC(sizeof(*brush));
		GModule *module;
		gpointer function;
		gchar *file_path;

		core->brush_data = (void*)brush;
		brush->plug_in_name = IniFileStrdup(file, section_name, "PLUG_IN_FILE");
		core->detail_data_size = sizeof(*brush);
		file_path = g_build_filename(app->current_path, PLUG_IN_DIRECTORY, brush->plug_in_name, NULL);

		module = g_module_open(file_path, G_MODULE_BIND_LOCAL);

		if(module != NULL)
		{
			if(g_module_symbol(module, "BrushDataNew", &function) != FALSE)
			{
				brush->detail_data = ((void* (*)(void))function)();
			}

			if(LoadPlugInBrushCallbacks(module, core, brush) == FALSE)
			{
				MEM_FREE_FUNC(brush->plug_in_name);
				MEM_FREE_FUNC(brush->detail_data);
				MEM_FREE_FUNC(brush);
			}
			else
			{
				core->brush_type = (uint8)BRUSH_TYPE_PLUG_IN;
				core->create_detail_ui = CreatePlugInBrushDetailUI;

				if(g_module_symbol(module, "LoadBrushSetting", &function) != FALSE)
				{
					((void (*)(BRUSH_CORE*, INI_FILE_PTR, const char*, APPLICATION*))function)(
						core, file, section_name, app);
				}
			}
		}
		else
		{
			MEM_FREE_FUNC(brush->plug_in_name);
			MEM_FREE_FUNC(brush);
		}

		g_module_close(module);
	}

	if(core->button_update == NULL)
	{
		core->button_update = DefaultToolUpdate;
	}

	if(core->motion_update == NULL)
	{
		core->motion_update = DefaultToolUpdate;
	}
}

void LoadBrushDefaultData(
	BRUSH_CORE* core,
	eBRUSH_TYPE brush_type,
	APPLICATION* app
)
{
	core->app = app;
	core->color = &app->tool_window.color_chooser->rgb;
	core->brush_pattern_buff = &app->tool_window.brush_pattern_buff;
	core->temp_pattern_buff = &app->tool_window.temp_pattern_buff;

	switch(brush_type)
	{
	case BRUSH_TYPE_PENCIL:
		{
			PENCIL* pen;
			core->brush_type = (uint8)BRUSH_TYPE_PENCIL;
			core->brush_data = MEM_ALLOC_FUNC(sizeof(*pen));
			(void)memset(core->brush_data, 0, sizeof(*pen));
			core->detail_data_size = sizeof(*pen);
			pen = (PENCIL*)core->brush_data;

			pen->core = core;
			pen->base_scale = 1;
			pen->r = 10;
			pen->alpha = 100;
			pen->outline_hardness = 100;
			core->press_func = PencilPressCallBack;
			core->motion_func = PencilMotionCallBack;
			core->release_func = PencilReleaseCallBack;
			core->draw_cursor = PencilDrawCursor;
			core->button_update = (brush_update_func)PencilButtonUpdate;
			core->motion_update = (brush_update_func)PencilMotionUpdate;
			core->color_change = PencilColorChange;
			core->create_detail_ui = CreatePencilDetailUI;
		}
		break;
	case BRUSH_TYPE_HARD_PEN:
		{
			HARD_PEN *pen;
			core->brush_type = (uint8)BRUSH_TYPE_HARD_PEN;
			core->brush_data = MEM_ALLOC_FUNC(sizeof(*pen));
			(void)memset(core->brush_data, 0, sizeof(*pen));
			core->detail_data_size = sizeof(*pen);
			pen = (HARD_PEN*)core->brush_data;

			pen->core = core;
			pen->base_scale = 1;
			pen->r = 10;
			pen->alpha = 100;
			core->press_func = HardPenButtonPressCallBack;
			core->motion_func = HardPenMotionCallBack;
			core->release_func = HardPenButtonReleaseCallBack;
			core->draw_cursor = HardPenDrawCursor;
			core->button_update = (brush_update_func)HardPenButtonUpdate;
			core->motion_update = (brush_update_func)HardPenMotionUpdate;
			core->create_detail_ui = CreateHardPenDetailUI;
		}
		break;
	case BRUSH_TYPE_AIR_BRUSH:
		{
			AIR_BRUSH* brush;
			core->brush_type = (uint8)BRUSH_TYPE_AIR_BRUSH;
			core->brush_data = MEM_ALLOC_FUNC(sizeof(*brush));
			(void)memset(core->brush_data, 0, sizeof(*brush));
			core->detail_data_size = sizeof(*brush);
			brush = (AIR_BRUSH*)core->brush_data;

			brush->core = core;
			brush->base_scale = 1;
			brush->r = 10;
			brush->opacity = 100;
			// brush->outline_hardness = 0;
			brush->blur = 100;
			// brush->enter = 0;
			// brush->out = 0;
			// brush->blend_mode = 0;
			brush->core = core;

			core->press_func = AirBrushPressCallBack;
			core->motion_func = AirBrushMotionCallBack;
			core->release_func = AirBrushReleaseCallBack;
			core->draw_cursor = AirBrushDrawCursor;
			core->button_update = (brush_update_func)AirBrushButtonUpdate;
			core->motion_update = (brush_update_func)AirBrushMotionUpdate;
			core->create_detail_ui = CreateAirBrushDetailUI;
			core->color_change = AirBrushColorChange;
		}
		break;
	case BRUSH_TYPE_OLD_AIR_BRUSH:
		{
			OLD_AIR_BRUSH* brush;
			core->brush_type = (uint8)BRUSH_TYPE_OLD_AIR_BRUSH;
			core->brush_data = MEM_ALLOC_FUNC(sizeof(*brush));
			(void)memset(core->brush_data, 0, sizeof(*brush));
			core->detail_data_size = sizeof(*brush);
			brush = (OLD_AIR_BRUSH*)core->brush_data;

			brush->r = 10;
			brush->opacity = 100;
			// brush->outline_hardness = 0;
			brush->blur = 100;

			core->press_func = OldAirBrushPressCallBack;
			core->motion_func = OldAirBrushMotionCallBack;
			core->release_func = OldAirBrushReleaseCallBack;
			core->draw_cursor = OldAirBrushDrawCursor;
			core->create_detail_ui = CreateOldAirBrushDetailUI;
		}
		break;
	case BRUSH_TYPE_BLEND_BRUSH:
		{
			BLEND_BRUSH* brush;
			core->brush_type = (uint8)BRUSH_TYPE_BLEND_BRUSH;
			core->brush_data = MEM_ALLOC_FUNC(sizeof(*brush));
			(void)memset(core->brush_data, 0, sizeof(*brush));
			core->detail_data_size = sizeof(*brush);
			brush = (BLEND_BRUSH*)core->brush_data;

			brush->core = core;
			brush->base_scale = 1;
			brush->r = 10;
			brush->opacity = 100;
			// brush->outline_hardness = 0;
			brush->blur = 100;
			// brush->enter = 0;
			// brush->out = 0;
			// brush->target = 0;
			// brush->blend_mode = 0;
			brush->core = core;

			core->press_func = BlendBrushButtonPressCallBack;
			core->motion_func = BlendBrushMotionCallBack;
			core->release_func = BlendBrushButtonReleaseCallBack;
			core->draw_cursor = BlendBrushDrawCursor;
			core->button_update = BlendBrushButtonUpdate;
			core->motion_update = BlendBrushMotionUpdate;
			core->create_detail_ui = CreateBlendBrushDetailUI;
			core->color_change = BlendBrushColorChange;
		}
		break;
	case BRUSH_TYPE_WATER_COLOR_BRUSH:
		{
			WATER_COLOR_BRUSH *brush;
			core->brush_type = (uint8)BRUSH_TYPE_WATER_COLOR_BRUSH;
			core->brush_data = MEM_ALLOC_FUNC(sizeof(*brush));
			(void)memset(core->brush_data, 0, sizeof(*brush));
			core->detail_data_size = sizeof(*brush);
			brush = (WATER_COLOR_BRUSH*)core->brush_data;

			brush->core = core;
			brush->base_scale = 1;
			brush->r = 10;
			brush->alpha = 100;
			// brush->outline_hardness = 0;
			brush->blur = 100;
			// brush->mix = 0;
			// brush->extend = 0;
			// brush->enter = 0;
			// brush->out = 0;

			core->press_func = WaterColorBrushPressCallBack;
			core->motion_func = WaterColorBrushMotionCallBack;
			core->release_func = WaterColorBrushReleaseCallBack;
			core->draw_cursor = WaterColorBrushDrawCursor;
			core->button_update = WaterColorBrushButtonUpdate;
			core->motion_update = WaterColorBrushMotionUpdate;
			core->create_detail_ui = CreateWaterColorBrushDetailUI;
		}
		break;
	case BRUSH_TYPE_STAMP_TOOL:
		{
			STAMP* stamp;
			core->brush_type = (uint8)BRUSH_TYPE_STAMP_TOOL;
			core->brush_data = MEM_ALLOC_FUNC(sizeof(*stamp));
			(void)memset(core->brush_data, 0, sizeof(*stamp));
			core->detail_data_size = sizeof(*stamp);
			stamp = (STAMP*)core->brush_data;

			stamp->core.brush_core = core;
			LoadStampCoreDefaultData(&stamp->core, &stamp->mode, app);

			core->press_func = StampToolButtonPressCallBack;
			core->motion_func = StampToolMotionCallBack;
			core->release_func = StampToolReleaseCallBack;
			core->draw_cursor = StampToolDrawCursor;
			core->button_update = StampToolButtonUpdate;
			core->motion_update = StampToolMotionUpdate;
			core->create_detail_ui = CreateStampToolDetailUI;
		}
		break;
	case BRUSH_TYPE_IMAGE_BRUSH:
		{
			IMAGE_BRUSH* brush;
			core->brush_type = (uint8)BRUSH_TYPE_IMAGE_BRUSH;
			core->brush_data = MEM_ALLOC_FUNC(sizeof(*brush));
			(void)memset(core->brush_data, 0, sizeof(*brush));
			core->detail_data_size = sizeof(*brush);
			brush = (IMAGE_BRUSH*)core->brush_data;

			brush->core.brush_core = core;
			LoadStampCoreDefaultData(&brush->core, &brush->mode, app);
			brush->size_range = 100;
			brush->random_rotate_range = 100;

			core->press_func = ImageBrushPressCallBack;
			core->motion_func = ImageBrushMotionCallBack;
			core->release_func = ImageBrushReleaseCallBack;
			core->draw_cursor = ImageBrushDrawCursor;
			core->button_update = ImageBrushButtonUpdate;
			core->motion_update = ImageBrushMotionUpdate;
			core->create_detail_ui = CreateImageBrushDetailUI;
			core->color_change = ImageBrushChangeColor;
		}
		break;
	case BRUSH_TYPE_BLEND_IMAGE_BRUSH:
		{
			BLEND_IMAGE_BRUSH* brush;
			core->brush_type = (uint8)BRUSH_TYPE_BLEND_IMAGE_BRUSH;
			core->brush_data = MEM_ALLOC_FUNC(sizeof(*brush));
			(void)memset(core->brush_data, 0, sizeof(*brush));
			core->detail_data_size = sizeof(*brush);
			brush = (BLEND_IMAGE_BRUSH*)core->brush_data;

			brush->core.brush_core = core;
			LoadStampCoreDefaultData(&brush->core, &brush->mode, app);
			brush->size_range = 100;
			brush->random_rotate_range = 100;

			core->press_func = BlendImageBrushButtonPressCallBack;
			core->motion_func = BlendImageBrushMotionCallBack;
			core->release_func = BlendImageBrushButtonReleaseCallBack;
			core->draw_cursor = BlendImageBrushDrawCursor;
			core->button_update = BlendImageBrushButtonUpdate;
			core->motion_update = BlendImageBrushMotionUpdate;
			core->create_detail_ui = CreateBlendImageBrushDetailUI;
			core->color_change = BlendImageBrushChangeColor;
		}
		break;
	case BRUSH_TYPE_PICKER_BRUSH:
		{
			PICKER_BRUSH *brush;
			core->brush_type = (uint8)BRUSH_TYPE_PICKER_BRUSH;
			core->brush_data = MEM_ALLOC_FUNC(sizeof(*brush));
			(void)memset(core->brush_data, 0, sizeof(*brush));
			core->detail_data_size = sizeof(*brush);
			brush = (PICKER_BRUSH*)core->brush_data;

			brush->core = core;
			brush->base_scale = 1;
			brush->r = 20;
			brush->alpha = 100;
			// brush->outline_hardness = 0;
			brush->blur = 100;
			// brush->picker_mode = PICKER_MODE_SINGLE_PIXEL;
			// brush->picker_source = 0;
			// brush->blend_mode = LAYER_BLEND_NORMAL;
			// brush->add_h = 0;
			// brush->add_s = 0;
			// brush->add_v = 0;

			core->press_func = PickerBrushButtonPressCallBack;
			core->motion_func = PickerBrushMotionCallBack;
			core->release_func = PickerBrushButtonReleaseCallBack;
			core->draw_cursor = PickerBrushDrawCursor;
			core->button_update = PickerBrushButtonUpdate;
			core->motion_update = PickerBrushMotionUpdate;
			core->create_detail_ui = CreatePickerBrushDetailUI;
		}
		break;
	case BRUSH_TYPE_PICKER_IMAGE_BRUSH:
		{
			PICKER_IMAGE_BRUSH* brush;
			core->brush_type = (uint8)BRUSH_TYPE_PICKER_IMAGE_BRUSH;
			core->brush_data = MEM_ALLOC_FUNC(sizeof(*brush));
			(void)memset(core->brush_data, 0, sizeof(*brush));
			core->detail_data_size = sizeof(*brush);
			brush = (PICKER_IMAGE_BRUSH*)core->brush_data;

			brush->core.brush_core = core;
			LoadStampCoreDefaultData(&brush->core, NULL, app);
			// brush->picker_mode = PICKER_MODE_SINGLE_PIXEL;
			// brush->picker_source = 0;
			// brush->add_h = 0;
			// brush->add_s = 0;
			// brush->add_v = 0;
			brush->size_range = 100;
			brush->random_rotate_range = 100;

			core->press_func = PickerImageBrushPressCallBack;
			core->motion_func = PickerImageBrushMotionCallBack;
			core->release_func = PickerImageBrushReleaseCallBack;
			core->draw_cursor = PickerImageBrushDrawCursor;
			core->button_update = PickerImageBrushButtonUpdate;
			core->motion_update = PickerImageBrushMotionUpdate;
			core->create_detail_ui = CreatePickerImageBrushDetailUI;
		}
		break;
	case BRUSH_TYPE_ERASER:
		{
			ERASER* eraser;
			core->brush_type = (uint8)BRUSH_TYPE_ERASER;
			core->brush_data = MEM_ALLOC_FUNC(sizeof(*eraser));
			(void)memset(core->brush_data, 0, sizeof(*eraser));
			core->detail_data_size = sizeof(*eraser);
			eraser = (ERASER*)core->brush_data;

			eraser->core = core;
			eraser->base_scale = 1;
			eraser->r = 10;
			eraser->alpha = 100;
			eraser->outline_hardness = 100;
			// eraser->blur = 0;

			core->press_func = EraserButtonPressCallBack;
			core->motion_func = EraserMotionCallBack;
			core->release_func = EraserReleaseCallBack;
			core->draw_cursor = EraserDrawCursor;
			core->button_update = EraserButtonUpdate;
			core->motion_update = EraserMotionUpdate;
			core->create_detail_ui = CreateEraserDetailUI;
		}
		break;
	case BRUSH_TYPE_BUCKET:
		{
			BUCKET *bucket;
			core->brush_type = (uint8)BRUSH_TYPE_BUCKET;
			core->brush_data = MEM_ALLOC_FUNC(sizeof(*bucket));
			(void)memset(core->brush_data, 0, sizeof(*bucket));
			core->detail_data_size = sizeof(*bucket);
			bucket = (BUCKET*)core->brush_data;

			bucket->threshold = 20;
			bucket->mode = BUCKET_RGBA;
			// bucket->target = BUCKET_TARGET_ACTIVE_LAYER;
			// bucket->extend = 0;

			core->press_func = BucketPressCallBack;
			core->motion_func = BucketMotionCallBack;
			core->release_func = BucketReleaseCallBack;
			core->draw_cursor = BucketDrawCursor;
			core->create_detail_ui = CreateBucketDetailUI;
		}
		break;
	case BRUSH_TYPE_PATTERN_FILL:
		{
			PATTERN_FILL *fill;
			core->brush_type = (uint8)BRUSH_TYPE_PATTERN_FILL;
			core->brush_data = MEM_ALLOC_FUNC(sizeof(*fill));
			(void)memset(core->brush_data, 0, sizeof(*fill));
			core->detail_data_size = sizeof(*fill);
			fill = (PATTERN_FILL*)core->brush_data;

			fill->threshold = 20;
			fill->mode = PATTERN_FILL_RGBA;
			// fill->target = PATTERN_FILL_TARGET_ACTIVE_LAYER;
			// fill->pattern_id = 0;
			fill->scale = 100;
			fill->flow = 1;
			// fill->extend = 0;

			core->press_func = PatternFillPressCallBack;
			core->motion_func = PatternFillMotionCallBack;
			core->release_func = PatternFillReleaseCallBack;
			core->draw_cursor = PatternFillDrawCursor;
			core->create_detail_ui = CreatePatternFillDetailUI;
		}
		break;
	case BRUSH_TYPE_GRADATION:
		{
			GRADATION* gradation;
			core->brush_type = (uint8)BRUSH_TYPE_GRADATION;
			core->brush_data = MEM_ALLOC_FUNC(sizeof(*gradation));
			(void)memset(core->brush_data, 0, sizeof(*gradation));
			core->detail_data_size = sizeof(*gradation);
			core->brush_type = BRUSH_TYPE_GRADATION;
			gradation = (GRADATION*)core->brush_data;

			gradation->app = app;
			core->press_func = GradationPressCallBack;
			core->motion_func = GradationMotionCallBack;
			core->release_func = GradationReleaseCallBack;
			core->draw_cursor = DrawGradationCursor;
			core->create_detail_ui = CreateGrationDetailUI;
			core->change_editting_selection = GradationOnChangeEditSelection;
		}
		break;
	case BRUSH_TYPE_BLUR:
		{
			BLUR_TOOL* blur;
			core->brush_type = (uint8)BRUSH_TYPE_BLUR;
			core->brush_data = MEM_ALLOC_FUNC(sizeof(*blur));
			(void)memset(core->brush_data, 0, sizeof(*blur));
			core->detail_data_size = sizeof(*blur);
			blur = (BLUR_TOOL*)core->brush_data;

			blur->core = core;
			blur->base_scale = 1;
			blur->r = 10;
			blur->alpha = 100;
			blur->outline_hardness = 100;
			// blur->blur = 0;
			blur->color_extend = 50;

			core->press_func = BlurToolPressCallBack;
			core->motion_func = BlurToolMotionCallBack;
			core->release_func = BlurToolReleaseCallBack;
			core->draw_cursor = BlurToolDrawCursor;
			core->button_update = BlurToolButtonUpdate;
			core->motion_update = BlurToolMotionUpdate;
			core->create_detail_ui = CreateBlurToolDetailUI;
		}
		break;
	case BRUSH_TYPE_SMUDGE:
		{
			SMUDGE* smudge;
			core->brush_type = (uint8)BRUSH_TYPE_SMUDGE;
			core->brush_data = MEM_ALLOC_FUNC(sizeof(*smudge));
			(void)memset(core->brush_data, 0, sizeof(*smudge));
			core->detail_data_size = sizeof(*smudge);
			smudge = (SMUDGE*)core->brush_data;

			smudge->core = core;
			smudge->base_scale = 1;
			smudge->r = 10;
			smudge->opacity = 100;
			// smudge->outline_hardness = 0;
			smudge->extention = 50;

			core->press_func = SmudgePressCallBack;
			core->motion_func = SmudgeMotionCallBack;
			core->release_func = SmudgeReleaseCallBack;
			core->draw_cursor = SmudgeDrawCursor;
			core->button_update = SmudgeButtonUpdate;
			core->motion_update = SmudgeMotionUpdate;
			core->create_detail_ui = CreateSmudgeDetailUI;
		}
		break;
	case BRUSH_TYPE_MIX_BRUSH:
		{
			MIX_BRUSH *mix;
			core->brush_type = (uint8)BRUSH_TYPE_MIX_BRUSH;
			core->brush_data = MEM_ALLOC_FUNC(sizeof(*mix));
			(void)memset(core->brush_data, 0, sizeof(*mix));
			core->detail_data_size = sizeof(*mix);
			mix = (MIX_BRUSH*)core->brush_data;

			mix->base_scale = 1;
			mix->r = 10;
			mix->alpha = 100;
			// mix->outline_hardness = 0;
			mix->blur = 100;

			core->press_func = MixBrushPressCallBack;
			core->motion_func = MixBrushMotionCallBack;
			core->release_func = MixBrushReleaseCallBack;
			core->draw_cursor = MixBrushDrawCursor;
			core->button_update = MixBrushButtonUpdate;
			core->motion_update = MixBrushMotionUpdate;
			core->create_detail_ui = CreateMixBrushDetailUI;
		}
		break;
	case BRUSH_TYPE_CUSTOM_BRUSH:
		{
			CUSTOM_BRUSH *brush;
			core->brush_type = (uint8)BRUSH_TYPE_CUSTOM_BRUSH;
			core->brush_data = MEM_ALLOC_FUNC(sizeof(*brush));
			(void)memset(core->brush_data, 0, sizeof(*brush));
			core->detail_data_size = sizeof(*brush);
			brush = (CUSTOM_BRUSH*)core->brush_data;

			brush->base_scale = 1;
			brush->r = 10;
			brush->scale = 10;
			brush->alpha = 1;
			brush->blur = 1;
			brush->outline_hardness = 0;
			brush->enter = 0;
			brush->out = 0;
			brush->start_angle = 0;
			brush->rotate_speed = 0;
			brush->random_size = 0;
			brush->random_angle = 0;
			brush->brush_distance = 1;
			brush->rotate_direction = -1;
			brush->brush_mode = CUSTOM_BRUSH_MODE_NORMAL;
			brush->blend_mode = LAYER_BLEND_NORMAL;
			brush->blend_target = BLEND_BRUSH_TARGET_UNDER_LAYER;
			brush->brush_shape = CUSTOM_BRUSH_SHAPE_CIRCLE;
			brush->color_mode = 0;
			brush->brush_mode = CUSTOM_BRUSH_MODE_NORMAL;
			brush->extend = 128;
			brush->mix = 128;
			brush->num_scatter = 0;
			brush->scatter_range = 1;
			brush->scatter_size = 1;
			brush->scatter_random_size = 0;
			brush->scatter_random_flow = 0;
			brush->pattern_id = 0;

			core->press_func = CustomBrushButtonPressCallBack;
			core->motion_func = CustomBrushMotionCallBack;
			core->release_func = CustomBrushButtonReleaseCallBack;
			core->draw_cursor = CustomBrushDrawCursor;
			core->button_update = CustomBrushButtonUpdate;
			core->motion_update = CustomBrushMotionUpdate;
			core->create_detail_ui = CreateCustomBrushDetailUI;
			core->color_change = CustomBrushColorChange;
		}
		break;
	case BRUSH_TYPE_TEXT:
		{
			TEXT_TOOL* text;
			core->brush_data = MEM_ALLOC_FUNC(sizeof(*text));
			(void)memset(core->brush_data, 0, sizeof(*text));
			core->detail_data_size = sizeof(*text);
			text = (TEXT_TOOL*)core->brush_data;
			core->brush_type = BRUSH_TYPE_TEXT;

			core->press_func = TextToolPressCallBack;
			core->motion_func = TextToolMotionCallBack;
			core->release_func = TextToolReleaseCallBack;
			core->draw_cursor = TextToolDrawCursor;
			core->create_detail_ui = CreateTextToolDetailUI;

			text->base_size = 1;
			text->font_size = 10;
			text->line_width = 3;
			text->back_color[0] = text->back_color[1] =
				text->back_color[2] = text->back_color[3] = 0xff;
			text->line_color[0] = text->line_color[1] = text->line_color[2] = 0;
			text->line_color[3] = 0xff;
			text->balloon_data.num_edge = 10;
			text->balloon_data.num_children = 3;
			text->balloon_data.edge_size = 15;
			text->balloon_data.random_seed = 0;
			text->balloon_data.edge_random_size = 0.15;
			text->balloon_data.edge_random_distance = 0.15;
			text->balloon_data.start_child_size = 0.40;
			text->balloon_data.end_child_size = 0.20;
			// text->font_id = 0;
		}
		break;
	case BRUSH_TYPE_SCRIPT_BRUSH:
		{
			core->brush_type = (uint8)BRUSH_TYPE_SCRIPT_BRUSH;
			core->press_func = ScriptBrushButtonPressCallBack;
			core->motion_func = ScriptBrushMotionCallBack;
			core->release_func = ScriptBrushButtonReleaseCallBack;
			core->draw_cursor = ScriptBrushDrawCursor;
			core->button_update = (brush_update_func)ScriptBrushButtonUpdate;
			core->motion_update = (brush_update_func)ScriptBrushMotionUpdate;
			core->color_change = ScriptBrushColorChange;
			core->create_detail_ui = CreateScriptBrushDetailUI;
		}
		break;
	}

	if(core->button_update == NULL)
	{
		core->button_update = DefaultToolUpdate;
	}

	if(core->motion_update == NULL)
	{
		core->motion_update = DefaultToolUpdate;
	}
}

/*********************************************************
* WriteBrushDetailData関数                               *
* ブラシの詳細設定を書き出す                             *
* 引数                                                   *
* window	: ツールボックスウィンドウ                   *
* file_path	: 書き出すファイルのパス                     *
* app		: アプリケーションを管理する構造体のアドレス *
* 返り値                                                 *
*	正常終了:0	失敗:負の値                              *
*********************************************************/
int WriteBrushDetailData(TOOL_WINDOW* window, const char* file_path, APPLICATION *app)
{
	GFile* fp = g_file_new_for_path(file_path);
	GFileOutputStream* stream =
		g_file_create(fp, G_FILE_CREATE_NONE, NULL, NULL);
	INI_FILE_PTR file;
	char brush_section_name[256];
	char *write_str, brush_name[1024], hot_key[2] = {0};
	int brush_id = 1;
	int x, y;

	// ファイルオープンに失敗したら上書きで試す
	if(stream == NULL)
	{
		stream = g_file_replace(fp, NULL, FALSE, G_FILE_CREATE_NONE, NULL, NULL);

		if(stream == NULL)
		{
			g_object_unref(fp);
			return -1;
		}
	}

	file = CreateIniFile(stream, NULL, 0, INI_WRITE);

	// 文字コードを書き込む
	IniFileAddString(file, "CODE", "CODE_TYPE", window->brush_code);

	// フォントファイル名を書き込む
	IniFileAddString(file, "FONT", "FONT_FILE", window->font_file);

	// ブラシテーブルの内容を書き出す
	for(y=0; y<BRUSH_TABLE_HEIGHT; y++)
	{
		for(x=0; x<BRUSH_TABLE_WIDTH; x++)
		{
			if(window->brushes[y][x].name != NULL)
			{
				(void)sprintf(brush_section_name, "BRUSH%d", brush_id);

				(void)strcpy(brush_name, window->brushes[y][x].name);
				StringRepalce(brush_name, "\n", "\\n");
				write_str = g_convert(brush_name, -1,
					window->brush_code, "UTF-8", NULL, NULL, NULL);

				(void)IniFileAddString(file, brush_section_name,
					"NAME", write_str);
				g_free(write_str);
				(void)IniFileAddString(file, brush_section_name,
					"IMAGE", window->brushes[y][x].image_file_path);
				(void)IniFileAddInteger(file, brush_section_name,
					"X", x, 10);
				(void)IniFileAddInteger(file, brush_section_name,
					"Y", y, 10);
				hot_key[0] = window->brushes[y][x].hot_key;
				(void)IniFileAddString(file, brush_section_name,
					"HOT_KEY", hot_key);

				switch(window->brushes[y][x].brush_type)
				{
				case BRUSH_TYPE_PENCIL:
					{
						PENCIL* pen = (PENCIL*)window->brushes[y][x].brush_data;
						(void)IniFileAddString(file, brush_section_name,
							"TYPE", "PENCIL");
						(void)IniFileAddInteger(file, brush_section_name,
							"MAGNIFICATION", pen->base_scale, 10);
						(void)IniFileAddInteger(file, brush_section_name,
							"SIZE", (int)(pen->r*2), 10);
						(void)IniFileAddInteger(file, brush_section_name,
							"FLOW", (int)(pen->alpha), 10);
						(void)IniFileAddInteger(file, brush_section_name,
							"PRESSURE_SIZE", ((pen->flags & BRUSH_FLAG_SIZE) != 0) ? 1 : 0 , 10);
						(void)IniFileAddInteger(file, brush_section_name,
							"PRESSURE_FLOW", ((pen->flags & BRUSH_FLAG_FLOW) != 0) ? 1 : 0 , 10);
						(void)IniFileAddInteger(file, brush_section_name,
							"OUTLINE_HARDNESS", (int)(pen->outline_hardness), 10);
						(void)IniFileAddInteger(file, brush_section_name,
							"MINIMUM_PRESSURE", (int)(pen->minimum_pressure * 100 + 0.5), 10);
						(void)IniFileAddInteger(file, brush_section_name,
							"ANTI_ALIAS", ((pen->flags & BRUSH_FLAG_ANTI_ALIAS) != 0) ? 1 : 0, 10);
					}
					break;
				case BRUSH_TYPE_HARD_PEN:
					{
						HARD_PEN *pen = (HARD_PEN*)window->brushes[y][x].brush_data;
						(void)IniFileAddString(file, brush_section_name,
							"TYPE", "HARD_PEN");
						(void)IniFileAddInteger(file, brush_section_name,
							"MAGNIFICATION", pen->base_scale, 10);
						(void)IniFileAddInteger(file, brush_section_name,
							"SIZE", (int)(pen->r*2), 10);
						(void)IniFileAddInteger(file, brush_section_name,
							"FLOW", (int)(pen->alpha), 10);
						(void)IniFileAddInteger(file, brush_section_name,
							"PRESSURE_SIZE", ((pen->flags & BRUSH_FLAG_SIZE) != 0) ? 1 : 0 , 10);
						(void)IniFileAddInteger(file, brush_section_name,
							"PRESSURE_FLOW", ((pen->flags & BRUSH_FLAG_FLOW) != 0) ? 1 : 0 , 10);
						(void)IniFileAddInteger(file, brush_section_name,
							"MINIMUM_PRESSURE", (int)(pen->minimum_pressure * 100 + 0.5), 10);
						(void)IniFileAddInteger(file, brush_section_name,
							"ANTI_ALIAS", ((pen->flags & BRUSH_FLAG_ANTI_ALIAS) != 0) ? 1 : 0, 10);
					}
					break;
				case BRUSH_TYPE_AIR_BRUSH:
					{
						AIR_BRUSH *brush = (AIR_BRUSH*)window->brushes[y][x].brush_data;
						(void)IniFileAddString(file, brush_section_name, "TYPE", "AIR_BRUSH");
						(void)IniFileAddInteger(file, brush_section_name, "MAGNIFICATION", brush->base_scale, 10);
						(void)IniFileAddInteger(file, brush_section_name, "SIZE", (int)(brush->r*2), 10);
						(void)IniFileAddInteger(file, brush_section_name, "FLOW", (int)(brush->opacity), 10);
						(void)IniFileAddInteger(file, brush_section_name, "OUTLINE_HARDNESS",
							(int)brush->outline_hardness, 10);
						(void)IniFileAddInteger(file, brush_section_name, "BLUR", (int)brush->blur, 10);
						(void)IniFileAddInteger(file, brush_section_name, "ENTER_SIZE", (int)brush->enter, 10);
						(void)IniFileAddInteger(file, brush_section_name, "OUT_SIZE", (int)brush->out, 10);
						(void)IniFileAddInteger(file, brush_section_name, "BLEND_MODE", brush->blend_mode, 10);
						(void)IniFileAddInteger(file, brush_section_name, "PRESSURE_SIZE",
							((brush->flags & BRUSH_FLAG_SIZE) != 0) ? 1 : 0, 10);
						(void)IniFileAddInteger(file, brush_section_name, "PRESSURE_FLOW",
							((brush->flags & BRUSH_FLAG_FLOW) != 0) ? 1 : 0, 10);
						(void)IniFileAddInteger(file, brush_section_name,
							"ANTI_ALIAS", ((brush->flags & BRUSH_FLAG_ANTI_ALIAS) != 0) ? 1 : 0, 10);
					}
					break;
				case BRUSH_TYPE_OLD_AIR_BRUSH:
					{
						OLD_AIR_BRUSH *brush = (OLD_AIR_BRUSH*)window->brushes[y][x].brush_data;
						(void)IniFileAddString(file, brush_section_name, "TYPE", "OLD_AIR_BRUSH");
						(void)IniFileAddInteger(file, brush_section_name, "SIZE", (int)(brush->r*2), 10);
						(void)IniFileAddInteger(file, brush_section_name, "FLOW", (int)(brush->opacity), 10);
						(void)IniFileAddInteger(file, brush_section_name, "OUTLINE_HARDNESS",
							(int)brush->outline_hardness, 10);
						(void)IniFileAddInteger(file, brush_section_name, "BLUR", (int)brush->blur, 10);
						(void)IniFileAddInteger(file, brush_section_name, "PRESSURE_SIZE",
							((brush->flags & BRUSH_FLAG_SIZE) != 0) ? 1 : 0, 10);
						(void)IniFileAddInteger(file, brush_section_name, "PRESSURE_FLOW",
							((brush->flags & BRUSH_FLAG_FLOW) != 0) ? 1 : 0, 10);
					}
					break;
				case BRUSH_TYPE_BLEND_BRUSH:
					{
						BLEND_BRUSH *brush = (BLEND_BRUSH*)window->brushes[y][x].brush_data;
						(void)IniFileAddString(file, brush_section_name, "TYPE", "BLEND_BRUSH");
						(void)IniFileAddInteger(file, brush_section_name, "MAGNIFICATION", brush->base_scale, 10);
						(void)IniFileAddInteger(file, brush_section_name, "SIZE", (int)(brush->r*2), 10);
						(void)IniFileAddInteger(file, brush_section_name, "FLOW", (int)(brush->opacity), 10);
						(void)IniFileAddInteger(file, brush_section_name, "OUTLINE_HARDNESS",
							(int)brush->outline_hardness, 10);
						(void)IniFileAddInteger(file, brush_section_name, "BLUR", (int)brush->blur, 10);
						(void)IniFileAddInteger(file, brush_section_name, "ENTER_SIZE", (int)brush->enter, 10);
						(void)IniFileAddInteger(file, brush_section_name, "OUT_SIZE", (int)brush->out, 10);
						(void)IniFileAddInteger(file, brush_section_name, "BLEND_MODE", brush->blend_mode, 10);
						(void)IniFileAddInteger(file, brush_section_name, "TARGET", brush->target, 10);
						(void)IniFileAddInteger(file, brush_section_name, "PRESSURE_SIZE",
							((brush->flags & BRUSH_FLAG_SIZE) != 0) ? 1 : 0, 10);
						(void)IniFileAddInteger(file, brush_section_name, "PRESSURE_FLOW",
							((brush->flags & BRUSH_FLAG_FLOW) != 0) ? 1 : 0, 10);
						(void)IniFileAddInteger(file, brush_section_name,
							"ANTI_ALIAS", ((brush->flags & BRUSH_FLAG_ANTI_ALIAS) != 0) ? 1 : 0, 10);
					}
					break;
				case BRUSH_TYPE_WATER_COLOR_BRUSH:
					{
						WATER_COLOR_BRUSH *brush = (WATER_COLOR_BRUSH*)window->brushes[y][x].brush_data;
						(void)IniFileAddString(file, brush_section_name, "TYPE", "WATER_COLOR_BRUSH");
						(void)IniFileAddInteger(file, brush_section_name, "MAGNIFICATION", brush->base_scale, 10);
						(void)IniFileAddInteger(file, brush_section_name, "SIZE", (int)(brush->r*2), 10);
						(void)IniFileAddInteger(file, brush_section_name, "FLOW", (int)brush->alpha, 10);
						(void)IniFileAddInteger(file, brush_section_name, "OUTLINE_HARDNESS",
							(int)brush->outline_hardness, 10);
						(void)IniFileAddInteger(file, brush_section_name, "BLUR", (int)brush->blur, 10);
						(void)IniFileAddInteger(file, brush_section_name, "COLOR_MIX", (int)brush->mix, 10);
						(void)IniFileAddInteger(file, brush_section_name, "COLOR_EXTEND",
							(int)brush->extend, 10);
						(void)IniFileAddInteger(file, brush_section_name, "ENTER_SIZE", (int)brush->enter, 10);
						(void)IniFileAddInteger(file, brush_section_name, "OUT_SIZE", (int)brush->out, 10);
						(void)IniFileAddInteger(file, brush_section_name, "PRESSURE_SIZE",
							((brush->flags & BRUSH_FLAG_SIZE) != 0) ? 1 : 0, 10);
						(void)IniFileAddInteger(file, brush_section_name, "PRESSURE_FLOW",
							((brush->flags & BRUSH_FLAG_FLOW) != 0) ? 1 : 0, 10);
					}
					break;
				case BRUSH_TYPE_STAMP_TOOL:
					{
						STAMP *stamp = (STAMP*)window->brushes[y][x].brush_data;
						(void)IniFileAddString(file, brush_section_name, "TYPE", "STAMP_TOOL");
						(void)IniFileAddInteger(file, brush_section_name, "SIZE",
							(int)(stamp->core.inv_scale*100), 10);
						(void)IniFileAddInteger(file, brush_section_name, "FLOW",
							(int)(stamp->core.flow*100), 10);
						(void)IniFileAddDouble(file, brush_section_name, "DISTANCE",
							stamp->core.stamp_distance, 2);
						(void)IniFileAddInteger(file, brush_section_name, "ROTATE_START",
							(int)(stamp->core.rotate_start * 180 / G_PI), 10);
						(void)IniFileAddInteger(file, brush_section_name, "ROTATE_SPEED",
							(int)(stamp->core.rotate_speed * 180 / G_PI), 10);
						(void)IniFileAddInteger(file, brush_section_name, "ROTATE_DIRECTION",
							stamp->core.rotate_direction, 10);
						(void)IniFileAddInteger(file, brush_section_name, "STAMP_ID",
							stamp->core.stamp_id, 10);
						(void)IniFileAddInteger(file, brush_section_name, "MODE",
							stamp->mode, 10);
						(void)IniFileAddInteger(file, brush_section_name, "PRESSURE_SIZE",
							((stamp->core.flags & STAMP_PRESSURE_SIZE) != 0) ? 1 : 0, 10);
						(void)IniFileAddInteger(file, brush_section_name, "PRESSURE_FLOW",
							((stamp->core.flags & STAMP_PRESSURE_FLOW) != 0) ? 1 : 0, 10);
						(void)IniFileAddInteger(file, brush_section_name, "RANDOM_ROTATE",
							((stamp->core.flags & STAMP_RANDOM_ROTATE) != 0) ? 1 : 0, 10);
						(void)IniFileAddInteger(file, brush_section_name, "RANDOM_SIZE",
							((stamp->core.flags & STAMP_RANDOM_SIZE) != 0) ? 1 : 0, 10);
					}
					break;
				case BRUSH_TYPE_IMAGE_BRUSH:
					{
						IMAGE_BRUSH *brush = (IMAGE_BRUSH*)window->brushes[y][x].brush_data;
						(void)IniFileAddString(file, brush_section_name, "TYPE", "IMAGE_BRUSH");
						(void)IniFileAddInteger(file, brush_section_name, "SIZE",
							(int)(brush->core.inv_scale*100), 10);
						(void)IniFileAddInteger(file, brush_section_name, "FLOW",
							(int)(brush->core.flow*100), 10);
						(void)IniFileAddDouble(file, brush_section_name, "DISTANCE",
							brush->core.stamp_distance, 2);
						(void)IniFileAddInteger(file, brush_section_name, "ROTATE_START",
							(int)(brush->core.rotate_start * 180 / G_PI), 10);
						(void)IniFileAddInteger(file, brush_section_name, "ROTATE_SPEED",
							(int)(brush->core.rotate_speed * 180 / G_PI), 10);
						(void)IniFileAddInteger(file, brush_section_name, "ROTATE_DIRECTION",
							brush->core.rotate_direction, 10);
						(void)IniFileAddInteger(file, brush_section_name, "STAMP_ID",
							brush->core.stamp_id, 10);
						(void)IniFileAddInteger(file, brush_section_name, "MODE",
							brush->mode, 10);
						(void)IniFileAddInteger(file, brush_section_name, "PRESSURE_SIZE",
							((brush->core.flags & STAMP_PRESSURE_SIZE) != 0) ? 1 : 0, 10);
						(void)IniFileAddInteger(file, brush_section_name, "PRESSURE_FLOW",
							((brush->core.flags & STAMP_PRESSURE_FLOW) != 0) ? 1 : 0, 10);
						(void)IniFileAddInteger(file, brush_section_name, "ROTATE_TO_BRUSH_DIRECTION",
							((brush->core.flags & BRUSH_FLAG_ROTATE) != 0) ? 1 : 0, 10);
						(void)IniFileAddInteger(file, brush_section_name, "RANDOM_ROTATE",
							((brush->core.flags & STAMP_RANDOM_ROTATE) != 0) ? 1 : 0, 10);
						(void)IniFileAddInteger(file, brush_section_name, "RANDOM_SIZE",
							((brush->core.flags & STAMP_RANDOM_SIZE) != 0) ? 1 : 0, 10);
						(void)IniFileAddInteger(file, brush_section_name, "SIZE_RANGE",
							(int)(brush->size_range * 100), 10);
						(void)IniFileAddInteger(file, brush_section_name, "ROTATE_RANGE",
							brush->random_rotate_range, 10);
					}
					break;
				case BRUSH_TYPE_BLEND_IMAGE_BRUSH:
					{
						BLEND_IMAGE_BRUSH *brush = (BLEND_IMAGE_BRUSH*)window->brushes[y][x].brush_data;
						(void)IniFileAddString(file, brush_section_name, "TYPE", "BLEND_IMAGE_BRUSH");
						(void)IniFileAddInteger(file, brush_section_name, "SIZE",
							(int)(brush->core.inv_scale*100), 10);
						(void)IniFileAddInteger(file, brush_section_name, "FLOW",
							(int)(brush->core.flow*100), 10);
						(void)IniFileAddDouble(file, brush_section_name, "DISTANCE",
							brush->core.stamp_distance, 2);
						(void)IniFileAddInteger(file, brush_section_name, "ROTATE_START",
							(int)(brush->core.rotate_start * 180 / G_PI), 10);
						(void)IniFileAddInteger(file, brush_section_name, "ROTATE_SPEED",
							(int)(brush->core.rotate_speed * 180 / G_PI), 10);
						(void)IniFileAddInteger(file, brush_section_name, "ROTATE_DIRECTION",
							brush->core.rotate_direction, 10);
						(void)IniFileAddInteger(file, brush_section_name, "STAMP_ID",
							brush->core.stamp_id, 10);
						(void)IniFileAddInteger(file, brush_section_name, "MODE",
							brush->mode, 10);
						(void)IniFileAddInteger(file, brush_section_name, "PRESSURE_SIZE",
							((brush->core.flags & STAMP_PRESSURE_SIZE) != 0) ? 1 : 0, 10);
						(void)IniFileAddInteger(file, brush_section_name, "PRESSURE_FLOW",
							((brush->core.flags & STAMP_PRESSURE_FLOW) != 0) ? 1 : 0, 10);
						(void)IniFileAddInteger(file, brush_section_name, "ROTATE_TO_BRUSH_DIRECTION",
							((brush->core.flags & BRUSH_FLAG_ROTATE) != 0) ? 1 : 0, 10);
						(void)IniFileAddInteger(file, brush_section_name, "RANDOM_ROTATE",
							((brush->core.flags & STAMP_RANDOM_ROTATE) != 0) ? 1 : 0, 10);
						(void)IniFileAddInteger(file, brush_section_name, "RANDOM_SIZE",
							((brush->core.flags & STAMP_RANDOM_SIZE) != 0) ? 1 : 0, 10);
						(void)IniFileAddInteger(file, brush_section_name, "SIZE_RANGE",
							(int)(brush->size_range * 100), 10);
						(void)IniFileAddInteger(file, brush_section_name, "ROTATE_RANGE",
							brush->random_rotate_range, 10);
						(void)IniFileAddInteger(file, brush_section_name, "BLEND_MODE", brush->blend_mode, 10);
						(void)IniFileAddInteger(file, brush_section_name, "TARGET", brush->target, 10);
					}
					break;
				case BRUSH_TYPE_PICKER_BRUSH:
					{
						PICKER_BRUSH *brush = (PICKER_BRUSH*)window->brushes[y][x].brush_data;
						(void)IniFileAddString(file, brush_section_name, "TYPE", "PICKER_BRUSH");
						(void)IniFileAddInteger(file, brush_section_name, "MAGNIFICATION", brush->base_scale, 10);
						(void)IniFileAddInteger(file, brush_section_name, "SIZE", (int)(brush->r*2), 10);
						(void)IniFileAddInteger(file, brush_section_name, "FLOW", (int)(brush->alpha), 10);
						(void)IniFileAddInteger(file, brush_section_name, "OUTLINE_HARDNESS",
							(int)brush->outline_hardness, 10);
						(void)IniFileAddInteger(file, brush_section_name, "BLUR", (int)brush->blur, 10);
						(void)IniFileAddInteger(file, brush_section_name, "BLEND_MODE", brush->blend_mode, 10);
						(void)IniFileAddInteger(file, brush_section_name, "PICK_MODE", brush->picker_mode, 10);
						(void)IniFileAddInteger(file, brush_section_name, "PICK_TARGET", brush->picker_source, 10);
						(void)IniFileAddInteger(file, brush_section_name, "HUE", brush->add_h, 10);
						(void)IniFileAddInteger(file, brush_section_name, "SATURATION", brush->add_s, 10);
						(void)IniFileAddInteger(file, brush_section_name, "BRIGHTNESS", brush->add_v, 10);
						(void)IniFileAddInteger(file, brush_section_name, "PRESSURE_SIZE",
							((brush->flags & BRUSH_FLAG_SIZE) != 0) ? 1 : 0, 10);
						(void)IniFileAddInteger(file, brush_section_name, "PRESSURE_FLOW",
							((brush->flags & BRUSH_FLAG_FLOW) != 0) ? 1 : 0, 10);
						(void)IniFileAddInteger(file, brush_section_name,
							"ANTI_ALIAS", ((brush->flags & BRUSH_FLAG_ANTI_ALIAS) != 0) ? 1 : 0, 10);
					}
					break;
				case BRUSH_TYPE_PICKER_IMAGE_BRUSH:
					{
						PICKER_IMAGE_BRUSH *brush = (PICKER_IMAGE_BRUSH*)window->brushes[y][x].brush_data;
						(void)IniFileAddString(file, brush_section_name, "TYPE", "PICKER_IMAGE_BRUSH");
						(void)IniFileAddInteger(file, brush_section_name, "SIZE",
							(int)(brush->core.inv_scale*100), 10);
						(void)IniFileAddInteger(file, brush_section_name, "FLOW",
							(int)(brush->core.flow*100), 10);
						(void)IniFileAddDouble(file, brush_section_name, "DISTANCE",
							brush->core.stamp_distance, 2);
						(void)IniFileAddInteger(file, brush_section_name, "ROTATE_START",
							(int)(brush->core.rotate_start * 180 / G_PI), 10);
						(void)IniFileAddInteger(file, brush_section_name, "ROTATE_SPEED",
							(int)(brush->core.rotate_speed * 180 / G_PI), 10);
						(void)IniFileAddInteger(file, brush_section_name, "ROTATE_DIRECTION",
							brush->core.rotate_direction, 10);
						(void)IniFileAddInteger(file, brush_section_name, "STAMP_ID",
							brush->core.stamp_id, 10);
						(void)IniFileAddInteger(file, brush_section_name, "PRESSURE_SIZE",
							((brush->core.flags & STAMP_PRESSURE_SIZE) != 0) ? 1 : 0, 10);
						(void)IniFileAddInteger(file, brush_section_name, "PRESSURE_FLOW",
							((brush->core.flags & STAMP_PRESSURE_FLOW) != 0) ? 1 : 0, 10);
						(void)IniFileAddInteger(file, brush_section_name, "ROTATE_TO_BRUSH_DIRECTION",
							((brush->core.flags & BRUSH_FLAG_ROTATE) != 0) ? 1 : 0, 10);
						(void)IniFileAddInteger(file, brush_section_name, "RANDOM_ROTATE",
							((brush->core.flags & STAMP_RANDOM_ROTATE) != 0) ? 1 : 0, 10);
						(void)IniFileAddInteger(file, brush_section_name, "RANDOM_SIZE",
							((brush->core.flags & STAMP_RANDOM_SIZE) != 0) ? 1 : 0, 10);
						(void)IniFileAddInteger(file, brush_section_name, "SIZE_RANGE",
							(int)(brush->size_range * 100), 10);
						(void)IniFileAddInteger(file, brush_section_name, "ROTATE_RANGE",
							brush->random_rotate_range, 10);
						(void)IniFileAddInteger(file, brush_section_name, "PICK_MODE", brush->picker_mode, 10);
						(void)IniFileAddInteger(file, brush_section_name, "PICK_TARGET", brush->picker_source, 10);
						(void)IniFileAddInteger(file, brush_section_name, "HUE", brush->add_h, 10);
						(void)IniFileAddInteger(file, brush_section_name, "SATURATION", brush->add_s, 10);
						(void)IniFileAddInteger(file, brush_section_name, "BRIGHTNESS", brush->add_v, 10);
					}
					break;
				case BRUSH_TYPE_ERASER:
					{
						ERASER *eraser = (ERASER*)window->brushes[y][x].brush_data;
						(void)IniFileAddString(file, brush_section_name, "TYPE", "ERASER");
						(void)IniFileAddInteger(file, brush_section_name,
							"MAGNIFICATION", eraser->base_scale, 10);
						(void)IniFileAddInteger(file, brush_section_name,
							"SIZE", (int)(eraser->r * 2), 10);
						(void)IniFileAddInteger(file, brush_section_name,
							"FLOW", (int)eraser->alpha, 10);
						(void)IniFileAddInteger(file, brush_section_name, "OUTLINE_HARDNESS",
							(int)eraser->outline_hardness, 10);
						(void)IniFileAddInteger(file, brush_section_name, "BLUR", (int)eraser->blur, 10);
						(void)IniFileAddInteger(file, brush_section_name, "PRESSURE_SIZE",
							((eraser->flags & BRUSH_FLAG_SIZE) != 0) ? 1 : 0, 10);
						(void)IniFileAddInteger(file, brush_section_name, "PRESSURE_FLOW",
							((eraser->flags & BRUSH_FLAG_FLOW) != 0) ? 1 : 0, 10);
					}
					break;
				case BRUSH_TYPE_BUCKET:
					{
						BUCKET *bucket = (BUCKET*)window->brushes[y][x].brush_data;
						(void)IniFileAddString(file, brush_section_name, "TYPE", "BUCKET");
						(void)IniFileAddInteger(file, brush_section_name,
							"THRESHOLD", bucket->threshold, 10);
						(void)IniFileAddInteger(file, brush_section_name,
							"MODE", bucket->mode, 10);
						(void)IniFileAddInteger(file, brush_section_name,
							"TARGET", bucket->target, 10);
						(void)IniFileAddInteger(file, brush_section_name,
							"EXTEND", bucket->extend, 10);
					}
					break;
				case BRUSH_TYPE_PATTERN_FILL:
					{
						PATTERN_FILL *fill = (PATTERN_FILL*)window->brushes[y][x].brush_data;
						(void)IniFileAddString(file, brush_section_name, "TYPE", "PATTERN_FILL");
						(void)IniFileAddInteger(file, brush_section_name,
							"THRESHOLD", fill->threshold, 10);
						(void)IniFileAddInteger(file, brush_section_name, "MODE", fill->mode, 10);
						(void)IniFileAddInteger(file, brush_section_name, "TARGET", fill->target, 10);
						(void)IniFileAddInteger(file, brush_section_name,
							"PATTERN_ID", fill->pattern_id, 10);
						(void)IniFileAddInteger(file, brush_section_name, "SIZE", (int)fill->scale, 10);
						(void)IniFileAddInteger(file, brush_section_name, "FLOW", (int)(fill->flow*100), 10);
						(void)IniFileAddInteger(file, brush_section_name,
							"EXTEND", fill->extend, 10);
					}
					break;
				case BRUSH_TYPE_GRADATION:
					{
						GRADATION *gradation = (GRADATION*)window->brushes[y][x].brush_data;
						(void)IniFileAddString(file, brush_section_name, "TYPE", "GRADATION");
						(void)IniFileAddInteger(file, brush_section_name,
							"COLOR_REVERSE", ((gradation->flags & GRADATION_COLOR_REVERSE)  != 0) ? 1 : 0, 10);
					}
					break;
				case BRUSH_TYPE_BLUR:
					{
						BLUR_TOOL *blur = (BLUR_TOOL*)window->brushes[y][x].brush_data;
						(void)IniFileAddString(file, brush_section_name, "TYPE", "BLUR_TOOL");
						(void)IniFileAddInteger(file, brush_section_name, "MAGNIFICATION", blur->base_scale, 10);
						(void)IniFileAddInteger(file, brush_section_name, "SIZE", (int)(blur->r*2), 10);
						(void)IniFileAddInteger(file, brush_section_name, "FLOW", (int)blur->alpha, 10);
						(void)IniFileAddInteger(file, brush_section_name,
							"OUTLINE_HARDNESS", (int)blur->outline_hardness, 10);
						(void)IniFileAddInteger(file, brush_section_name,
							"BLUR", (int)blur->blur, 10);
						(void)IniFileAddInteger(file, brush_section_name, "COLOR_EXTEND",
							(int)blur->color_extend, 10);
						(void)IniFileAddInteger(file, brush_section_name, "PRESSURE_SIZE",
							((blur->flags & BRUSH_FLAG_SIZE) != 0) ? 1 : 0, 10);
						(void)IniFileAddInteger(file, brush_section_name, "PRESSURE_FLOW",
							((blur->flags & BRUSH_FLAG_FLOW) != 0) ? 1 : 0, 10);
					}
					break;
				case BRUSH_TYPE_SMUDGE:
					{
						SMUDGE *smudge = (SMUDGE*)window->brushes[y][x].brush_data;
						(void)IniFileAddString(file, brush_section_name, "TYPE", "SMUDGE");
						(void)IniFileAddInteger(file, brush_section_name, "MAGNIFICATION", smudge->base_scale, 10);
						(void)IniFileAddInteger(file, brush_section_name, "SIZE", (int)(smudge->r*2), 10);
						(void)IniFileAddInteger(file, brush_section_name, "OPACITY", (int)smudge->opacity, 10);
						(void)IniFileAddInteger(file, brush_section_name,
							"OUTLINE_HARDNESS", (int)smudge->outline_hardness, 10);
						(void)IniFileAddInteger(file, brush_section_name, "BLUR",
							(int)smudge->blur, 10);
						(void)IniFileAddInteger(file, brush_section_name,
							"COLOR_EXTEND", (int)smudge->extention, 10);
						(void)IniFileAddInteger(file, brush_section_name, "PRESSURE_SIZE",
							((smudge->flags & SMUDGE_PRESSURE_SIZE) != 0) ? 1 : 0, 10);
						(void)IniFileAddInteger(file, brush_section_name, "PRESSURE_EXTENTION",
							((smudge->flags & SMUDGE_PRESSURE_EXTENTION) != 0) ? 1 : 0, 10);
					}
					break;
				case BRUSH_TYPE_MIX_BRUSH:
					{
						MIX_BRUSH *mix = (MIX_BRUSH*)window->brushes[y][x].brush_data;
						(void)IniFileAddString(file, brush_section_name, "TYPE", "MIX_BRUSH");
						(void)IniFileAddInteger(file, brush_section_name, "MAGNIFICATION", mix->base_scale, 10);
						(void)IniFileAddInteger(file, brush_section_name, "SIZE", (int)(mix->r*2), 10);
						(void)IniFileAddInteger(file, brush_section_name, "FLOW", (int)(mix->alpha), 10);
						(void)IniFileAddInteger(file, brush_section_name, "OUTLINE_HARDNESS",
							(int)mix->outline_hardness, 10);
						(void)IniFileAddInteger(file, brush_section_name, "BLUR", (int)mix->blur, 10);
						(void)IniFileAddInteger(file, brush_section_name, "PRESSURE_SIZE",
							((mix->flags & BRUSH_FLAG_SIZE) != 0) ? 1 : 0, 10);
						(void)IniFileAddInteger(file, brush_section_name, "PRESSURE_FLOW",
							((mix->flags & BRUSH_FLAG_FLOW) != 0) ? 1 : 0, 10);
					}
					break;
				case BRUSH_TYPE_TEXT:
					{
						TEXT_TOOL *text = (TEXT_TOOL*)window->brushes[y][x].brush_data;
						char str[128];
						(void)IniFileAddString(file, brush_section_name, "TYPE", "TEXT_TOOL");
						(void)IniFileAddInteger(file, brush_section_name, "MAGNIFICATION", text->base_size, 10);
						(void)IniFileAddInteger(file, brush_section_name, "SIZE", (int)text->font_size, 10);
						(void)IniFileAddInteger(file, brush_section_name, "NUM_EDGE", (int)text->balloon_data.num_edge, 10);
						(void)IniFileAddInteger(file, brush_section_name, "NUM_CHILDREN", (int)text->balloon_data.num_children, 10);
						(void)IniFileAddDouble(file, brush_section_name, "EDGE_SIZE", text->balloon_data.edge_size, 1);
						(void)IniFileAddInteger(file, brush_section_name, "RANDOM_SEED", (int)text->balloon_data.random_seed, 10);
						(void)IniFileAddDouble(file, brush_section_name, "RANDOM_EDGE_SIZE", text->balloon_data.edge_random_size * 100, 1);
						(void)IniFileAddDouble(file, brush_section_name, "RANDOM_EDGE_DISTANCE", text->balloon_data.edge_random_distance * 100, 1);
						(void)IniFileAddDouble(file, brush_section_name, "START_CHILD_SIZE", text->balloon_data.start_child_size * 100, 1);
						(void)IniFileAddDouble(file, brush_section_name, "END_CHILD_SIZE", text->balloon_data.end_child_size * 100, 1);
						(void)IniFileAddInteger(file, brush_section_name, "VERTICAL",
							((text->flags & TEXT_TOOL_VERTICAL) != 0) ? 1 : 0, 10);
						(void)IniFileAddString(file, brush_section_name, "FONT_NAME",
							pango_font_family_get_name(app->font_list[text->font_id]));
						(void)IniFileAddInteger(file, brush_section_name, "BALLOON_TYPE", text->balloon_type, 10);
						(void)IniFileAddDouble(file, brush_section_name, "LINE_WIDTH", text->line_width, 1);
						(void)sprintf(str, "%02x%02x%02x%02x", text->back_color[0], text->back_color[1],
							text->back_color[2], text->back_color[3]);
						(void)IniFileAddString(file, brush_section_name, "BACK_COLOR", str);
						(void)sprintf(str, "%02x%02x%02x%02x", text->line_color[0], text->line_color[1],
							text->line_color[2], text->line_color[3]);
						(void)IniFileAddString(file, brush_section_name, "LINE_COLOR", str);
						(void)IniFileAddInteger(file, brush_section_name, "BALLOON_HAS_EDGE",
							((text->flags & TEXT_TOOL_BALLOON_HAS_EDGE) != 0) ? 1 : 0, 10);
						(void)IniFileAddInteger(file, brush_section_name, "CENTERING_HORIZONTALLY",
							((text->flags & TEXT_TOOL_CENTERING_HORIZONTALLY) != 0) ? 1 : 0, 10);
						(void)IniFileAddInteger(file, brush_section_name, "CENTERING_VERTICALLY",
							((text->flags & TEXT_TOOL_CENTERING_VERTICALLY) != 0) ? 1 : 0, 10);
						(void)IniFileAddInteger(file, brush_section_name, "ADJUST_RANGE_TO_TEXT",
							((text->flags & TEXT_TOOL_ADJUST_RANGE_TO_TEXT) != 0) ? 1 : 0, 10);
					}
					break;
				case BRUSH_TYPE_SCRIPT_BRUSH:
					{
						SCRIPT *script = (SCRIPT*)window->brushes[y][x].brush_data;
						gchar *system_name = g_locale_from_utf8(script->file_name, -1, NULL, NULL, NULL);
						(void)IniFileAddString(file, brush_section_name, "TYPE", "SCRIPT_BRUSH");
						(void)IniFileAddString(file, brush_section_name, "FILE_NAME", system_name);
						g_free(system_name);
					}
					break;
				case BRUSH_TYPE_CUSTOM_BRUSH:
					{
						CUSTOM_BRUSH *brush = (CUSTOM_BRUSH*)window->brushes[y][x].brush_data;
						(void)IniFileAddString(file, brush_section_name, "TYPE", "CUSTOM_BRUSH");
						(void)IniFileAddInteger(file, brush_section_name, "MAGNIFICATION", brush->base_scale, 10);
						(void)IniFileAddDouble(file, brush_section_name, "SIZE", brush->scale, 1);
						(void)IniFileAddDouble(file, brush_section_name, "FLOW", brush->alpha * 100, 1);
						(void)IniFileAddDouble(file, brush_section_name, "BLUR", brush->blur * 100, 1);
						(void)IniFileAddDouble(file, brush_section_name, "OUTLINE_HARDNESS", brush->outline_hardness * 100, 1);
						(void)IniFileAddDouble(file, brush_section_name, "ENTER", brush->enter * 100, 1);
						(void)IniFileAddDouble(file, brush_section_name, "OUT", brush->out * 100, 1);
						(void)IniFileAddDouble(file, brush_section_name, "ANGLE", brush->start_angle * 180 / G_PI, 1);
						(void)IniFileAddDouble(file, brush_section_name, "ROTATE_SPEED", brush->rotate_speed * 180 / G_PI, 1);
						(void)IniFileAddDouble(file, brush_section_name, "RANDOM_SIZE", brush->random_size * 100, 1);
						(void)IniFileAddDouble(file, brush_section_name, "RANDOM_ANGLE", brush->random_angle * 180 / G_PI, 1);
						(void)IniFileAddDouble(file, brush_section_name, "DRAW_DISTANCE", brush->brush_distance, 1);
						(void)IniFileAddInteger(file, brush_section_name, "ROTATE_DIRECTION", (int)brush->rotate_direction, 10);
						(void)IniFileAddInteger(file, brush_section_name, "BLEND_MODE", brush->blend_mode, 10);
						(void)IniFileAddInteger(file, brush_section_name, "BLEND_TARGET", brush->blend_target, 10);
						(void)IniFileAddInteger(file, brush_section_name, "COLOR_EXTEND", brush->extend, 10);
						(void)IniFileAddInteger(file, brush_section_name, "COLOR_MIX", brush->mix, 10);
						(void)IniFileAddInteger(file, brush_section_name, "BRUSH_SHAPE", brush->brush_shape, 10);
						(void)IniFileAddInteger(file, brush_section_name, "COLOR_MODE", brush->color_mode, 10);
						(void)IniFileAddInteger(file, brush_section_name, "BRUSH_MODE", brush->brush_mode, 10);
						(void)IniFileAddInteger(file, brush_section_name, "PICKER_MODE", brush->picker_mode, 10);
						(void)IniFileAddInteger(file, brush_section_name, "HUE", brush->hue, 10);
						(void)IniFileAddInteger(file, brush_section_name, "SATURATION", brush->saturation, 10);
						(void)IniFileAddInteger(file, brush_section_name, "BRIGHTNESS", brush->brightness, 10);
						(void)IniFileAddInteger(file, brush_section_name, "NUM_SCATTER", brush->num_scatter, 10);
						(void)IniFileAddDouble(file, brush_section_name, "SCATTER_RANGE", brush->scatter_range * 100, 1);
						(void)IniFileAddDouble(file, brush_section_name, "SCATTER_SIZE", brush->scatter_size * 100, 1);
						(void)IniFileAddDouble(file, brush_section_name, "SCATTER_RANDOM_SIZE", brush->scatter_random_size * 100, 1);
						(void)IniFileAddDouble(file, brush_section_name, "SCATTER_RANDOM_FLOW", brush->scatter_random_flow * 100, 1);
						(void)IniFileAddInteger(file, brush_section_name, "PATTERN_ID", brush->pattern_id, 10);

						if(brush->brush_shape == CUSTOM_BRUSH_SHAPE_IMAGE)
						{
							FILE *fp;
							GDir *dir;
							gchar *dir_path;
							gchar *new_dir_path;
							gchar *image_path;
							gchar *system_path;
							gchar image_name[256];

							dir_path = g_path_get_dirname(file_path);
							new_dir_path = g_build_filename(dir_path, "brushes", NULL);
							if((dir = g_dir_open(new_dir_path, 0, NULL)) == NULL)
							{
								(void)g_mkdir(new_dir_path,
#ifdef __MAC_OS__
								S_IRUSR | S_IWUSR | S_IXUSR |
								S_IRGRP | S_IWGRP | S_IXGRP |
								S_IROTH | S_IXOTH | S_IXOTH
#elif defined(_WIN32)
								0
#else
								S_IRUSR | S_IWUSR | S_IXUSR |
								S_IRGRP | S_IWGRP | S_IXGRP |
								S_IROTH | S_IXOTH | S_IXOTH
#endif
								);
							}
							else
							{
								g_dir_close(dir);
							}

							(void)sprintf(image_name, "brush%d.png", y * BRUSH_TABLE_WIDTH + x);
							image_path = g_build_filename(new_dir_path, image_name, NULL);
							system_path = g_locale_from_utf8(image_path, -1, NULL, NULL, NULL);

							if(brush->image_pixel != NULL)
							{
								fp = fopen(system_path, "wb");
								WritePNGStream((void*)fp, (stream_func_t)fread, NULL,
									brush->image_pixel, brush->image_width, brush->image_height, brush->image_width * brush->image_channel,
										brush->image_channel, 0, Z_DEFAULT_COMPRESSION);
								(void)fclose(fp);
							}

							(void)IniFileAddString(file, brush_section_name, "IMAGE_NAME", image_name);

							g_free(system_path);
							g_free(image_path);
							g_free(new_dir_path);
							g_free(dir_path);
						}

						(void)IniFileAddInteger(file, brush_section_name, "PRESSURE_SIZE", brush->flags & (1 << CUSTOM_BRUSH_FLAG_PRESSURE_SIZE), 10);
						(void)IniFileAddInteger(file, brush_section_name, "PRESSURE_FLOW", brush->flags & (1 << CUSTOM_BRUSH_FLAG_PRESSURE_FLOW), 10);
						(void)IniFileAddInteger(file, brush_section_name, "ROTATE_BY_CURSOR", brush->flags & (1 << CUSTOM_BRUSH_FLAG_ROTATE_BY_CURSOR), 10);
						(void)IniFileAddInteger(file, brush_section_name, "RANDOM_SIZE", brush->flags & (1 << CUSTOM_BRUSH_FLAG_RANDOM_SIZE), 10);
						(void)IniFileAddInteger(file, brush_section_name, "RANDOM_ROTATE", brush->flags & (1 << CUSTOM_BRUSH_FLAG_RANDOM_ROTATE), 10);
						(void)IniFileAddInteger(file, brush_section_name, "ANTI_ALIAS", brush->flags & (1 << CUSTOM_BRUSH_FLAG_ANTI_ALIAS), 10);
						(void)IniFileAddInteger(file, brush_section_name, "FLIP_HORIZONTALLY", brush->flags & (1 << CUSTOM_BRUSH_FLAG_IMAGE_FLIP_HORIZONTALLY), 10);
						(void)IniFileAddInteger(file, brush_section_name, "FLIP_VERTICALLY", brush->flags & (1 << CUSTOM_BRUSH_FLAG_IMAGE_FLIP_VERTICALLY), 10);
						(void)IniFileAddInteger(file, brush_section_name, "DRAW_SCATTER_ONLY", brush->flags & (1 << CUSTOM_BRUSH_FLAG_DRAW_ONLY_SCATTER), 10);
					}
					break;
				case BRUSH_TYPE_PLUG_IN:
					{
						PLUG_IN_BRUSH *brush = (PLUG_IN_BRUSH*)window->brushes[y][x].brush_data;
						GModule *module;
						gpointer function;
						gchar *file_path;

						file_path = g_build_filename(app->current_path, PLUG_IN_DIRECTORY, brush->plug_in_name, NULL);

						module = g_module_open(file_path, G_MODULE_BIND_LOCAL);

						if(module != NULL)
						{
							(void)IniFileAddString(file, brush_section_name, "TYPE", "PLUG_IN_BRUSH");
							(void)IniFileAddString(file, brush_section_name, "PLUG_IN_FILE", brush->plug_in_name);

							if(g_module_symbol(module, "SaveBrushSetting", &function) != FALSE)
							{
								((void (*)(BRUSH_CORE*, INI_FILE_PTR, const char*, APPLICATION*))function)(
									&window->brushes[y][x], file, brush_section_name, app);
							}
						}
					}
					break;
				}
				brush_id++;
			}	// if(window->brushes[y][x].name != NULL)
		}	// for(x=0; x<VECTOR_BRUSH_TABLE_WIDTH; x++)
	}	// for(y=0; y<VECTOR_BRUSH_TABLE_HEIGHT; y++)

	WriteIniFile(file, (size_t (*)(void*, size_t, size_t, void*))FileWrite);
	file->delete_func(file);

	g_object_unref(fp);
	g_object_unref(stream);

	return 0;
}

/*****************************************************
* SetBrushCallBack関数                               *
* ブラシのマウス関連のコールバック関数を設定する     *
* 引数                                               *
* core	: コールバック関数を設定するブラシの基本情報 *
*****************************************************/
void SetBrushCallBack(BRUSH_CORE* core)
{
	switch(core->brush_type)
	{
	case BRUSH_TYPE_PENCIL:
		core->press_func = PencilPressCallBack;
		core->motion_func = PencilMotionCallBack;
		core->release_func = PencilReleaseCallBack;
		break;
	case BRUSH_TYPE_HARD_PEN:
		core->press_func = HardPenButtonPressCallBack;
		core->motion_func = HardPenMotionCallBack;
		core->release_func = HardPenButtonReleaseCallBack;
		break;
	case BRUSH_TYPE_AIR_BRUSH:
		core->press_func = AirBrushPressCallBack;
		core->motion_func = AirBrushMotionCallBack;
		core->release_func = AirBrushReleaseCallBack;
		break;
	case BRUSH_TYPE_OLD_AIR_BRUSH:
		core->press_func = OldAirBrushPressCallBack;
		core->motion_func = OldAirBrushMotionCallBack;
		core->release_func = OldAirBrushReleaseCallBack;
		break;
	case BRUSH_TYPE_WATER_COLOR_BRUSH:
		core->press_func = WaterColorBrushPressCallBack;
		core->motion_func = WaterColorBrushMotionCallBack;
		core->release_func = WaterColorBrushReleaseCallBack;
		break;
	case BRUSH_TYPE_STAMP_TOOL:
		core->press_func = StampToolButtonPressCallBack;
		core->motion_func = StampToolMotionCallBack;
		core->release_func = StampToolReleaseCallBack;
		break;
	case BRUSH_TYPE_IMAGE_BRUSH:
		core->press_func = ImageBrushPressCallBack;
		core->motion_func = ImageBrushMotionCallBack;
		core->release_func = ImageBrushReleaseCallBack;
		break;
	case BRUSH_TYPE_BLEND_IMAGE_BRUSH:
		core->press_func = BlendImageBrushButtonPressCallBack;
		core->motion_func = BlendImageBrushMotionCallBack;
		core->release_func = BlendImageBrushButtonReleaseCallBack;
		break;
	case BRUSH_TYPE_ERASER:
		core->press_func = EraserButtonPressCallBack;
		core->motion_func = EraserMotionCallBack;
		core->release_func = EraserReleaseCallBack;
		break;
	case BRUSH_TYPE_BUCKET:
		core->press_func = BucketPressCallBack;
		core->motion_func = BucketMotionCallBack;
		core->release_func = BucketReleaseCallBack;
		break;
	case BRUSH_TYPE_PATTERN_FILL:
		core->press_func = PatternFillPressCallBack;
		core->motion_func = PatternFillMotionCallBack;
		core->release_func = PatternFillReleaseCallBack;
		break;
	case BRUSH_TYPE_GRADATION:
		core->press_func = GradationPressCallBack;
		core->motion_func = GradationMotionCallBack;
		core->release_func = GradationReleaseCallBack;
		break;
	case BRUSH_TYPE_BLUR:
		core->press_func = BlurToolPressCallBack;
		core->motion_func = BlurToolMotionCallBack;
		core->release_func = BlurToolReleaseCallBack;
		break;
	case BRUSH_TYPE_SMUDGE:
		core->press_func = SmudgePressCallBack;
		core->motion_func = SmudgeMotionCallBack;
		core->release_func = SmudgeReleaseCallBack;
		break;
	case BRUSH_TYPE_MIX_BRUSH:
		core->press_func = MixBrushPressCallBack;
		core->motion_func = MixBrushMotionCallBack;
		core->release_func = MixBrushReleaseCallBack;
		break;
	case BRUSH_TYPE_CUSTOM_BRUSH:
		core->press_func = CustomBrushButtonPressCallBack;
		core->motion_func = CustomBrushMotionCallBack;
		core->release_func = CustomBrushButtonReleaseCallBack;
		break;
	}
}

/*************************************************************
* SetEditSelectionCallBack関数                               *
* ブラシのマウス関連のコールバック関数を選択範囲編集用にする *
* 引数                                                       *
* core	: コールバック関数を設定するブラシの基本情報         *
*************************************************************/
void SetEditSelectionCallBack(BRUSH_CORE* core)
{
	switch(core->brush_type)
	{
	case BRUSH_TYPE_PENCIL:
		core->press_func = PencilEditSelectionPressCallBack;
		core->motion_func = PencilEditSelectionMotionCallBack;
		core->release_func = PencilEditSelectionReleaseCallBack;
		break;
	case BRUSH_TYPE_HARD_PEN:
		core->press_func = HardPenEditSelectionPressCallBack;
		core->motion_func = HardPenEditSelectionMotionCallBack;
		core->release_func = HardPenEditSelectionReleaseCallBack;
		break;
	case BRUSH_TYPE_AIR_BRUSH:
		core->press_func = AirBrushEditSelectionPressCallBack;
		core->motion_func = AirBrushEditSelectionMotionCallBack;
		core->release_func = AirBrushEditSelectionReleaseCallBack;
		break;
	case BRUSH_TYPE_OLD_AIR_BRUSH:
		core->press_func = OldAirBrushEditSelectionPressCallBack;
		core->motion_func = OldAirBrushEditSelectionMotionCallBack;
		core->release_func = OldAirBrushEditSelectionReleaseCallBack;
		break;
	case BRUSH_TYPE_WATER_COLOR_BRUSH:
		core->press_func = WaterColorBrushEditSelectionPressCallBack;
		core->motion_func = WaterColorBrushEditSelectionMotionCallBack;
		core->release_func = WaterColorBrushEditSelectionReleaseCallBack;
		break;
	case BRUSH_TYPE_STAMP_TOOL:
		core->press_func = StampToolEditSelectionPressCallBack;
		core->motion_func = StampToolEditSelectionMotionCallBack;
		core->release_func = StampToolEditSelectionReleaseCallBack;
		break;
	case BRUSH_TYPE_ERASER:
		core->press_func = EraserEditSelectionButtonPressCallBack;
		core->motion_func = EraserEditSelectionMotionCallBack;
		core->release_func = EraserEditSelectionReleaseCallBack;
		break;
	case BRUSH_TYPE_IMAGE_BRUSH:
		core->press_func = ImageBrushEditSelectionPress;
		core->motion_func = ImageBrushEditSelectionMotion;
		core->release_func = ImageBrushEditSelectionRelease;
		break;
	case BRUSH_TYPE_BLEND_IMAGE_BRUSH:
		core->press_func = BlendImageBrushEditSelectionPress;
		core->motion_func = BlendImageBrushEditSelectionMotion;
		core->release_func = BlendImageBrushEditSelectionRelease;
		break;
	case BRUSH_TYPE_BUCKET:
		core->press_func = BucketEditSelectionPressCallBack;
		core->motion_func = BucketEditSelectionMotionCallBack;
		core->release_func = BucketEditSelectionReleaseCallBack;
		break;
	case BRUSH_TYPE_PATTERN_FILL:
		core->press_func = PatternFillEditSelectionPressCallBack;
		core->motion_func = PatternFillEditSelectionMotionCallBack;
		core->release_func = PatternFillEditSelectionReleaseCallBack;
		break;
	case BRUSH_TYPE_GRADATION:
		core->press_func = GradationEditSelectionPressCallBack;
		core->motion_func = GradationEditSelectionMotionCallBack;
		core->release_func = GradationEditSelectionReleaseCallBack;
		break;
	case BRUSH_TYPE_BLUR:
		core->press_func = BlurToolEditSelectionPressCallBack;
		core->motion_func = BlurToolEditSelectionMotionCallBack;
		core->release_func = BlurToolEditSelectionReleaseCallBack;
		break;
	case BRUSH_TYPE_SMUDGE:
		core->press_func = SmudgeEditSelectionPressCallBack;
		core->motion_func = SmudgeEditSelectionMotionCallBack;
		core->release_func = SmudgeEditSelectionReleaseCallBack;
		break;
	case BRUSH_TYPE_MIX_BRUSH:
		core->press_func = MixBrushEditSelectionPressCallBack;
		core->motion_func = MixBrushEditSelectionMotionCallBack;
		core->release_func = MixBrushEditSelectionReleaseCallBack;
		break;
	case BRUSH_TYPE_CUSTOM_BRUSH:
		core->press_func = CustomBrushEditSelectionPress;
		core->motion_func = CustomBrushEditSelectionMotion;
		core->release_func = CustomBrushEditSelectionRelease;
		break;
	}
}

#ifdef __cplusplus
}
#endif
